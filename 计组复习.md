 

# 第1章 计算机系统概述

## 1.1 计算机发展历程

### 1.1.1 计算机硬件的发展

#### 1. 计算机的四代变化

- 第一代计算机——电子管时代
- 第二代计算机——晶体管时代
- 第三代计算机——中小规模集成电路时代
- 第四代计算机——超大规模集成电路时代

#### 2. 计算机元件的更新换代

- 摩尔定律
- 半导体存储器的发展
- 微处理器的发展

### 1.1.3 计算机的分类与发展方向

电子计算机可分为电子模拟计算机和电子数字计算机

数字计算机又可按用途分为专用计算机和通用计算机。

计算机按指令和数据流可分为：

- 单指令流和单数据流系统（SISD），即传统冯·诺依曼体系结构。



## 1.2 计算机系统层次结构

### 1.2.1 计算机系统的组成

硬件系统和软件系统共同构成了一个完整的计算机系统。硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档。

### 1.2.2 计算机硬件的基本组成

#### 1. 早期的冯·诺依曼机

特点如下：

- 计算机由==由运算器、控制器、存储器、输入设备和输出设备==5部分组成
- 指令和数据以同等地位存储在存储器中，并可按地址寻访
- 指令和数据均用二进制代码表示
- 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置
- 指令在存储器内按顺序存放，通常，指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序
- 早期的冯·诺伊曼以运算器为中心，输入/输出设备通过运算器与存储器传送数据

==存储程序的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。==

![image-20211211180757080](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211180757080.png)

#### 2. 现代计算机的组织结构

![image-20211211180839498](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211180839498.png)

#### 3. 计算机的功能部件

- 输入设备

  输入设备是主要功能将程序和数据以机器所能识别和接收的信息形式输入计算机。

- 输出设备

  输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。

- 存储器

  存储器是计算机的存储部件，用来存放程序和数据。

  存储器分为主存储器和辅助存储器。CPU能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器章的信息必须调入主存后，才能为CPU所访问。

  主存储器由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的的位数为存储字长，存储字长可以是1B(8bit)或是字节的偶数倍。

  主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。

  ![image-20211211181258236](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211181258236.png)

  - 存储体存放二进制信息
  - 地址寄存器（MAR)存放访存地址，经过地址译码后找到所选的存储单元
  - 数据寄存器（MDR）用于暂存要从存储器中读或写的信息
  - 时序控制逻辑用于产生存储器操作所需的各种时序信号

  MAR用于寻址，其位数对应着存储单元的个数。MAR的长度与PC的长度相等。

  MDR的位数和存储字长相等，一般为字节的二次幂的整数倍。

  注意MAR与MDR虽然是存储器的一部分，但在现代CPU中确实存在于CPU中的。

- 运算器

  运算器是计算机的执行部件，用于进行算术运算或逻辑运算。

  运算器的核心是算术逻辑单元（ALU）。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前三个寄存器必须存在。

  运算器内还有程序状态寄存器（PSW）。也称标志寄存器，用于存放ALU运算得到一些标志信息或处理机的状态信息。

- 控制器

  控制器是计算机的指挥中心。控制器由程序计算器（PC）、指令寄存器（IR）和控制单元（CU）组成。

  PC用来存放当前欲执行指令的地址，可以用自动加1以形成下一条指令的地址，它与主存的MAR之间有一条直接通路。

  IR用来存放当前的指令，其内容来自主存的MDR，指令的操作码OP（IR）送至CU，用以分析指令并发出各种微操作命令序列；而地址码Ad（IR）送往MAR，用以取操作数。

  ![image-20211211182102581](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211182102581.png)

  CPU和主存之间通过一组总线相连，总线中有地址、控制和数据3组信号线。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；控制线中有读/写信号线，指出数据是从CPU写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。

### 1.2.3 计算机软件的分类

#### 2. 三个级别的语言

- 机器语言。又称二进制代码语言。机器语言是计算机唯一可以直接识别和执行的语言。
- 汇编语言。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。
- 高级语言。高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。

### 1.2. 4 计算机的工作过程

#### 2. 指令执行过程的描述

- 取指令：PC→MAR→M→MAR→IR

  根据PC取指令到IR，将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读新信号送读/写信号线，主存根据地址上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。

- 分析指令：OP（IR）→CU

  指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。

- 执行指令：Ad（IR）→MAR→M→MDR→ACC

  取数操作，将IR中指令的地址码送MAR，MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至MDR，再传送到ACC中。

### 1.2.5 计算机系统的多级层次结构

![image-20211211183349944](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211183349944.png)

- 第1级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。
- 第2级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统。
- 第3级时操作系统层，它由操作系统程序实现。
- 第4级时汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。
- 第5级是高级语言层，它是面向用户的。

### 练习题

早起的冯·诺依曼以运算器为中心，且是单处理机。冯·诺依曼最根本的特征是采用“存储程序”原理，基本工作方式是控制流驱动方式。

相联存储器的特点是存储器按内容选择地址。

CPU可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的数据。

软件和硬件具有逻辑上的等效性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性。执行频繁、硬件实现代价不是很高的功能通常由硬件实现。

IR存放当前欲执行的指令，PC存放下一条指令的地址，不要将它们混淆。MAR用来存放欲访问的存储单元地址，MDR存放从存储单元取来的数据。

地址寄存器（MAR）存放访存地址，因此位数与地址码长度相同。数据寄存器（MDR）用于暂存要从存储器中读或写的信息，因此位数与存储字长相同。

8位计算机表面计算机字长位8位，即一次可以处理8位的数据；而16位表示地址码的长度。

编译程序是先完成编译后运行的程序；解释程序是一句一句翻译且边翻译边执行的程序。由于解释程序要边翻译成机器语言边执行，因此一般速度较编译程序慢。

寄存器的设置对汇编语言不透明。

全面代表计算机性能的是实际软件的运行情况。

软件和硬件在逻辑上是等效的，但不是等价的。

向后兼容指的是时间上向后兼容，即新机器兼容使用以前机器的指令系统。

CPU由运算器和控制器两个部件组成，而运算器和控制器中都含有寄存器。存储器是一个独立的部件。

相联存储器既可以按地址寻址由可以按内容寻址，为与传统存储器区别，又称按内容寻址的存储器。

在程序执行前，指令和数据需预先存放在存储器中，中央处理器可以从存储器存取代码。

解答：

存储程序是指将指令以代码的形式实现输入计算机主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定书顺序执行其他指令，直至程序执行结束。

计算机按照此原理应该具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能。

## 1.3 计算机的性能指标

### 1.3.1 计算机的性能指标

#### 1. 机器字长

机器字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8位）的整数倍。

#### 2. 数据通路带宽

数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器大小）有可能不同。

==各个子系统通过数据总线连接形成的数据传送路径称为数据通路。==

#### 3. 主存容量

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长来表示存储容量。其中，MAR的位数反映存储单元的个数，MDR的位数反映可寻址范围的最大值。

![image-20211211191309146](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211191309146.png)

#### 4. 运算速度

- 吞吐量和响应时间

  - 吞吐量：指系统在单位时间内处理请求的数量
  - 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需要结果的等待时间。

- 主频和CPU时钟周期

  - CPU时钟周期：通常为节拍脉冲或*T*周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期
  - 主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间就越短，执行指令的速度越快。

  ==CPU时钟周期 = 1/主频。主频通常以Hz为单位，1Hz表示每秒1次==

- CPI（Clock cycle Per Instruction）：即执行一条指令所需的时钟周期数。

- CPU执行时间：指运行一个程序所花费的时间

  CPU执行时间 = CPU时钟周期数/主频 = （指令条数×CPI）/主频

  CPU的性能取决于三个要素：

  - 主频（时钟频率）
  - 每条指令执行所用的时钟周期数（CPI）
  - 指令条数

  主频、CPI和指令条数是相互制约的。

- MIPS、MFLOPS、GFLOPS和TFLOPS

  - MIPS(Million Instructions Per Second)：即每秒执行多少百万条指令。MIPS = 指令条数/(执行时间×10^6^) = 主频/CPI
  - MFLOPS(Mega Floating-point Operations Per Second)：即每秒执行多少百万次浮点运算。 MFLOPS = 浮点操作次数/(执行时间×10^6^) 。
  - GFLOPS(Giga Floating-point Operations Per Second)：即每秒执行多少十亿次浮点运算。 GFLOPS =  浮点操作次数/(执行时间×10^9^）。
  - TFLOPS(Tera Floating-point Operations Per Second)：即每秒执行多少万亿次浮点运算。 TFLOPS = 浮点操作次数/(执行时间×10^12^）。

### 1.3.2 几个专业术语

- 系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。

### 练习题

CPU主频指CPU的时钟脉冲频率，CPI是指一条指令平均使用的CPU时钟数。

机器字长、指令字长和存储字长，三者在数值上可以相等也可以不等，视机器不同而定。一个存储单元中的二进制代码的位数称为存储字长。存储字长等于MDR的位数，而数据字长是数据总线一次能并行传送信息的位数。

计算机的位数，即机器字长，也就是计算机一次能处理的二进制数的长度。操作系统的位数是操作系统可寻址的位数，一般情况下可通过寄存器的位数来判断机器字长。

MFLOPS用来描述计算机的浮点运算性能，而用于科学计算的计算机主要评估浮点运算的性能

4字节 = 32位

汇编程序员可以通过指定待执行指令的地址来设置 PC（程序计数器）的值，状态寄存器、通用寄存器只有为汇编程序员可见，才能实现编程。而 IR、MAR、MDR 是 CPU 的内部工作寄存器，对程序员均不可见，所以它们被称为 “透明” 寄存器。

时钟周期即CPU频率的倒数，是最基本的时间单位。CPU周期又称机器周期，它由多个时钟周期组成。

CPI是执行一条指令所需的时钟周期数，系统结构、指令集、计算机组织都会影响CPI，而时钟频率并不会影响CPI，但可加快指令的执行速度。

吞吐率指系统在单位时间内处理请求的数量，是评价计算机系统性能的综合参数。

采用并行技术是实现高性能计算的重要途径

兼容通常在同一系列的不同型号计算机间。

![image-20211211202321237](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211202321237.png)

MAR = 16位 MDR = 32位

指令字长 = 存储字长 = 机器字长 IR、ACC、MQ、X = 32位。

寄存器之间的信息通路有： 

PC→MAR

Ad（IR）→MAR

MDR→IR

取数：MDR→ACC 存数：ACC→MDR

MDR →X

### 常见问题和易混淆知识点

1. 同一个功能既可以由软件实现又可以由硬件实现吗？

   在逻辑功能上，软件和硬件是等效的。在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。

2. 翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么?

   翻译程序是指把高级语言源程序翻译称机器语言程序的软件。

   翻译程序有两种：一种是编译程序，一种是解释程序

   汇编程序也是一种语言翻译程序，它把汇编语言程序翻译为机器语言程序。

3. 什么是透明性？透明是指什么都能看得见吗？

   在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即”看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。

   在CPU中，IR、MAR和MDR对各类程序员都是透明的。

4. 机器字长、指令字长、存储字长的区别和联系是什么？

   机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。

   指令字长：一个指令字中包含的二进制代码的位数。

   存储字长：一个存储单元存储的二进制代码的长度

# 第2章 数据的表示和运算

## 2.1 数制与编码

### 2.1.1 进位计数制及其相互转换

在计算机系统内部，所有信息都是用二进制进行编码的。这样做的原因有以下几点：

- 二进制只有两种状态，使用有了两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示0和1。
- 二进制1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了遍历条件。
- 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。

### 2.1.2 真值和机器数

![image-20211211211555525](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211211555525.png)

### 2.1.3 BCD码

![image-20211211211613955](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211211613955.png)

### 2.1.4 字符与字符串

![image-20211211211709546](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211211709546.png)

### 2.1.5 校验码

校验码是指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。

#### 1. 奇偶校验码

![image-20211211212003317](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211212003317.png)

奇校验码：整个校验码中“1”的个数为奇数

偶校验码：整个校验码中“1”的个数为偶数

![image-20211211212122915](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211212122915.png)

#### 2. 海明校验码

![image-20211211214403673](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211214403673.png)

![image-20211211214307741](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211214307741.png)

#### 3. 循环冗余校验码（CRC）

![image-20211211214349375](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211214349375.png)

## 2.2 定点数的表示与运算

### 2.2.1 定点数的表示

#### 1. 无符号数和有符号数的表示

在计算机中参与运算的机器数有两大类：无符号数和有符号数

- 无符号数：指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为8位，则数的表示范围为0~ 2^8^-1，即0~255
- 有符号数：有符号数用“0”表示“正”号，用“1”表示“负”号

有符号数的机器表示有原码、补码、反码和移码。

#### 2. 机器数的定点表示

定点表示即约定机器数中的小数点位置是固定不变的，小数点不再使用“.”表示，而是约定它的位置。在计算机中通常采用两种简单的约定：将小数点的位置固定在数据的最高位之前，或固定在最低位之后。一般常称为前者为定点小数，后者为定点整数。

- 定点小数

  若数据X的形式为$X = x_0.x_1x_2...x_n$（其中x~0~为符号位，x~1~ ~ x~n~是数值的有效部分，也称尾数，x~1~为最高有效位）

  当$x_0 = 0$，$x_1$~$x_n$均为1时，X为其所能表示的最大正数，真值等于$1-2^{-n}$

  当$x_0 = 1$，$x_1$~$x_n$均为1时，X为其所能表示的最小负数，真值等于$-(1-2^{-n})$

  ![image-20211211215426074](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211215426074.png)

- 定点整数

  若数据X的形式为$X = x_0x_1x_2...x_n$（其中x~0~为符号位，x~1~ ~ x~n~是数值的有效部分，也称尾数，x~n~为最低有效位）

  ![image-20211211215559346](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211215559346.png)

  当$x_0 = 0$，$x_1$~$x_n$均为1时，X为其所能表示的最大正数，真值等于$2^n-1$

  当$x_0 = 1$，$x_1$~$x_n$均为1时，X为其所能表示的最小负数，真值等于$-(2^n-1)$

#### 3. 原码、补码、反码、移码

- 原码表示法

  - 纯小数的原码定义

    若字长为n+1，则原码小数的表示范围为$-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）。

  - 纯整数原码

    若字长为n+1，则原码整数的表示范围为$-(2^n-1) \le x \le 2^n-1$（关于原点对称）

    ==真值零的原码表示有正零和负零两种形式，即[+0]~原~ = **0**0000和[-0]~原~ = **1**0000==

- 补码表示法

  - 纯小数的补码

    若字长为n+1，则补码的表示范围为$-1 \le x \le 1-2^{-n}$（比原码多表示-1）

  - 纯整数的补码

    若字长为n+1，则补码的表示范围为$-2^n \le x \le 2^n-1$，（比原码表示多-2^n^)

    ==真值零的补码表示是唯一的，即[+0]~补~ = [-0]~补~ = 0.0000==

  - 由原码求补码、由补码求原码

    对于正数，补码与原码的表示相同，$[x]_补 = [x]_原$

    对于负数，原码符号位不变，数值部分按位取反，末位加1（即所谓“取反加1”），此规则同样适用于由补码求原码

  - 补码的算术移位

    将[x]~补~的符号位与数值位一起右移一位并一起保持原符号位的值不变，可实现除法功能。变形补码，又称模4补码，双符号位的补码小数。模4补码双符号位00表示正，11表示负，用在完成算术运算的ALU部件中。

- 反码表示法

  - 纯小数的反码

    若字长为n+1，则原码小数的表示范围为$-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）。

    ==真值零的反码表示不唯一，负数的反码符号位为”1“，数值部分求反，$[+0]_反 = 0.0000$；$[-0]_反 = 1.1111$==

  - 纯整数的反码

    若字长为n+1，则原码整数的表示范围为$-(2^n-1) \le x \le 2^n-1$（关于原点对称）

    ![image-20211211221636666](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211221636666.png)

- 移码表示法

  移码常也用来表示浮点数的阶码，它只能表示整数。

  移码就是在真值X上加一个常数（偏置值），通常这个常数取2^n^，相当于X在数轴上向正方向偏移了若干单位。

  移码具有以下特点：

  - 移码中零的表示唯一，$[+0]_移 = 2^n + 0 = [-0]_移 = 2^n-0 = 100...0$（n个“0”）
  - 一个真值的移码和补码仅差一个符号位
  - 移码全0时，对应真值的最小值-2^n^；移码全1时，对应真值的最大值2^n^-1.
  - 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。

### 2.2.2 定点数的移位运算

#### 1. 定点数的移位运算

- 算术移位

  算术移位的对象是有符号数，在移位过程中符号位保持不变。

  对于原码，左移一位若不产生溢出，相当于乘以2，右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。

  ![image-20211211222336881](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211222336881.png)

- 逻辑移位

  逻辑移位将操作数无视位符号数，移位规则：逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0.

  机器支持两种形式的右移：逻辑右移和算术右移

  - 逻辑右移是在左端补k个0
  - 算数右移是在左端补k个最高有效位的值![image-20211208034218616](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034218616.png)几乎所有的编译器/机器组合都对符号数使用算术右移。对于无符号数，右移必须是逻辑的。

- 循环移位

  循环移位分为带进位标志位CF的循环移位和不带进位标志位的循环移位。

#### 2. 原码定点数的加减法运算

设$[X]_原 = x_s.x_1x_2...x_n$和$[Y]_原 = y_s.y_1y_2...y_n$，进行加减运算的规则如下。

加法规则：先判符号位，若相同，则绝对值相加，结果符号位不变；若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。

减法规则：两个原码表示的相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算

![image-20211211223913147](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211223913147.png)

#### 3. 补码定点数加减法运算

补码运算的特点如下：

- 参与运算的两个操作数均用补码表示

- 按二进制运算规则运算，逢二进1

- 符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出。

- 补码加减法运算依据下面的公式进行。

  ![image-20211211224250295](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211224250295.png)

- 补码运算的结果亦为补码

#### 4. 符号扩展

正数的符号扩展非常简单，即原有形式的符号为移动到新形式的符号位上，新表示形式的所有附加位都用0进行扩展

负数的符号扩展方法则根据机器数的不同而不同，

- 原码表示负数的符号扩展方法与正数相同，只不过此时符号位为1。

- 补码表示负数的符号扩展法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1(对于整数)或0(对于小数)进行填充。
- 反码表示负数的符号扩展方法：原有形式的符号位移动到新形式的符号位桑，新表示形式的所有附加位都用1进行填充。

#### 5. 溢出概念和判别方法

溢出是指运算结果超过了数的表示范围。通常，称大于机器所能表示的最大整数为上溢。称小于机器所能表示的最小负数为下溢。

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出。

补码定点数加减法运算溢出判断的方法有3种：

- 采用一位符号位

  由于减法运算在机器中使用加法器实现的，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。

  设A的符号为A~s~,B的符号为B~s~,运算结果的符号为S~S~，则溢出逻辑表达式为
  $$
  V = A_sB_s \overline{S_s} + \overline{A_s} \overline{B_s}S_s
  $$
  若V= 0，表示无溢出；若V=1，表示有溢出

- 采用双符号位

  双符号位也称模4补码。运算结果的两个符号位$S_{s1}S_{s2}$相同，表示未溢出；运算结果的两个符号位$S_{s1}S_{s2}$不同，表示溢出，此时最高位符号位代表真正的符号。

  符号位$S_{s1}S_{s2}$的各种情况如下：

  - $S_{s1}S_{s2}$= 00：表示结果为正数，无溢出。
  - $S_{s1}S_{s2}$=01：表示结果正溢出
  - $S_{s1}S_{s2}$=10：表示结果负溢出
  - $S_{s1}S_{s2}$=11：表示结果为负数，无溢出

  溢出逻辑判断表达式为$V = S_{s1} \oplus S_{s2}$，若V = 0，表示无溢出；若V = 1，表示有溢出。

- 采用一位符号位根据数据位的进位情况判断溢出

  若符号位的进位C~s~与最高数位的进位C~1~相同，则说明没有溢出，否则表示发生溢出。溢出逻辑判断表达式为$V = C_s \oplus C_1$，若V = 0，表示无溢出；V =1，表示有溢出。

#### 6. 定点数的乘法运算

- 原码一位乘法

  ![image-20211211023344015](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211023344015.png)

  ![image-20211211231442806](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211231442806.png)

- 补码一位乘法（Booth算法）

  ![image-20211211231539494](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211231539494.png)

  ![image-20211211231551384](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211231551384.png)

  <img src="C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211030334427.png" alt="image-20211211030334427" style="zoom:200%;" />

  ![image-20211211030513488](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211030513488.png)

- 乘法运算总结

  ![image-20211211231830457](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211231830457.png)

#### 7. 定点数的除法运算

- 原码除法运算（不恢复余数法）

  ![image-20211211234956725](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211234956725.png)

  ![image-20211211235105887](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211235105887.png)

- 补码除法运算

  ![image-20211211235016376](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211235016376.png)

  ![image-20211211235704869](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211235704869.png)

- 除法运算总结

  ![image-20211211235820182](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211235820182.png)

### 2.2.3 C语言中的整数类型及类型转换

## 2.3 浮点数的表示与运算

### 2.3.1 浮点数的表示

#### 1. 浮点数的表示格式

通常，浮点数表示为
$$
N = r^E × M
$$
，r是浮点数阶码的底（隐含），与尾数的基数相同，通常r =2。E和M都是有符号的定点数，E称为阶码，M称为尾数。可见浮点数由阶码和尾数两部分组成。

![image-20211212000448695](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212000448695.png)

阶码是整数，阶符$J_f$和阶码的位数m共同反映浮点数的表示范围及小数点的实际位置；数符$S_f$代表浮点数的符号；尾数的位数n反应浮点数的精度。

#### 2. 规格化浮点数

为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高位必须是一个有效值。

所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。

**左规**：当浮点数运算的结果为非规格化时要规格化处理，将尾数算术左移一位、阶码减1(基数为2时)的方法称为左规，左归可能要进行多次。

**右规**：当浮点数运算的结果尾数出现溢出（双符号位为01或10时），将尾数算术右移一位、阶码加1(基数为2时)的方法称为右规。需要右规时，只需进行一次。

![image-20211212001232070](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001232070.png)

#### 4. IEEE754标准

![image-20211212001256284](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001256284.png)

IEEE754标准规定常用的浮点数格式右短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数

![image-20211212001356520](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001356520.png)

IEEE754标准的浮点数，是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。

阶码是以移码形式存储的。

![image-20211212001547860](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001547860.png)



![image-20211212001832742](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001832742.png)

![image-20211212001847609](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001847609.png)

# 第3章 存储系统

## 3.1 存储器概述

### 3.1.1 存储器的分类

##### 1. 按在计算机中的作用（层次）分类

- **主存储器**。简称主存，又称内存储器（内存）。用来存放计算机运行期间所需的大量程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。==其特点是容量较小，存取速度较快，每位价格较高。==
- **辅助存储器**。简称辅存，又称外存储器（外存），是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与CPU直接交换信息。==其特点是容量极大、存取速度较慢、单位成本较低。==
- **高速缓冲存储器**。简称Cache，位于主存和CPU之间，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们。==Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。==

##### 2. 按存储介质分类

存储器可分为磁表面存储器（磁盘、磁带）、磁心存储器半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘）

##### 3. 按存取方式分类

- 随机存取器（RAM）。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。其优点是读写方便、使用灵活，主要用作主存或高速缓冲存储器。RAM又分为静态RAM（以触发器原理寄存信息）和动态RAM（以电容充电原理寄存信息）
- 只读存储器（ROM）。
- 串行访问存储器。对存储的单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）。

##### 4. 按信息的可保存性分类

- 断电后，存储信息即消失的存储器，称为易失性存储器，如RAM
- 断电后，信息仍然保持的存储器，称为非易失性存储器，如ROM



### 3.1.2 存储器的性能指标

- 存储容量 = 存储字数 × 字长 （如1M×8位）

- 单位成本：每位价格 = 总成本/总容量

- 存储速度：数据传输率 = 数据的宽度/存储周期

  - 存取时间：存取时间是指启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。
  - 存取周期：存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作之间所需的最小时间间隔。
  - 主存带宽：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒

  ![image-20211212001915367](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212001915367.png)

### 练习题



CD_ROM即光盘，采用串行存取方式。其访问方式是顺序访问，不属于只读存储器。

16MB = 2^24^B，由于字长为32位，现按半字（2B）寻址，因此可寻址的单元数为2^23^

操作系统保存在硬盘上，首先需要将其引导到主存中，而引导程序通常存放在ROM中，程序运行时需要进行读写操作，因此应采用RAM。

![image-20211214002938548](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214002938548.png)



## 3.2 存储器的层次化结构

### 3.2.1 多级存储系统

存储系统层次结构主要体现在“Cache-主存”层次和“主存-辅存”层次。前者主要解决CPU和主存之间速度不匹配的问题，后者主要解决存储系统的容量问题。

![image-20211211162011043](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211162011043.png)

在存储体系中，Cache、主存能CPU直接交换信息，辅存则要通过主存与CPU交换信息

![image-20211211162016995](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211162016995.png)

主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的。

在“主存-辅存”这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应。对具有虚拟存储器的计算机系统而言，编程时可用的地址空间远大于主存空间。

==在“Cache-主存”层次和“主存-辅存”层次中，上一层的内容都只是下一层中内容的副本。==

### 练习题

主存和辅存之间的数据调动是由硬件和操作系统共同完成的，仅对应用级程序员透明。

## 3.3 半导体随机存储器

### 3.3.1 SRAM和DRAM

#### 1. SRAM的工作原理

SRAM的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器。

#### 2. DRAM的工作原理

DRAM具有容易集成、位价低、容量大和功耗低等有点，但DRAM的存取速度比SRAM的慢，一般用来组成大容量主存系统。

DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失。为此，每隔一定时间必须刷新，通常取2ms，这个时间称为刷新周期。常用的刷新方式有3中：

- 集中刷新：指在一个刷新周期内，利用一段固定时间，依次对存储器的所有进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。
- 分散刷新：把对每行的刷新分散到各个工作周期中。
- 异步刷新：异步刷新是前两种法方法的结合，它既可以缩短“死时间”，又能充分利用最大刷新间隔位2ms的特点。

DRAM刷新需要注意以下问题：

- 刷新对CPU是透明的，即刷新不依赖于外部的访问
- 动态RAM的刷新单位是行，因此刷新操作时仅需要行地址
- 刷新操作类似于读操作，但又有所不同。刷新操作仅给栅极电容补充电荷，不需要信息输出。

SRAM和DRAM都满足断电内容消失，但需要刷新的只有DRAM，而SRAM不需要刷新。

#### 3. 存储器的读、写周期

- RAM的读周期

  读周期与读出时间是两个不同的概念，读周期时间表示存储芯片进行两次连续读操作时所必须间隔的时间，它总是大于等于读出时间。

- RAM的写周期

#### 4. SRAM和DRAM的比较

![image-20211211162246691](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211211162246691.png)

### 3.3.2 只读存储器

#### 1. 只读存储器（ROM）的特点

- 结构简单，所以位密度比可读写存储器高。
- 具有非易失性，所以可靠性高。

#### 2. ROM的类型

- 掩模式只读存储器（MROM）

  - 优点：可靠性高，集成度高，价格便宜
  - 缺点：灵活性差

- 一次可编程只读存储器（PROM）

  允许用户利用专门的设备写入自己的程序，一旦写入，内容就无法改变。

- 可擦除可编程只读存储器（EPROM）

  ERPOM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。

- 闪速存储器（Flash Memory）

  主要特点是既可以在不加电的情况下长期保存信息，又能在线进行快速擦除与重写。闪速存储器既有EPROM的价格便宜、集成度高的优点，又有E^2^PROM电可擦除重写的特点，且擦除重写的速度快。

- 固态硬盘（SSD）

  基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元组成。保留了Flash Memory长期保存信息、快速擦除与重写的特性。对比传统硬盘也具有读写速度快、低功耗的特性，缺点是价格较高。

### 3.3.3 主存储器的基本组成

![image-20211212005643058](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212005643058.png)

数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。

地址线的位数决定了主存地址空间的最大可寻址范围。

数据线数和地址线数共同反映存储体容量的大小。

### 练习题

![image-20211214005315627](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214005315627.png)

![image-20211214005405890](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214005405890.png)

![image-20211214005448934](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214005448934.png)

动态半导体存储器的特点

- 每隔一定事件，需要根据原存内容重新写入一遍
- 一次完整的刷新过程只需要占用一个存储周期

## 3.4 主存储器与CPU的连接

### 3.4.1 连接原理

- 主存储器通过数据总线、地址总线和控制总线与CPU连接。
- 数据总线的位数与工作频率的乘积正比于数据传输率
- 地址总线的位数决定了可寻址的最大内存空间。
- 控制总线指出总线周期的类型和本次输入/输出操作完成的时刻。

### 3.4.2 主存容量的扩展

- 位扩展法

  位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。![image-20211212010035952](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212010035952.png)

- 字扩展法

  字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线，数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。

  ![image-20211212010156556](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212010156556.png)

- 字位同时扩展法

  字位同时扩展是指既增加存储字的数量，又增加存储字长。

  ![image-20211212010239039](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212010239039.png)

### 3.4.3 存储芯片的地址分配和片选‘

CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行字选。

片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端。

#### 1. 线选法

优点：不需要地址译码器，线路简单。

缺点：地址空间不连续，选片的地址必须分时为低电平，不能充分理由系统的存储器空间，造成地址资源的浪费。

![image-20211212010300706](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212010300706.png)

#### 2. 译码片选法



### 3.4.4 存储器与CPU的连接

#### 1. 合理选择存储芯片

通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便。

#### 2. 地址线的连接

存储芯片的容量不同，其地址线数也不同，而CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位于存储芯片的地址线相连，以选择芯片中的某一的那元，这部分的译码是由芯片的片内逻辑完成的。

#### 3. 数据线的连接

CPU的数据线数于存储芯片的数据线数不一定相等，在相等时可直接相连；在不等时必须对存储芯片扩位，使其数据位数于CPU的数据线数相等。

#### 4. 读/写命令线的连接

#### 5. 片选线的连接

## 3.6 高速缓冲存储器

### 3.6.2 Cache的基本工作原理

Cache位于存储器层次结构的顶层，通常由SRAM构成。

![image-20211212010856294](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212010856294.png)

为便于Cache和主存之间交换信息，Cache和主存都被划分为相等的块，Cache块又称为Cache行，每块由若干字节组成，块的长度称为块长（Cache行长）。由于Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。

### Cache和主存的映射方式

由于Cache行数比主存块数少得多，因此主存只有一部分块的信息可放在Cache中，因此在Cache中要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容先当与主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。

#### 1. 直接映射

根据每个组的高速缓存行数E，高速缓存被分为不同的类。每个组只有一行（E=1）的高速缓存称为*直接映射*高速缓存。直接映射高速缓存是最容易实现和理解的。

![image-20211113225736507](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225736507.png)

高速缓存确定一个请求是否命中，然后抽取处被请求的字的过程，分为三步：1）组选择；2）行匹配；3）字抽取

**1. 直接映射高速缓存中的组选择**

在这一步中，高速缓存从*ω*的地址中间抽取出*s*个组索引位。这些位被解释成一个对应于一组号的无符号整数。

![image-20211113230233517](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113230233517.png)

**2. 直接映射高速缓存中的行匹配**

在高速缓存中很容易，选中的组只有一个高速缓存行。这个行的有效位设置了，所以我们知道标记和块中的位是有意义的。因为这个高速缓存行中的标记位与地址中的标记位相匹配。

![image-20211113230430756](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113230430756.png)

**3. 直接映射高速缓存中的字选择**

块偏移位提供了所需要的字的第一字节的偏移，字节偏移是到这个数组的一个索引。

**4. 直接映射高速缓存中不命中时的行替换**

对于直接映射高速缓存来说，每个组只包含一行，替换策略非常简单：用新取出的行替换当前的行。

#### 2. 全相联映射

全相联高速缓存是由一个包含所有高速缓存行的组(即E=C/B)组成的。

![image-20211113233413642](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233413642.png)

**1. 全相联高速缓存中的组选择**

全相联高速缓存中的组选择非常简单，因为只有一个组。地址中没有组索引位，地址只被划分成了一个标记和一个块偏移。

![image-20211113233503290](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233503290.png)

**2. 全相联高速缓存中的行匹配和字选择**

全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，它们之间的区别主要是规模大小的问题。

![image-20211113233634787](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233634787.png)

因为高速缓存电路必须并行地搜索许多相匹配的标记，构造一个又大又快的相连高速缓存很困难，而且很昂贵。因此，全相联高速缓存知识和做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器。

#### 3. 组相联映射

直接映射高速缓存中冲突不命中造成的问题源于每个组只有一行这个限制。*组相联高速缓存*放松了这条限制，所以每个组都保存有多于一个的高速缓存行。一个1<E<C/B的高速缓存通常称为E路组相联高速缓存。

![image-20211113231332116](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113231332116.png)

**1. 组相联高速缓存中的组选择**

它的组选择与直接映射高速缓存的组选择一样，组索引标识组。

**2. 组相联高速缓存中的行匹配和字选择**

组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂，因为它必须检查多个行的标记位和有效位，以确定所请求的字是否在集合中。传统的内存是一个值的数组，以地址作为输入，并返回存储在那个地址的值。另一方面，相联存储器是一个(key, value)对的数组，以key为输入，返回与输入的key相匹配的(key, value)中的value值。因此，可以把组相联高速缓存中的每个组都看成一个小的相连存储器，key是标记和有效位，而value就是块的内容。

![image-20211113232943725](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113232943725.png)

行匹配的重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行，寻找一个有效的行，其标记与地址中的标记相匹配。

![image-20211113233146248](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233146248.png)



三种映射方式中：

- 直接映射的命中率最低，全相联映射的命中率最高
- 直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长
- 直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大。

### 3.6.4 Cache中主存块的替换算法

- 随机算法
- 先进先出算法（FIFO）
- 近期最少使用（LRU）
- 最不经常使用算法（LFU）

### 3.6.5 Cache写策略

因为Cache中的内容时主存块副本，当对Cache的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。

对于Cache写命中，有两种处理方法：

- 全写法
- 写回法

对于Cache写不命中，也有两种处理方法

- 写分配法
- 非写分配法

### 练习题

Cache中存放的是主存中某一部分信息的副本

![image-20211214225748405](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214225748405.png)

Cache有16块，采用2路相联，一共是8组，从 0 开始，0 1 2 3 4 5 6 7. 主存的某一字块按模 8 映像到 Cache 中的任一字块中。比如说主存中第 0、8、16 字块是映像到 Cache 里第 0 组。现在题目告诉你每个主存块大小 32 字节，129 号单元位于第几块呢？0-31 号单元在第 0 块，32-63 号单元在第 1 块，64-95 号单元在第 2 块，96-127 号单元在第 3 块。由此可见，主存 129 号单元位于主存中第 4 块的位置。现在，主存中第 4 块应该映像到 Cache 中的第几块呢？答案很明显了吧？4 对 8 取模，自然就是装入 Cache 中的第 4 块咯。

**字块**：**主存**的数据块大小称为字块，简称块。每个块中包含 2^b 个连续的字，字块所包含的字数或字节数称为**块长**。



## 3.7 虚拟存储器

### 3.7.1 虚拟存储器的基本概念

### 3.7.6 虚拟存储器与Cache的比较

#### 1. 相同之处

- 最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度
- 都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大
- 都有地址的映射、替换算法、更新策略等问题
- 依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中

#### 2. 不同之处

- Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量
- Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明
- 对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大
- CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信

### 练习题

Cache中存放的是主存的一部分副本，TLB（快表）中存放的是Page（页表）的一部分副本。在同时具有虚拟页式存储器和Cache的系统中，CPU发出访存命令，先查找对应的Cache块。

- 若Cache命中，则说明所需内容在Cache内，其所在页面必然已调入主存中，因此Page必然命中，但TLB不一定命中
- 若Cache未命中，则并不能说明所需内容未调入主存，和TLB、Page命中与否没有关系。但若TLB命中，Page页必然命中，而当Page命中，TLB未必命中。
- ![image-20211214222820019](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214222820019.png)

快表由组相连存储器组成，因此查表速度很快，而慢表存储在主存中，快表仅是慢表的一个小副本。

# 第4章 指令系统

## 4.1 指令格式

指令是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的指令系统，也称指令集。

指令系统是计算机的主要属性，位于硬件和软件的交界面上。

### 4.1.1 指令的基本格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分：

![image-20211212023032578](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212023032578.png)

操作码指出指令中该指令应该执行什么性质的操作和具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息。

地址码给出倍操作的信息的地址，包括参与运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。

指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。

根据指令中操作数地址码的数目的不同，可将指令分称以下几种格式：

- 零地址指令

  ![image-20211214205137318](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214205137318.png)

  - 不需要操作数的指令，如空操作指令、停机指令、关中断指令
  - 零地址的运算类指令仅用在堆栈计算机中。

- 一地址指令

  ![image-20211214205232174](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214205232174.png)

  - 只有目的操作数的单操作数指令，按A~1~地址读取操作数，进行OP操作后，结果存回原地址
  - 隐含约定目的地址的双操作指令

- 二地址指令

  ![image-20211214205358252](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214205358252.png)

  指令含义：(A~1~)OP(A~2~)→A~1~

  对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果。

- 三地址指令

  ![image-20211214205523774](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214205523774.png)

  指令含义：(A~1~)OP(A~2~)→A~3~

  若地址字段均为主存地址，则完成一条三地址需要访问4次存储器（取指令1次，取两个操作数2次，存放结果1次）

- 四地址指令

  ![image-20211214205702394](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214205702394.png)
  
  指令含义：(A~1~)OP(A~2~)→A~3~， A~4~=下一条将要执行指令的地址

### 4.1.2 定长操作码指令格式

定长操作码指令在指令字的最高位部分分配固定的若干位表示操作码。一般n位操作码字段的指令系统最大能够表示2^n^条指令。

### 4.1.3 扩展操作码指令格式

![image-20211212023757357](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212023757357.png)

- 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
- 各指令的操作码一定不能重复。

通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。

设地址长度为n，上一层留出m种状态，下一层可扩展出m×2^n^种状态

### 练习题

PC存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址。

程序控制类指令用于改变程序执行的顺序，并使程序具有测试、分析、判断和循环执行的能力

中断隐指令是由硬件实现的，并不是指令系统中存在的指令。

特权指令是指仅用于操作系统或其他系统软件的指令。为确保系统与数据安全起见。

零地址的运算类指令又称堆栈运算指令，参与的两个操作数来自栈顶和次栈顶单元。

指令的地址个数与指令的长度是否固定没有必然联系，即使是单地址指令也可能由于单地址的寻址方式不同而导致指令长度不同 

## 4.2 指令的寻址方式

寻址方式是指指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。

指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址。

### 4.2.1 指令寻址和数据寻址

#### 1. 指令寻址

- 顺序寻址可通过程序计数器（PC）加1，自动形成下一条指令的地址
- 跳跃寻址通过转移类指令实现。跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过程序计算器（PC）给出

#### 2. 数据寻址

数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎么样计算出操作数的地址。

数据寻址的方式较多，为区别各种方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式，由此可得指令的格式如下所示：

![image-20211212024355494](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212024355494.png)

### 4.2.2 常见的数据寻址方式

- 隐含寻址：有利于缩短指令字长；需增加存储操作数或隐含地址的硬件

  ![image-20211212024446863](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212024446863.png)

- 立即（数）寻址

  立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短；缺点是A的位数限制了立即数的范围

- 直接寻址

  指令字中的形式地址A是操作数的真实地址EA

  ![image-20211212024604664](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212024604664.png)

  直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

- 间接寻址

  间接寻址是相对与直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。间接寻址可以是一次间接寻址，还可以是多次间接寻址。

  ![image-20211212024824173](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212024824173.png)

- 寄存器寻址

  寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即EA = R，其操作数在由R所指的寄存器内。

  寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度块，支持向量/矩阵运算；缺点是寄存器价格昂贵，计算机中的寄存器个数有限。

  ![image-20211212025111771](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212025111771.png)

- 寄存器间接寻址

  寄存器间接寻址是指在寄存器R中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA =（R）

  ![image-20211212025156145](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212025156145.png)

  寄存器间接寻址的特点是，与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存。

- 相对寻址

  相对寻址是把程序计数器（PC）的内容加上指令格式中的形式地址A而形成操作数的有效地址，

  即EA = （PC）+A，其中A是相对与当前指令地址的位移量，可正可负

  ![image-20211212025556629](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212025556629.png)

  相对寻址的优点是操作数的地址不是固定的，它随PC指的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。

- 基址寻址

  基址寻址是指将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA = （BR）+A，其中基址寄存器可采用专用寄存器，又可采用通用寄存器。

  ![image-20211212025825399](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212025825399.png)

  基址寻址的优点是可扩大寻址范围；用户不必考虑自己的程序存于主存的哪个空间区域。

- 变址寻址

  变址寻址是指有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA =(IX)+A，其中X为变址寄存器（专用)，也可用通用寄存器作为变址寄存器。

  ![image-20211212025941285](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212025941285.png)

  变址寻址的优点是可扩大寻址范围

- 堆栈寻址

  堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出(LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。堆栈可分为硬堆栈与软堆栈两种。

![image-20211212030034856](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212030034856.png)

### 练习题

间接寻址不需要寄存器

采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度

寄存器寻址中，只需指定寄存器的编号，因此能有效地缩短地址码的位数

隐地址不给出明显的操作数地址，而在指令中隐含操作数的地址，因此可以简化地址结构

立即寻址最快，指令直接给出操作数；寄存器寻址次之，只需访问一次寄存器；直接寻址再次之，访问一次内存；间接寻址最慢，要访问内存两次或以上

寄存器间接寻址取操作数的速度接近直接寻址

变址寻址便于处理数组问题。

相对寻址中，指令所提供的相对地址实质上是一种以下条指令的地址为基准位置的偏移量

在多道程序设计中，各个程序段可能要在内存中浮动，而相对寻址特别有利于程序浮动。

## 4.3 CISC和RISC的基本概念

### 4.3.1 复杂指令系统计算机（CISC）

CISC的主要特点如下：

1. 指令系统复杂庞大，指令数目一般为200条以上。
2. 指令的长度不固定，指令格式多，寻址方式多。
3. 可以访存的指令不受限制
4. 各种指令使用频度相差很大
5. 各种指令执行时间相差很大，大多数指令需要多个时钟周期才能完成。
6. 控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制
7. 难以用优化编译生成高效的目标代码程序

### 4.3.2 精简指令系统计算机（RISC）

RISC的主要特点如下：

1. 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现
2. 指令长度固定，指令格式种类少，寻址方式种类少
3. 只有Load/Store指令访存，其余指令的操作都在寄存器之间进行
4. CPU中通用寄存器的数量相当多
5. RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。
6. 以硬布线控制为主，不用或少用微程序控制。
7. 特别重视编译优化工作，以减少程序执行时间

### 4.3.3 CISC和RISC的比较

- RISC更能充分利用VLSI芯片的面积。CISC的控制大多采用微程序控制，其控制存储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%左右
- RISC更能提高运算速度。RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。
- RISC便于设计，可降低成本，提高可靠性。RISC指令系统简单，因此机器设计周期短；其逻辑简单，因此可靠性高。
- RISC有利于编译程序代码优化。RISC指令类型少，寻址方式少，使编译程序更容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化

![image-20211212031223563](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212031223563.png)

![image-20211212031240986](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212031240986.png)

![image-20211212031254939](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212031254939.png)

# 第5章

## 5.1 CPU的功能和基本结构

### 5.1.1 CPU的功能

CPU的具体功能包括：

1）指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2）操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU管理并产生由内存
取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3）时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有
的控制信号。
4）数据加工。对数据进行算术和逻辑运算。
5）中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。

### 5.1.2 CPU的基本结构

![image-20211212031502254](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212031502254.png)

#### 1. 运算器

运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。运算器是计算机对数据进行加工处理的中心，它主要由算术逻辑单元(ALU)、暂存寄存器、累加寄存器(ACC)、通用寄存器组、程序状态字寄存器（PSW)、移位器、计数器（CT）等组成。
1）算术逻辑单元。主要功能是进行算术/逻辑运算。
2）暂存寄存器。用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。
3）累加寄存器。它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法
运算的一个输入端。
4）通用寄存器组。如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。
5)程序状态字寄存器。保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OF)、符号标志（SF)、零标志（ZF)、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。
6）移位器。对操作数或运算结果进行移位运算。7)计数器。控制乘除运算的操作步数。

#### 2. 控制器

控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。控制器的基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。
控制器有硬布线控制器和微程序控制器两种类型
控制器由程序计数器（PC)、指令寄存器（IR)、指令译码器、存储器地址寄存器(MAR)、存储器数据寄存器(MDR)、时序系统和微操作信号发生器等组成。
1）程序计数器。用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令（通常）是顺序执行的，所以PC有自增功能。
2）指令寄存器。用于保存当前正在执行的那条指令。
3）指令译码器。仅对操作码字段进行译码，向控制器提供特定的操作信号。

4）存储器地址寄存器。用于存放要访问的主存单元的地址。
5）存储器数据寄存器。用于存放向主存写入的信息或从主存读出的信息。
6）时序系统。用于产生各种时序信号，它们都由统一时钟(CLOCK)分频得到。
7）微操作信号发生器。根据IR的内容（指令)、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。

控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。

### 练习题

汇编语言程序员可见的是程序计数器(PC)，而IR、MAR、MDR是CPU的内部工作寄存器，对程序员不可见。

数据总线的位数与处理器的位数相同，它表示CPU一次能处理的数据的位数

指令寄存器中存放当前执行的指令，不需要用户的任何干预，所以对用户是透明的。

转移指令时，需要判别转移是否成功，若成功则PC修改为转移指令的目标地址，否则下一条指令的地址仍然为PC自增后的地址。

程序计数器的位数与存储器地址的位数相等，而存储器地址取决于存储器的容量

指令寄存器中保存当前正在执行的指令，所以其位数取决于指令字长

指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能

地址译码器位于存储器

程序状态寄存器对用户不透明

CPU中的专用寄存器由程序计数器(PC)、指令寄存器(IR)、存储器数据寄存器(MDR)、存储器地址寄存器(MAR)和程序状态字寄存器(PSW)

## 5.2 指令执行过程

### 5.2.1 指令周期

CPU从主存中取出并执行一条指令的时间称为指令周期，不同指令的指令周期可能不同。

指令周期常用若干机器周期来表示

一个机器周期又包括若干时钟周期(它是CPU操作的最基本单位)。

每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数可以不等。

![image-20211214185919312](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214185919312.png)

对于无条件转移指令JMPX，在执行时不需要访问主存，只包含取值阶段（包括取值和分析）和执行阶段，所以其指令周期仅包含取值周期和执行周期。

对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存地址，取出操作数。==间址周期介于取值周期和执行周期之间。==

当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入只能中断响应阶段，又称中断周期。

一个完整的指令周期应该包括取值、间址、执行和中断4个周期。

![image-20211214190321677](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214190321677.png)

- 取值周期为了取指令（FE）
- 间址周期是为了取有效地址（IND）
- 执行周期是为了取操作数（EX）
- 中断周期是为了保存程序断点（INT）

### 5.2.2 指令周期的数据流

#### 1. 取值周期

取值周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中

![image-20211214190545393](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214190545393.png)

#### 2. 间址周期

间址周期的任务是取操作数有效地址。

![image-20211214190617762](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214190617762.png)

#### 3. 执行周期

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。

#### 4. 中断周期

中断周期的任务是处理中断请求。

![image-20211214190706207](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214190706207.png)

### 5.2.3 指令执行方案

#### 1. 单指令周期

对所有指令都选用相同的执行时间来完成，称为单指令周期方案

#### 2. 多指令周期

对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案

#### 3. 流水线方案

指令之间可以并行执行的方案，称为流水线方案。

### 练习题

即使是空操作指令，在取值才做后，PC也会加1

存取周期是指存储器进行两次独立的存储器操作所需的最小间隔时间。

指令总是从主存中读出。

取值操作是自动进行的，控制器不需要得到相应的指令。

指令周期的第一个机器周期是取值周期，即从主存中取出指令字。

机器周期通常由存取周期确定。

存储器间址通过形式地址访存，寄存器间址通过寄存器内容访存

不同长度的指令，其取值操作数可能是不同的

控制器可区分存储单元中存放的是指令还是数据

指令字长一般都取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要两次访存，取值周期等于机器周期的2倍。

指令字长一般都取字长或存储字长的整数倍，而不一定和存储字长一样大。

## 5.3 数据通路的功能和基本结构

### 5.3.2 数据通路的基本和结构

- CPU内部单总线方式
- CPU内部三总线方式
- 专用数据通路方式

![image-20211214184026520](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214184026520.png)

字母加“in”表示该部件的允许输入控制信号；字母加“out”表示该部件的允许输出控制信号

#### 1. 寄存器之间的数据传送

寄存器之间的数据传送可通过CPU内部总线完成

PC→Bus，PCout有效，PC内容送总线

Bus→MAR MARin有效，总线内容送MAR

#### 2. 主存与CPU之间的数据传送

主存与CPU之间的数据传送也要借助CPU内部总线完成。

![image-20211214184529427](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214184529427.png)

#### 3. 执行算术或逻辑运算

![image-20211214184608745](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214184608745.png)

### 练习题

ALU只能有一个输入端可与总线相连，另一输入端需通过暂存器与总线相连。

采用CPU内部总线方式的数据通路的特点：结构简单，实现容易，性能较低，存在较多的冲突线选

不采用CPU内部总线方式的数据通路的特点：结构复杂；硬件量大，不易实现，性能高，基本不存在数据冲突现象。

## 5.2 指令执行过程

### 5.2.1 指令周期

CPU从主存中取出并执行一条指令的时间称为指令周期，不同指令的指令周期可能不同。



微指令是若干微命令的结合。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含两大部分信息：

- 操作控制字段：用于产生某一步操作所需的各种操作控制信号
- 顺序控制字段：用于控制产生下一条要执行的微指令地址。

![image-20211212032158134](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212032158134.png)



![image-20211212032211916](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212032211916.png)

![image-20211212032229283](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211212032229283.png)

## 5.4 控制器的功能和工作原理

#### CPU的控制方式

控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。

- 同步控制方式
- 异步控制方式
- 联合控制方式

### 硬布线控制单元设计步骤

- 列出微操作命令的操作时间表
- 进行微操作综合
- 画出微操作命令的逻辑图

### 5.4.3 微程序控制器

- 微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。

- 微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含两大部分信息：

  - 操作控制字段，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。
  - 顺序控制字段，又称微地址码字段，用于控制产生下一条要执行的微指令地址。

- 主存储器与控制存储器

  主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器用于存放微程序，在CPU内部，用ROM实现。

- 程序与微程序

微程序是由微指令组成的，用于描述机器指令。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，计算机系统中微程序的结构和功能是透明的。

- 地址寄存器（MAR）
- 微地址寄存器（CMAR）：用于存放控制存储器的读/写微指令的地址
- 指令寄存器（IR）
- 微指令寄存器（CMDR）：用于存放从控制存储器中读出的微指令

通常，一条机器指令对应一个微程序。由于任何一条机器指令的取指令操作都是相同的。

若指令系统中具有n中机器指令，则控制存储器中的微程序数至少是n+1

#### 微指令的编码方式

- 直接编码（直接控制）方式

  ![image-20211214165326389](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214165326389.png)

  直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。

  设计微命令时，选用或不选用某个微命令，只要将表示该微命令的对应位置设置称1或0即可。每个微命令对应并控制数据通路中的一个微操作。

  这种编码的优点是简单、直观，执行速度快，操作并行性好；缺点是微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控制存储器容量极大

- 字段直接编码方式

  ![image-20211214165611791](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214165611791.png)

  将微指令的微命令字段分称若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。

  这种方式可以缩短微指令字长，但因为要通过译码电路在发出微命令，因此比直接编码方式慢。

  微命令字段分段的原则：

  - 互斥性微命令分在同一段内，相容性微命令分在不同风格段内。
  - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间
  - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3时，最多只能表示7个互斥的微命令，通常用000表示不操作。

  

#### 微指令的格式

- 水平型微指令

  - 优点：微程序短，执行速度快
  - 缺点：微指令长，编写微程序较麻烦

- 垂直型微指令

  - 优点：微指令短、简单、规整，便于编写微程序
  - 微程序长

- 混合型微指令

  微指令较短，便于编写，微程序也不长，执行速度加快

#### 硬布线和微程序控制器的特点

- 硬布线控制器的特点：

  由于控制器的速度取决于电路延迟，所以速度快

  由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能。

- 微程序控制器的特点

### 练习题

取指令阶段完成的任务是将现行指令从主存中取出并送至指令寄存器，这个操作是公共的操作，是每条指令都要进行的，与具体的指令无关，所以不需要操作码的控制。

CU（微操作控制信号）：

- 经指令译码器译码产生的指令信息
- 时序系统产生的机器周期信号和节拍信号
- 来自执行单元的反馈信息即标志

执行公用的取值微程序从主存中取出机器指令后，由机器指令的操作码字段指出各个微程序的入口地址（初始微地址）

一条微指令存放在控制器的一个控制存储单元中

5个互斥类，分别包含7、3、12、5、和6个微命令，需要3、2、4、3和3位，共15位

兼容性微命令是指那些可以同时产生、共同完成某些微操作的微命令。

微处理器是相对于一些大型处理器而言的，微程序控制器则是相对于CPU的控制器而言的。

微程序的作用是实现一条对应的机器指令。

CPU控制器主要由三个部件组成：指令寄存器、程序计数器和操作控制器。

状态寄存器通常属于运算器的部件，保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容

存储容量计算公式

 按位计算 (b)  ：     存储容量 = 存储单元个数 x 存储字长

 按字节计算 (B)：     存储容量 = 存储单元个数 x 存储字长 / 8

字节（B）与位 (b) 的关系  :   计算机里规定 1Byte = 8bit 

两种表示方法 64K x 8 位 = 64KB

![image-20211214173857312](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211214173857312.png)

## 5.5 指令流水线

#### 流水线方式的特点

- 把一个任务分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间
- 流水线每个功能段部件后面都要有一个缓冲寄存器，或称锁存器，其作用是保存本流水段的执行结果，供给给下一流水段使用
- 流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流
- 只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。
- 流水线需要有装入时间和排空时间。装入时间是指第一个任务进入到流水线到输出流水线的时间。排空时间是指最后一个任务进入到流水线到输出流水线的时间。

### 5.5.2 流水线的分类

#### 1. 部件功能级、处理机级和处理机间级流水线

部件功能级流水将复杂的算术逻辑运算组成流水线工作方式。

处理机级流水把一条指令解释过程分为多个子过程

处理机间流水是一种宏流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与下一个处理机共享的存储器中。



### 5.5.4 流水线的性能指标

#### 1. 流水线的吞吐率

在指令级流水线中，吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量。计算流水线吞吐率的最基本的公式为
$$
TP =  \frac{n}{T_k}
$$
n是任务数，T~k~是处理完n个任务所用的时间。

### 练习题

时钟周期应以各功能段最长的执行时间为准，否则用时较长的流水段功能将不能正确完成。

有三种相关可能引起指令流水线阻塞

- 结构相关，又称资源相关
- 数据相关
- 控制相关，主要由转移指令引起

超标量流水线是指在一个时钟周期内一条流水线可执行一条以上的指令

一条指令分为多段指令，由不同电路单元完成。

超标量通过内置多条流水线来同时执行多个处理器，其实质是以空间换取时间。



### 小结

CPU分为运算器和控制器。其中运算器主要负责数据的加工，即对数据进行算术和逻辑运算。控制器是整个系统的指挥中枢，对整个计算机系统进行有效的控制，包括指令控制、操作控制、事件控制和中断处理。

从时间上，取指令事件发生在“取值周期“，取数据事件发生在”执行周期“。从空间上将，从内存读取的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）

CPU每取出并执行一条指令所需的全部事件称为==指令周期==

==机器周期==是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排==机器周期长度 = 主存周期==

==时钟周期==是指计算机时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期 = 计算机主频的倒数。

由于计算机中各种指令执行所需的时间差异很大，因此为了提高CPU的运行效率，即使在同步控制的机器中，不同指令的指令周期长度都是不一致的，即指令周期对不同的指令来说不是一个固定值。

控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为==微命令==，而一组实现一定操作功能的微命令组合，构成一条==微指令==。许多条微指令组成的序列构成==微程序==，微程序完成对指令的解释执行。

指令，即指机器指令，每条指令可以完成一个独立的算术运算或逻辑运算操作。

在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。

指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。

采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，

