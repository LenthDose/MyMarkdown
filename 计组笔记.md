# 存储器部分

## 1. 存储技术

### 1.1 随机访问存储器

随机访问存储器（RAM）分为两类：静态的和动态的。

**1. 静态RAM**

SRAM将每个位存储在一个双稳态的存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有一个属性，它可以无限期地保持在两个不同的电压配置或状态之一。

![image-20211113181901532](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113181901532.png)

由于SRAM存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值。

**2. 动态RAM**

DRAM将每个位存储为一个对电容的充电。这个电容非常小，通常只有大约30毫微微法拉。DRAM存储器可以制造得非常密集——每个的单元由一个电容和一个访问晶体管组成。但是，与SRAM不同，DRAM存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。

![image-20211113182515782](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113182515782.png)

**3. 传统的DRAM**

DRAM芯片中的单元被分成*d*个超单元，每个超单元都有*ω*个DRAM单元组成。一个*d*×*ω*的DRAM总共存储了*dω*位信息。超单元被组织成一个*r*行*c*列的长方形阵列，这里*rc=d*。每个超单元有形如（*i*，*j*）的地址，这里*i*表示行，*j*表示列。

![image-20211113182610897](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113182610897.png)

每个DRAM芯片被来连接到某个称为*内存控制器*的电路，这个电路可以一次传送*ω*位到每个DRAM芯片或一次从每个DRAM芯片传出*ω*位。DRAM把超单元（*i*，*j*）的内容发回给控制器作为响应。行地址*i*称为RAS请求。列地址*j*称为CAS请求。RAS和CAS请求共享相同的DRAM地址引脚。

![image-20211113182821555](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113182821555.png)

电路设计者将DRAM组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。二维阵列组织的缺点是必须分两步发送地址，增加了访问时间。

**4. 内存模块**

DRAM芯片封装在*内存模块*中，它插到主板的扩展槽上。下图展示了一个内存模块的基本思想：用8个64Mbit的8M×8的DRAM芯片，总共存储64MB，这8个芯片编号为0~7。每个超单元存储主存的一个字节，而用相应超单元地址为$(i,j)$的8个超单元来表示主存中字节地址A处的64位字。

![image-20211113183249334](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113183249334.png)

**5. 增强的DRAM**

- 快页模式DRAM（FPM DRAM）：FPM允许对同一行连续地访问可以直接从行缓冲区得到服务。
- 扩展数据输出DRAM（EDO DRAM）：FPM DRAM的一个增强形式，它允许各个CAS信号在时间上靠得更紧密一点。
- 同步DRAM：SDRAM能够比异步的存储器更快地输出它的超单元内容。
- 双倍数据速率同步DRAM：DDR SDRAM是对SDRAM的一种增强，它通过使用两个始终沿作为控制信号，从而使DRAM的速度翻倍。
- 视频RAM：VRAM的思想与FPM DRAM类似。

**6. 非易失性存储器**

非易失性存储器即使在关电后，仍然保存着它们的信息。现在由很多种非易失性存储器，由于历史原因，虽然ROM种有的类型可以读也可以写，但是它们整体上都被称为只读存储器（Read-Only Memory，ROM）。ROM是以它们能够被重编程（写）的次数和对它们进行重编程所用的机制来区分的。

- PROM（Programmable ROM，可编程ROM）只能被编程一次。PROM的每个存储器单元有一种熔丝，只能用高电流熔断一次。
- 可擦可写编程ROM（Erasable Programmable ROM，EPROM）有一个透明的石英窗口，允许光达到存储单元。EPROM能够被擦除和重编程的次数的数量级可以达到1000次。
- 电子可擦除PROM（Electricity Erasable PROM， EEPROM）类似于EPROM，但是它不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。EEPROM能够被编程的次数的数量级可以达到10^5^次。
- 闪存是一类非易失性存储器，基于EEPROM，它已经称为了一种重要的存储技术。

存储在ROM设备种的程序通常被称为固件。当一个计算机系统通电以后，它会运行存储在ROM种的固件。一些系统的固件提供了少量基本的输入和输出函数——例如PC的BIOS例程。

**7. 访问主存**

数据流通过称为总线的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务。

![image-20211113184539361](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113184539361.png)



### 1.2 磁盘存储

磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。

**1. 磁盘构造**

磁盘是由*盘片*构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片得以固定的旋转速率旋转，通常是5400~15000转每分钟。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。

![image-20211113185354084](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113185354084.png)

整个装置通常被称为磁盘驱动器，我们通常简称为磁盘，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。

**2. 磁盘容量**

一个磁盘可以记录的最大位数称为它的最大容量，或者简称为容量。磁盘容量是由以下技术因素决定的：

- 记录密度：磁道一英寸的段种可以放入的位数。
- 磁道密度：从盘片中心出发半径上一英寸的段内可以有的磁道数。
- 面密度：记录密度与磁道密度的乘积。

一个磁盘的容量：
$$
磁盘容量=\frac{字节数}{扇区} \times \frac{平均扇区数}{磁道} \times \frac{磁道数}{表面} \times \frac{表面数}{盘片} \times \frac{盘片数}{磁盘}
$$
**3. 磁盘操作**

磁盘用读/写头来读写存储在磁性表面的位，而读写头连接到一个传动臂一端。通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为寻道。

![image-20211113192848720](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113192848720.png)

磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：

- 寻道时间：为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为*寻道时间*。寻道时间*T~seek~*依赖于读/写头以前的位置和传动臂在盘面上移动的速度。

- 旋转时间；一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读/写头下。这个步骤的性能依赖于当读/写头到达目标扇区时盘面的位置以及磁盘的旋转速度。最大旋转延迟是：
  $$
  T_{max \, rotation} = \frac{1}{RPM} \times \frac{60s}{1min}
  $$
  平均旋转时间是最大旋转延迟的一半

- 传送时间：当目标扇区的第一个位位于读/写头下时，驱动器就可以开始读或者写该扇区的内容。一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。一个扇区以秒位单位的平均传送时间：
  $$
  T_{avg \, transfer} = \frac{1}{RPM} \times \frac{1}{(平均扇区数/磁道)} \times \frac{60s}{1min}
  $$

**4. 逻辑磁盘块**

为了对操作系统隐藏复杂性，现代磁盘将它们的构造呈现为一个简单的视图，一个B个扇区大小的逻辑块的序列，磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际磁盘扇区之间的映射关系。

**5. 连接I/O设备**

有三种不同类型的设备连接到总线：

- 通用串行总线控制器是一个连接到USB总线的设备的中转机构。

- 图形卡包含硬件和软件逻辑，它们负责代表CPU在显示器上画像素。

- 主机总线适配器将一个或多个磁盘连接到I/O总线，使用的是一个特别的主机总线接口定义的通信协议。

  ![image-20211113195027201](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195027201.png)

**6. 访问磁盘**

CPU使用一种称为内存映射I/O的技术来向I/O设备发射命令。在使用内存映射I/O的系统中，地址空间中有一块地址是为与I/O设备通信保留的。每个这样的地址称为一个I/O端口。当一个设备连接到总线时，它与一个或多个端口相关联。

![image-20211113195245462](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195245462.png)

设备可以自己执行读或者写总线事务而不需要CPU干涉的过程，称为*直接内存访问（DMA）*。这种数据传送称为DMA传送。在DMA传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给CPU发送一个中断信号来通知CPU。

### 1.3 固态硬盘

固态硬盘是一种基于闪存的存储技术。一个SSD封装由一个或多个闪存芯片和闪存翻译成组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译成是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。

![image-20211113195806618](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195806618.png)

一个闪存由B个块的序列组成，每个块由P页组成。通常，页的大小是512字节~4KB，块是由32 ~ 128页组成的，块的大小为16KB~512KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页。一旦一个块磨损之后，就不能再使用了。

![image-20211113195840573](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195840573.png)

随机写很慢，有两个原因。首先，擦除块需要相对较长的时间，1ms级的，比访问页所需的时间要高一个数量级。其次，如果写操作试图修改一个包含已经有数据的页*p*，那么这个块中所有带有用数据的页都必须被复制到一个新块，然后才能进行对页*p*的写。

## 2. 存储器层次结构

一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在最高处(L0)，是少量快速的CPU寄存器，CPU可以在一个时钟周期内访问它们。接下来是一个或多个小型到中型的基于SRAM的高速缓存存储器，可以在几个CPU时钟周期内访问它们。然后是一个大的基于DRAM的主存，可以在几十到几百个始终周期内访问它们。接下来来是慢速但是容量很大的本地磁盘。

![image-20211113214941075](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113214941075.png)

### 2.1 存储器层次结构中的缓存

高速缓存（cache）是一个小而快速的存储设备，它作为存储在更大、更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存。

存储器层次结构的中心思想是，对于每个*k*，位于*k*层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。

第k+1层的存储器被划分成连续的数据对象组块，称为块。每个块都有一个唯一的地址或名字，使之区别于其他的块。块是可固定大小的，也可以是可变大小的。

![image-20211113215155327](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113215155327.png)

在任何时刻，第k层的缓存包含第k+1层块的一个子集的副本。

数据总是以块大小为传递单元在第k层和第k+1层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。一般而言，层次结构中较底层的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。
**1. 缓存命中**

当程序需要地*k*+1层的某个数据对象*d*时，它首先在当前存储在第*k*层的一个块中查找*d*。如果*d*刚好缓存在第*k*层中，那么就是所说的缓存名字。该程序直接从第*k*层读取d，根据存储器层次结构的性质，这要比从第*k*+1层读取*d*更快。

**2. 缓存不命中**

如果第*k*层中没有缓存数据对象*d*，就是*缓存不命中*。当发生缓存不命中时，第*k*层的缓存从第*k*+1层缓存中取出包含*d*的那个块，如果第*k*层的缓存已经满了，可能就会覆盖现存的一个块。

覆盖一个现存的块的过程称为*替换*或*驱逐*这个块。被驱逐的这个块有时也称为牺牲块。决定该替换哪个块是由缓存的替换策略来控制的。

**3. 缓存不命中的种类**

如果第*k*层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时被称为*冷缓存*，此类不命中称为*强制性不命中*或*冷不命中*。冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存暖身之后的稳定状态中出现。

只要发生了不命中，第*k*层的缓存就必须执行某个放置策略，确定把它从第*k*+1层中取出的块放在哪里。最灵活的替换策略是允许来自第*k*+1层的任何块放在第*k*层的任何块中。对于存储器层次结构中高层的缓存，它们是用硬件来实现的，而且速度是最优的。这个策略实现起来通常很昂贵，因为随机地放置块，定位起来代价很高。

因此，硬件缓存通常使用的是更严格的放置策略，这个策略将第*k*+1层的某个块限制放置在第*k*层块的一个小的子集中。

这种限制性的放置策略会引起一种不命中，称为*冲突不命中*，在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。

程序通常是按照一系列阶段来运行的，每个阶段访问缓存块的某个相对稳定不变的集合。

**4. 缓存管理**

存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。在每一层上，某种形式的逻辑必须管理缓存。管理缓存的逻辑可以是硬件、软件，或者是两者的结合。

### 2.2 存储器层次结构概念小结

概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：

- 利用时间局部性：由于时间局部性，同一数据对象可能会被使用多次。一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。
- 利用空间局部性：块通常包含有uoge数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。

## 3. 高速缓存存储器

由于CPU和主存之间逐渐增大的差距，系统设计者被迫在CPU寄存器文件和主存之间插入了一个小的SRAM高速缓存存储器，称为L1高速缓存。L1高速缓存的访问速度几乎和寄存器一样快，典型地是大约4个时钟周期。

![image-20211113224353042](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113224353042.png)

随着内存和主存之间的性能差距不断增大，系统设计者在L1高速缓存和主存之间又插入了一个更大的高速缓存，称为L2高速缓存，可以在大约10个时钟周期内访问到它。

### 3.1  通用的高速缓存存储器组织结构

考虑一个计算机系统，其中每个存储器地址有*m*位。形成M=2^2^个不同的地址。如图所示，这样一个机器的高速缓存被组织成一个有S=2^s^个高速缓存组的数组。每个组包含E个高速缓存行。每个行是由一个B=2^b^字节的数据块组成的，一个有效位指明这个行是否包含有意义的信息，还有*t=m-(b+s)*个标记位（是当前块的内存地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块

![image-20211113225323604](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225323604.png)

一般而言，高速缓存的结构可以用元组(S,E,B,m)来描述。高速缓存的大小C指的是所有块的大小的和。标记位和有效位不包括在内。因此，C=S×E×B。

![image-20211113225537542](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225537542.png)

### 3.2 直接映射高速缓存

根据每个组的高速缓存行数E，高速缓存被分为不同的类。每个组只有一行（E=1）的高速缓存称为*直接映射*高速缓存。直接映射高速缓存是最容易实现和理解的。

![image-20211113225736507](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225736507.png)

高速缓存确定一个请求是否命中，然后抽取处被请求的字的过程，分为三步：1）组选择；2）行匹配；3）字抽取

**1. 直接映射高速缓存中的组选择**

在这一步中，高速缓存从*ω*的地址中间抽取出*s*个组索引位。这些位被解释成一个对应于一组号的无符号整数。

![image-20211113230233517](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113230233517.png)

**2. 直接映射高速缓存中的行匹配**

在高速缓存中很容易，选中的组只有一个高速缓存行。这个行的有效位设置了，所以我们知道标记和块中的位是有意义的。因为这个高速缓存行中的标记位与地址中的标记位相匹配。

![image-20211113230430756](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113230430756.png)

**3. 直接映射高速缓存中的字选择**

块偏移位提供了所需要的字的第一字节的偏移，字节偏移是到这个数组的一个索引。

**4. 直接映射高速缓存中不命中时的行替换**

对于直接映射高速缓存来说，每个组只包含一行，替换策略非常简单：用新取出的行替换当前的行。

### 3.3 组相连高速缓存

直接映射高速缓存中冲突不命中造成的问题源于每个组只有一行这个限制。*组相联高速缓存*放松了这条限制，所以每个组都保存有多于一个的高速缓存行。一个1<E<C/B的高速缓存通常称为E路组相联高速缓存。

![image-20211113231332116](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113231332116.png)

**1. 组相联高速缓存中的组选择**

它的组选择与直接映射高速缓存的组选择一样，组索引标识组。

**2. 组相联高速缓存中的行匹配和字选择**

组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂，因为它必须检查多个行的标记位和有效位，以确定所请求的字是否在集合中。传统的内存是一个值的数组，以地址作为输入，并返回存储在那个地址的值。另一方面，相联存储器是一个(key, value)对的数组，以key为输入，返回与输入的key相匹配的(key, value)中的value值。因此，可以把组相联高速缓存中的每个组都看成一个小的相连存储器，key是标记和有效位，而value就是块的内容。

![image-20211113232943725](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113232943725.png)

行匹配的重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行，寻找一个有效的行，其标记与地址中的标记相匹配。

![image-20211113233146248](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233146248.png)

### 3.4 全相联高速缓存

全相联高速缓存是由一个包含所有高速缓存行的组(即E=C/B)组成的。

![image-20211113233413642](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233413642.png)

**1. 全相联高速缓存中的组选择**

全相联高速缓存中的组选择非常简单，因为只有一个组。地址中没有组索引位，地址只被划分成了一个标记和一个块偏移。

![image-20211113233503290](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233503290.png)

**2. 全相联高速缓存中的行匹配和字选择**

全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，它们之间的区别主要是规模大小的问题。

![image-20211113233634787](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233634787.png)

因为高速缓存电路必须并行地搜索许多相匹配的标记，构造一个又大又快的相连高速缓存很困难，而且很昂贵。因此，全相联高速缓存知识和做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器。

## 4. 高速缓存参数的性能影响

有许多指标来衡量高速缓存的性能：

- 不命中率：在一个程序执行或程序的一部分执行期间，内存引用不命中的比率。它是这样计算的：不命中数量/引用数量
- 命中率：命中的内存引用比。它等于1-不命中率
- 命中时间：从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。对于L1高速缓存来说，命中时间的数量级是几个时钟周期。
- 不命中处罚：由于不命中所需要的额外的时间。L1不命中需要从L2得到服务的除法，通常是数10个周期



