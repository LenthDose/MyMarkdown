# 第1章 UML类图实训

## 1.1 知识讲解

### 1.1.1 UML概述

UML(United Modeling Language, 统一建模语言): 是一种基于面向对象的可视化建模语言. UML 采用了一组形象化的图形(如类图)符号作为建模语言, 使用这些符号可以形象地描述系统的各个方面 UML 通过建立图形之间的各种关系(如类与类之间的关系)来描述模型.

UML主要包括以下4个组成部分：

- 视图（View）：UML视图用于从不同的角度来表示待建模系统。UML视图包括用户视图、结构视图、行为视图、实现视图和环境视图。
  - 用户视图：以用户的观点表示系统的目标，它是所有视图的核心，用于描述系统的需求
  - 结构视图：表示系统的静态行为，描述系统的静态元素（如包、类与对象），以及它们之间的关系
  - 行为视图：表示系统的动态行为，描述系统的组成元素（如对象）在系统运行时的交互关系
  - 实现视图：表示系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系
  - 环境视图：表示系统中物理元素的分布，描述系统中硬件设备以及它们之间的关系
- 图（Diagram）：UML2.0提供了13种图。其中各视图对应的图为：
  - 用户视图→用例图
  - 结构视图→类图、对象图、包图、组合结构图
  - 行为视图→状态图、活动图、顺序图、通信图、定时图、交互概览图
  - 实现视图→组件图
  - 环境视图→部署图
- 模型元素（Model Element）
- 通用机制（General Mechanism）

### 1.1.2 类的UML表示

在UML类图中，类一般由三部分组成。

- 第一部分是类名：每个类都必须有一个名字，类名是一个字符串

- 第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。类可以有任意多个属性，也可以没有属性。

  UML规定属性的表示方式为：

  > 可见性 名称：类型 [ = 默认值]

  其中：

  - “可见性”表示该属性对于类外的元素是否可见，==包括公有（public）、私有（private）和受保护（protected）三种，在类图中分别用符号+、-和#表示。==
  - “名称”表示属性名，用一个字符串表示
  - “类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型
  - “默认值”是一个可选项，即属性的初始值

- 第三部分是类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，操作是类的成员方法。

  UML规定操作的表示方式为：

  > 可见性 名称([ 参数列表 ])[：返回类型]

  - “可见性”的定义与属性的可见性定义相同
  - “名称”即操作名或方法名，用一个字符串表示
  - “参数列表”表示操作的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。
  - “返回类型”表示操作的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型



### 1.1.3 类之间的关系

#### 1. 关联关系

关联关系是类于类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象于另一类对象之间有联系。它使一个类知道另一个类的属性和方法。

- ==双向关联==默认情况下，关联是双向的

  ![image-20211209201833027](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209201833027.png)

- ==单向关联==。例如顾客（Customer）拥有地址（Address），则Customer类与Address类具有单向关联关系

  ![image-20211209202056169](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209202056169.png)

  ```java
  class Driver {  
      //使用成员变量形式实现关联  
      Car mycar;  
      public void drive(){  
          mycar.run();  
      }  
      ...  
      //使用方法参数形式实现关联  
      public void drive(Car car){  
          car.run();  
      }  
  }  
  ```

- ==自关联==。在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。

  ![image-20211209204732932](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209204732932.png)

- ==多重性关联==。多重性关联关系又称为重数性关联关系，表示两个关联对象在数量上的对应关系。

  | 表示方式 | 多重性说明                                               |
  | -------- | -------------------------------------------------------- |
  | 1..1     | 表示另一个类的一个对象只与一个该类对象有关系             |
  | 0..*     | 表示另一个类的一个对象与零个或多个该类对象有关系         |
  | 1..*     | 表示另一个类的一个对象与一个或多个该类对象有关系         |
  | 0..1     | 表示另一个类的一个对象没有或只与一个该类对象有关系       |
  | m..n     | 表示另一个类的一个对象与最少m、最多n个类对象有关系(m<=n) |

  例如，一个表单可以拥有零个或多个按钮，但一个按钮只能属于一个表单。

  ![image-20211209205418686](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209205418686.png)

- ==聚合关系==。表示一个整体与部分的关系。在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。

  ```java
  class Driver {  
      //使用成员变量形式实现聚合关系  
      Car mycar;  
      public void drive(){  
          mycar.run();  
      }  
  }  
  ```

  ![image-20211209205919582](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209205919582.png)

- ==组合关系==也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。例如，人的头（Head）与嘴巴（Mouth），如果头没了，嘴巴也就没了。

  ```java
  public Driver(Car car){  
      mycar = car;  
  }  
  ```
  
  ![image-20211209210431760](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209210431760.png)
  
  

#### 2. 依赖关系

依赖关系是一种使用，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。

```java
class Car {  
    public static void run(){  
        System.out.println("汽车在奔跑");  
    }  
}  
  
class Driver {  
    //使用形参方式发生依赖关系  
    public void drive1(Car car){  
        car.run();  
    }  
    //使用局部变量发生依赖关系  
    public void drive2(){  
        Car car = new Car();  
        car.run();  
    }  
    //使用静态变量发生依赖关系  
    public void drive3(){  
        Car.run();  
    }  
} 

```

在系统实施阶段，依赖关系通常通过三种方式来实现：

- 将一个类的对象作为另一个类中方法的参数
- 在一个类的方法中将另一个类的对象作为其局部变量
- 在一个类的方法中调用另一个类的静态方法

![image-20211209211005636](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209211005636.png)

#### 3. 泛化关系

泛化关系也就是继承关系，泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。

![image-20211209211813890](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211209211813890.png)

#### 4. 接口与实现关系

接口之间也可以与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。

![image-20211210210537412](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210210537412.png)

但总的来说，后几种关系所表现的强弱程度依次为： **组合 > 聚合 > 关联 > 依赖；**



# 第2章

### 2.1.2 单一职责原则（Single Responsibility Principal ，SRP）

单一职责原则定义如下：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

原理：在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。

### 2.1.3 开闭原则（Open-Close Principal， OCP）

定义：一个软件实体如类、模块和函数应该对扩展开发、对修改关闭。

实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现。在面向对象设计种，开闭原则一般通过在原有模块中添加抽象层（如接口或抽象类）来实现。

实例：

- 原始UML图

  ![image-20211210141820969](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210141820969.png)

- 实例重新构造

  ![image-20211210145114915](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210145114915.png)



### 2.1.4 里氏代换原则（Liskov Substitution Principal， LSP）

**定义1**：如果对每一个类型为T1的对象o1 ， 都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。

**定义2**：所有引用基类的地方必须能透明地使用其子类的对象

里氏替换原则通俗的来讲就是：==子类可以扩展父类的功能，但不能改变父类原有的功能。==它包含以下4层含义：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

在运用里氏代换原则时，尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量针对基类对象进行编程。

实例分析：

- 原始UML图

  ![image-20211210150658682](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210150658682.png)

- 重构类图

  ![image-20211210151038992](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210151038992.png)

### 2.1.5 依赖倒转原则（Dependecny Inversion Principal， DIP）

**定义**：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖于细节，细节应当依赖于抽象。

依赖倒置原则的核心思想是面向接口编程。

**实例**：

- 原始UML图

  ![image-20211210160012797](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210160012797.png)

- 重构UML图

  ![image-20211210160251874](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210160251874.png)

==开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。==它们相辅相成，相互补充，目标一致，只是分析问题时的角度不同而已。

### 2.1.6 接口隔离原则（Interface Segregetion Principal， ISP）

**定义**：使用多个专门的接口，而不使用单一的总接口。客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

**实例**：

- 原始UML图

  ![image-20211213172658581](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213172658581.png)

- 重构

  ![image-20211213172841930](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213172841930.png)

  

在面向对象编程语言总，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，就需要将大接口中的方法根据其职责不同分别放入不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。

### 2.1.7 合成复用原则（Composite Reuse Principal， CRP）

定义：尽量使用对象组合，而不是继承来达到复用的目的。

合成复用原则就是在一个新的对象里通过关联关系来使用一些已有的对象，使之成为新对象的一部；新对象通过委派调用已有对象的方法达到复用已有功能的目的。

通过继承来进行复用的主要问题主要在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。

一般而言，如果两个类之间使Has-A关系应使用组合或聚合，如果使Is-A关系可使用继承。

**实例**：

- 原始UML图

  ![image-20211213173322647](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213173322647.png)

- 重构

  ![image-20211213173434747](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213173434747.png)

  

### 2.1.8 迪米特法则（Law of Demeter， LoD）

定义：一个软件实体应当尽可能少地与其他实体发生相互作用。

这样，当一个模块修改时，就会尽量少地影响其他模块，扩展会相对容易。

这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。

- 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及
- 在类的结构设计上，每一个类都应当降低其成员遍历和成员函数的访问权限
- 在类的设计上，只要有可能，一个类型应设计成不变类
- 在对其他类的引用上，一个对象对其他对象的引用应当降到最低

# 第3章 创建型模式

### 设计模式的概念

设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结、使用设计模式的目的是提高代码的可重用型，让代码更容易被他人理解，并让代码具有更好的可靠性。

### 创建型模式概述

==创建型模式对类的实例化过程即对象的创建过程进行了抽象，能够使软件模块做到与对象的创建和组织无关。==

创建型模式隐藏了对象的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

### 简单工厂模式

简单工厂模式又称为静态工厂方法模式，属于==类创建型模式==。

![image-20211213165302021](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213165302021.png)

工厂类中有一个负责生产对象的静态工厂方法，系统可根据工厂方法所传入的参数，动态决定应该创建出哪一个产品类的实例。

工厂方法是静态的，而且必须是返回类型，其返回类型为抽象产品类型，即Product类型。

### 工厂方法模式

**定义**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式使一个类的实例化延迟到其子类。

工厂方法模式属于==类创建型模式==。

在工厂方法模式中，父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。

工厂方法模式有四个要素：

- 工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际编程中，有时候也会使用一个抽象类来作为与调用者交互的接口，其本质上是一样的。
- 工厂实现。在编程中，工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。
- 产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但要注意最好不要违反里氏替换原则。
- 产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。

**适用场景**

- 客户端不知道它所需要的对象的类
- 抽象工厂类通过其子类来指定创建哪个对象

**工厂方法模式结构**

![image-20211210174747147](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210174747147.png)

在系统加入新产品时，无须修改抽象工厂和抽象产品提高的接口，无须修改客户端，也无须修改其他具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样，系统的可扩展性就变得非常好，符合开闭原则。但是在添加新产品时，需要编写新的具体产品类，还要提供与之对应的具体工厂类，会增加系统类的个数，增加系统的开销。

### 抽象工厂模式

**定义**：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

抽象工厂模式属于==对象创建型模式==。

![img](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure-2x.png)

抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或相互依赖的对象。与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。

抽象工厂模式中，引入了产品等级结构和产品族的概念。

==产品等级结构是指抽象产品于具体产品所构成的继承层次关系。==

==产品族是指位于不同产品等级结构且功能相关联的产品组成的家族。==

抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。

![img](https://github.com/JackChan1999/DesignPattern/raw/master/assets/designpattern16.gif)

在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。

当抽象工厂模式退化到只有一个产品等级结构时，就变成了工厂方法模式

**抽象工厂模式优点**

当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象，这对于那些需要根据当前环境来决定其行为的软件系统来说，是一种非常使用的设计模式。

**抽象工厂模式缺点**

在该模式中，增加新的产品等级结构很困难，需要要修改抽象工厂接口和已有的具体工厂类。抽象工厂模式的这个特点称为开闭原则的倾斜性，即它以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，而不能为新的产品等级结构的增加提供这样的方便。

**适用场景**

当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。

### 建造者模式

**定义**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式属于==对象创建型模式==。

![image-20211210204340419](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210204340419.png)



**四个要素**

- 产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。
- 抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。
- 建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。
- 导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。

建造者模式将复杂对象的构件与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现对象。

使用建造者模式时，客户端不必直到产品内部组成的细节。每一个Builder都相对独立，而与其他Builder无关。

如果产品的内部变化很复杂，Builder的每一个子类都需要对应到不同的产品去执行构建操作，这就需要定义很多个具体建造类来实现这种变化，将导致系统类个数的增加。

### 原型模式

**定义**：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

原型模式是==对象创建型模式==。

![原型设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure.png)



使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。

浅克隆仅仅复制所考虑的对象，而不复制它所有引用的对象，也就是其中的成员对象并不复制。

深克隆除了本身对象被复制外，对象包含的引用也被复制，即成员对象也被复制。

深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。

原型模式的最主要缺点就是每一个类必须配备一个克隆方法，在对已有系统进行改造时难度较大，而且在实现深克隆时需要编写较为复杂的代码。

### 单例模式

**定义**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问方法。

单例模式是一种==对象创建型模式==。

单例模式的要点有三个：

- 某个类只能有一个实例
- 它必须自行创建这个实例
- 它必须自行向整个系统提供这个实例

![单例模式结构](https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh.png)

当一个系统要求一个类只有一个实例时可以使用单例模式，单例模式为系统提供 了对唯一实例的受控访问，并且可以对单例模式进行扩展获得可变数目的实例，即多例模式，可以用单例控制相似的方法来获得指定个数的实例。

单例模式根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。

### 创建类模式总结

创建类模式有5种，分别是：

- **单例模式**：用于得到内存中的唯一对象
- **工厂方法模式**：用于创建复杂对象
- **抽象工厂模式**：用于创建一组相关或相互依赖的复杂对象
- **建造者模式**：用于创建模块化的更加复杂的对象
- **原型模式**：用于得到一个对象的拷贝

采用创建类模式则可以实现面向抽象编程。客户端要求的只是一个抽象的类型，具体返回什么样的对象，由创建者来决定。再次，可以对创建对象的过程进行优化，客户端关注的只是得到对象，对对象的创建过程则不关心，因此，创建者可以对创建的过程进行优化，例如在特定条件下，如果使用单例模式或者是使用原型模式，都可以优化系统的性能。

所有的创建类模式本质上都是对对象的创建过程进行封装。

# 第4章 结构型模式

### 结构型模式概述

==结构型模式描述如何将类或者对象结合在一起形成更大的结构。==

结构性模式可以描述两种不太的东西：==类与类的实例（即对象）==。根据这一点，结构性模式可以分为==类结构型模式==和==对象结构型模式==。

类结构模式关心类的组合，可以由多个类组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。

对象结构型模式关心类与对象的组合，通过关联关系在一个类中定义另一个类的实例作为成员对象，在调用所定义的成员对象的方法。

### 适配器模式

**定义**：将一个类的接口转换成用户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适配器模式可以作为类结构型模式，也可以作为对象结构型模式

类适配器模式结构图：

![image-20211210211206081](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210211206081.png)

对象适配器模式结构图：

![image-20211210211616052](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211210211616052.png)

- Target表示抽象目标类，它表示客户端需要使用的特定领域的接口，该接口不能随意改动
- Adapter表示适配器类，它是适配器模式的核心，用于调用另一个接口，它作为一个转换器，对Adaptee接口和Target接口进行适配
  - 如果是类适配器，Adapter实现了Target接口，并继承了Adaptee类，在实现Target接口的request()方法是可以直接调用从Adaptee类继承过来的方法
  - 如果是对象适配器，Adapter继承了Target类且与Adaptee是关联关系，即在Adapter中定义了Adaptee对象，从而可调用在Adaptee中已实现的方法。
  - Adaptee表示是适配者类(被适配)，用于定义一个已经存在的接口，这个接口需要被适配
- Client类表示客户类，用于与符合Target接口的对象进行协同。

适配器模式可以将一个类的接口和另一个类的接口匹配起来，使用的前提是不能或不想修改原来的适配者接口和目标接口

### 桥接模式

**定义**：将抽象部分与实现部分分离，使它们都可以独立地变化。

桥接模式使==对象结构型模式==，又称为柄体模式或接口模式

![image-20211213021643649](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213021643649.png)

- Abstraction表示抽象类，它定义了抽象类的接口，并维护一个抽象实现类Implementor的对象
- RefinedAbstraction表示扩充的抽象类，它扩充由Abstraction定义的接口
- Implementor表示抽象实现类接口，它用于定义实现类的接口
- ConcreteImplementorA和ConcreteImplementorB表示具体实现类

桥接模式类似于多继承方案，但多继承方案往往违背了类的单一职责原则，其复用性比较差，桥接模式是比多继承方案更好的解决方法

桥接模式一般应用于“两个非常强的变化维度”。

桥接模式提供了系统的可扩充性，其实现细节对客户透明，可以对用户隐藏实现细节。

### 组合模式

**定义**：使对象组合成树型结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。

组合模式属于==对象结构型模式==

![img](https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh-indexed-2x.png?id=eb7353263feb59edb306)

- Component表示抽象构件，它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现
- Leaf表示叶子构件，在组合中表示叶子节点对象，它实现抽象构件接口声明的基本行为
- Composite表示容器构件，它定义包含子节点的构件的行为，并存储子节点，它实现抽象构件接口中定义的操作叶子构件的行为
- Client，通过Component接口控制组合构件中的对象。

组合模式对应于树型结构图。

组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。

组合模式使得客户端调用简单，客户端可以一致地使用组合结构或其中单个对象

组合模式中定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，容器对象也可以被组合。

客户代码中，任何用到叶子对象的地方都可以使用容器对象，客户端不必因为加入了新的对象构建而更改代码。

在增加新组件时可能会产生一些问题，很难对容器中的组件进行限制，难以限制一个容器中只能有某些特定的构件。

组合模式的使用将使得系统设计变得更加抽象

组合模式分为透明组合模式和安全组合模式。

### 装饰模式

**定义**：动态地给一个对象添加一些额外的职责，就扩展功能而言，它比生成子类的方式更为灵活。

装饰模式是一种==对象结构型模式==

![装饰设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/decorator/structure-indexed.png)

- Component表示抽象组件，它是定义对象的接口，可以给这些对象动态增加职责
- ConcreteComponent表示具体组件，它定义具体的组件对象，装饰器可以给它增加额外的职责
- Decorator表示抽象装饰类，它维护一个指向抽象组件的指针，并定义一组于抽象组件接口一致的方法
- ConcreteDecorator表示具体装饰类，它负责向组件添加新的职责

装饰模式比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。

装饰模式可以在不需要创造更多子类的情况下，对对象的功能加以扩展。

关联关系和继承关系相比，最主要的优势是不会被破坏封装。缺点是比继承关系要创建更多的对象。

装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。

装饰模式可分为透明装饰模式和半透明装饰模式

### 外观模式

**定义**：子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容使用。

外观模式属于==对象结构型模式==

![外观设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/facade/structure-indexed.png)

- Facade表示外观角色，客户端可以调用这个角色的方法，此角色直到相关的子系统的功能和责任
- Subsystem表示子系统橘色，一个系统可以同时有一个或多个子系统。

外观模式的外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。

外观模式的目的在于减少系统的复杂程度。

外观模式并不限制复杂应用使用子系统类，它并不增加任何系统功能，而仅仅是提供一些简单的接口。

外观模式的主要缺陷在于它不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多限制将降低系统的可变性。

### 享元模式

**定义**：运用共享技术有效地支持大量细粒度的对象。

![享元设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/flyweight/structure-indexed.png)

享元模式以共享的方式高效地支持大量的细粒度对象。享元对象能做到共享的关键是区分内部状态和外部状态。

内部状态存储在享元对象内部并且不会随环境改变而改变，因此内部状态可以共享。

外部状态是随环境改变而改变的，不可以共享的状态，享元对象的外部状态必须由客户端保存。

享元模式的优点在于它大幅度地降低内存中对象的数量。但是也使得系统更加复杂。

### 代理模式

**定义**：为其他对象提供一个代理以控制对这个对象的访问。

代理模式是一种==对象结构型模式==

![代理设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/proxy/structure-indexed.png)

1. **服务接口** （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。
2. **服务** （Service） 类提供了一些实用的业务逻辑。
3. **代理** （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。
4. **客户端** （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。

- 远程代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。
- 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象，真实对象只在需要时才会被真正创建。
- Copy-on-Write代理：虚拟代理的一种，把复制（克隆）操作延迟到客户端真正需要时才执行
- 保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限
- 缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
- 防火墙代理：保护目标不让恶意用户接近
- 同步化代理：使几个用户能够同时使用一个对象而没有冲突
- 智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。

代理模式能够协调调用者和被调用者，能够在程度上降低系统的耦合度。代理模式的缺点是请求的处理速度回变慢，并且实现代理模式需要额外的工作，有些类型的代理模式实现过程较为复杂。

# 第5章 行为型模式

### 行为型模式概述

==行为型模式是对在不同的对象之间划分责任和算法的抽象化。==行为型模式不仅仅关注类和对象本身，还重点关注它们之间的相互作用和职责划分。

行为型模式分为类行为型模式和对象行为型模式两种。

类行为型模式使用继承关系在几个类之间分配行为，主要通过多态等方式来分配父类与子类的职责

对象行为型模式则使用对象的聚合关联关系来分配行为，主要是通过对象关联等方式来分配两个或多个类的职责

根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为设计模式都属于对象行为型设计模式。



### 职责链模式

**定义**：为解除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求；将这写些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

![image-20211213170846245](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213170846245.png)

- Handler表示抽象传递者，它定义了一个处理请求的接口，并且在Handler中定义了后继对象，其后继对象类型为Handler，可以在Handeler中编写代码实现后继链的设置
- ConcreteHandler表示具体传递者，处理它所负责的请求，并可以访问链中下一个对象，当有请求发送过来时，如果能够处理请求就处理它，否则将请求转发给后继者
- Client表示客户类。

在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链，请求在这个链上传递，直到链上的某一个对象决定处理此请求。

职责链模式可以降低系统耦合度，职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持对它所有候选接收者的引用

该模式增强了给对象指派职责的灵活性，可以将这种机制与继承机制结合起来使用

对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。

如果建链不当，可能会造成循环调用，将导致系统陷入死循环。

### 命令模式

**定义**：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

![image-20211213171823907](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213171823907.png)

命令模式可以对发送者和接收者完全解耦。

- Command表示抽象命令类，它用于声明执行操作的一个接口
- ConcreteCommand表示具体命令类，它将一个接收者对象绑定与一个动作，实现在Command中声明的execute()方法，调用接收者的相关操作
- Invoker表示调用者，要求一个命令执行一个请求
- Receiver表示接收者，它实现如何执行关联请求的相关操作

命令模式是对命令封装，命令模式把发出命令的责任和执行命令的责任分隔开，委托给不同的对象。

由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易；也可以把命令对象聚合在一起，构成合成命令。

但是使用命令模式有时会导致某些系统有过多的具体命令类，某些系统可能会需要多个具体命令类。

### 解释器模式

**定义**：定义语言的文法，并且建立一个解释器来解释该语言中的句子。

![image-20211213185121843](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213185121843.png)

当有一种语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。

### 迭代器模式

**定义**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。

聚合对象拥有两个职责：一是存储内部数据；而是遍历内部数据。

![迭代器设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/iterator/structure-indexed.png)

1. **迭代器** （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。

2. **具体迭代器** （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。

3. **集合** （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。

4. **具体集合** （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。

5. **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。

   客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。

![img](https://refactoringguru.cn/images/patterns/diagrams/iterator/example-zh-2x.png)

当需要访问一个聚合对象的内容而无须暴露它的内部表示，或为聚合对象提供多种遍历方式，以及为遍历不同的聚合结构提供一个统一的接口时可使用迭代器模式。

### 中介者模式

**定义**：用一个中介对象来封装一系列的对象交互；==中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。==

![image-20211213185710687](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213185710687.png)

- Mediator表示抽象中介者，它定义了一个接口用于与各同时对象之间进行通信
- ConcreteMediator表示具体中介者，它通过协调各个同时对象来实现协作行为，了解并维护它对各个同时对象的引用
- Colleague表示抽象同事类，它定义各同事的公有方法
- ConcreteColleague表示具体同事类，其中每一个同时对象都引用一个中介者对象，且每一个同事对象在需要和其他同事对象通信时，只与它的中介者通信，它实现了抽象同事中定义的方法。

通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构。

中介者模式减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可。

### 备忘录模式

**定义**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该队恢复到先前保存的状态。

![基于嵌套类的备忘录](https://refactoringguru.cn/images/patterns/diagrams/memento/structure1-indexed.png)

- Originator表示原发器，它创建备忘录并存储其当前内部状态，还可使用备忘录爱恢复内部状态。
- Memento表示备忘录，它存储原发器的内部状态，并根据原发器来决定保存哪些内部状态。
- Caretaker表示负责人，它负责保存好备忘录，但不能对备忘录的内容进行操作或检查

备忘录模式的最大缺点就是资源消耗过大，如果类的成员变量太多，就不可避免占用大量的内存，而且每保存一次对象的状态都需要消耗内存资源。

### 观察者模式

**定义**：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

![image-20211213191312116](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213191312116.png)

- Subject表示抽象目标主题，即被观察的对象，目标需要了解其多个观察者，一个目标可以接受任意数量的观察者观察
- ConcreteSubject表示具体目标，将有关状态存入各ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知
- Observer表示抽象观察者，在一个Subject对象改变时，为那些需要获得通知的对象定义一个更新接口
- ConcreteObserver表示具体观察者，它维护一个指向ConcreteSubject对象的引用，同时存储有关状态，这些状态需和ConcreteSubject保持一致。

观察者模式的优点在于实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，类别清晰，抽象了更新接口，使得相同的数据逻辑层可以有各种各样不同的表示出。

观察者模式支持广播通信。

如果在目标之间有循环依赖的话，将会触发它们之间进行循环调用，导致系统崩溃。

### 状态模式

**定义**：允许一个对象在其内部状态改变时改变它们的行为，对象看起来似乎修改了它所属的类。

![状态设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/state/structure-zh-indexed.png)

1. **上下文** （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。

2. **状态** （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。

3. **具体状态** （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。

   状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。

4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

状态模式封装了状态的转换过程，但是它需要枚举可能的状态，因此，需要实现确定状态状态，这也导致在状态模式中增加新的状态类时将违反开闭原则，新的状态类的引入将需要修改与之能够进行转换的其他状态类的代码。

状态模式中，可以将所有与某个状态有关的行为放到一个对象里，允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。

同时它避免了状态的不一致性，因为状态的改变只使用一个状态对象而不是几个对象或属性

状态模式的使用必然会增加系统类和对象的个。

### 策略模式

**定义**：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换，策略模式使得算法的变化可独立于使用它们的客户。

![img](https://refactoringguru.cn/images/patterns/diagrams/strategy/structure-indexed-2x.png)

- Context表示环境类，它通过ConcreteStrategy对象配置其指向环境，维护一个对Strategy的引用实例，可以定义一个接口供Strategy存取其数据
- Strategy表示抽象策略类，它定义一个公共的接口给所有支持的算法，Context可以使用这个接口调用ConcreteStrategies定义的算法

策略模式是对算法的包装，它把算法的责任和算法本身分隔开，委派给不同的对象管理。

当出现新的行为时，只需要增加新的策略类。

策略模式提供了管理相关的算法组的办法，策略类的等级结构定义了一个算法或行为族。

策略模式提供了可以替换继承关系的办法。

但在使用策略模式时，客户端必须知道所有的策略类，并自行决定使用哪一个策略类。

同时，策略模式造成系统有很多的策略类，有时可以通过把依赖于环境的状态保存到客户端，而将策略类设计成可共享的，这也策略类实例可以被不同客户端使用，即可以使用享元模式来减少对象的数量。

### 模板方法模式

**定义**：用于定义以一个操作中算法的骨架，而将一些步骤延迟到子类中。

模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

==模板方法模式是一种类行为型模式。==

![模板方法设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/template-method/structure-indexed.png)

- AbstractClass表示抽象类，它定义一系列抽象的基本操作，其子类可重定义并实现一个算法的各个步骤
- ConcreteClass表示具体子类，它实现基本操作以完成子类特定算法的步骤

模板方法模式的优势在于子类定义详细的处理算法时不会改变算法的结构，它是一种代码复用的基本技术

模板方法模式的缺点在于对于不同的实现都需要定义一个子类，这会导致类的个数增加，但是更加符合类职责的分配原则，使得类的内聚性得以提高。

### 访问者模式

**定义**：表示一个作用于某对象结构中的各元素的操作，可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

![访问者设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/visitor/structure-zh-indexed.png)

1. **访问者** （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。
2. **具体访问者** （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。
3. **元素** （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。
4. **具体元素** （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。
5. **客户端** （Client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。

访问者模式的目的是封装一些施加于某种数据结构之上的操作，一旦这些操作需要修改的话，接收这个操作的数据结构则可以保持不变。

访问者模式将数据结构和作用于结构上的操作之间的耦合解脱开，使得增加一个新的访问类变得很方便。

访问者模式增加新的操作很容易，但增加新的具体元素对象困难。

访问者模式与抽象工厂模式一样，对开闭原则的支持具有倾斜性。增加新的访问者很容易，但增加新的具体元素很复杂；访问者在一定程序上破坏了封装性。

# 第6章

### 软件体系结构的概念及作用

**概念**：软件体系结构就是附属于系统之中，只要存在系统，体系结构就存在

将软件体系结构可视化的手段和产物 
软件体系结构是具有一定形式的结构化元素，即构件的集合，包括处理构件、数据构件和连接构件。

### 软件体系结构风格的概念及作用

软件体系结构风格是描述特定系统组织方式的惯用范例，强调了软件系统中通用的组织结构。
体系结构风格不是对软件进行分类的标准。它仅仅是表示描述软件的不同角度而已。
一种软件体系结构风格刻划一个具有共享结构和语义的系统家族

### 用例图

- Use-case Diagram
- 是从用户的观点对系统进行描述
- 常用于需求分析阶段，用来描述人们希望系统如何运行
- 站在外部看系统，不描述系统内部的具体操作方式

### 类图

- Class Diagram
- 用来描述类的内部结构
- 用来描述系统中类和类的关系

### 对象图

- Object Diagram
- 是类图的实例
- 与类图使用几乎相同的标志
- 不同在于显示类的对象实例，而不是实际的类

### 顺序图

- Sequence Diagram
- 用来描述随着时间的推移，对象之间是如何交互的

### 协作图/通信图

- Communication Diagram
- 描述对象间的协作关系
- 与顺序图相似，显示对象间的动态合作关系

### 状态图

- State Diagram
- 描述类的所有可能的状态以及事情发生时状态的转移条件
- 状态图是对类图的补充

### 活动图

- Activity Diagram
- 被称为UML中的流程图，也可以称为是一种特殊的状态图
- 由各种动作状态构成，每个动作包含可执行的规范说明
- 活动图描述满足用例要求所要进行的活动以及活动间的约束关系

### 构建图（组件图）

- Component Diagram
- 描述构件的物理结构和各构件的依赖关系

### 部署图（配置图）

- Deployment Diagram
- 定义软、硬件体系结构

### 软件体系结构描述语言

#### UniCon语法

- 描述构件：

  ```
  component <identifier>(构件名)
  <interface>(接口)
  <implementation>(构件实施)
  end < identifier >
  ```

- 描述接口

  ```
  interface is 
  type <component_type>
  <property_list>(属性,用于更进一步的说明)
  <player_list>(参与者,用于更进一步的说明)
  end interface
  component_type:Module|Computation|SharedData|SeqFile|Filter|Process|SchedProcess|General
  ```

- 描述构件实施

  ```
  implementation is
  <property_list>
  <variant_list>	
  end implementation
  ```

- 描述连接件

  ```
  connector <identifier>(连接件名字)
  <protocol>(协议)
  <implementation>(连接件的实现)
  end <identifier>
  ```

- 描述协议

  ```
  protocol is
  type <connetor_type>
  <property_list>
  <role_list>(角色)
  end protocol
  <connector_type>:DataAccess|FileIO|Pipe|PLBundler|PocedureCall|RemoteProcCall|RTScheduler
  ```

- 描述连接件的实现

  ```
  implementation is
  builtin
  end implementation
  ```

#### C2

- C2将软件理解为构件、端口和连接器。
- 不过构件有且只有Top和Bottom两个端口。
- 同时构件和构件之间仅通过Request和  Notification两种信息进行通讯。
- 适合描述交互式系统。

构件

```
component <identifier> is (构件名)
interface
   top_domain is(面向top的接口)
   bottom_domain is(面向bottom的接口)
      out 
         …//请求、输出方法体
      in
         …//内部、输入方法体
    [behavior]
    [context component_context]
end <identifier> 
```

![img](https://img-blog.csdnimg.cn/20190912095355494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0c2NjU2NTkwNg==,size_16,color_FFFFFF,t_70)

C2风格

- C2底层向上层索取数据，递交请求
- C2上层为下层提供数据、反馈结果，不能递交请求
- 2个构件：
  - comUI，comUser
- 1个连接件：
  - comInput

![image-20211213202537513](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213202537513.png)

C2描述

- comUI向comUser发出验证请求，userRequest(user,pw)，获取验证结果getVerity()后，显示信息。

- comUI的out事件和in事件：

  - Out：userRequest(user,pw)
  - In：getVerity()

- comUI描述

  ```
  component comUI is
  interface
    top_domain is
      out
        userRequest(user,pw)
      in
        getVerity()
      [behavior]//此处省略
  end comUI
  ```

- 收到comUI的信息userRequest(user,pw)，进行判断，之后将结果result()发回给UI

- comUser描述

  ```
  component comUser is
  interface
    top_domain is
      out 
        result()
      in 
     	  userRequest(user,pw)
  	[behavior]//此处省略
  end comUser
  ```

连接件

```
connector <identifier> conections
top_ports  top_component1; 
top_component2…
bottom_ports bottom_component
```

comInput连接件的描述

```
connector comInput connections 
top ports comUser
bottom_ports comUI
```

体系结构

```
system 系统名_1 is
     architecture 系统名 with
            instance (实例)
            instance
end 系统名_1
```

比如有2个用户信息的验证，分别是user1和user2，两个验证结果，分别是R1和R2

```
system 用户验证_1 is
  architecture 用户验证 with
    comUI instance user1,user2;
    comUser instance R1,R2;
end 用户验证_1
```

#### Wright

- WRIGHT将软件理解为构件、连接器、端口、角色，以及这些元素之间的联系和约束。
- CSP的描述使其有利分析复杂行为。

### 软件体系结构风格

#### 1. 管道-过滤器风格

管道-过滤器风格把系统任务分成若干连续的处理步骤，这些处理步骤通过系统的数据流连接，一个步骤的输出是下一个步骤的输入。

在管道-过滤器风格的软件体系结构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。

过滤器必须是独立的实体，它不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。

特点：

- 使得软构件具有良好的隐蔽性和高内聚、低耦合的特点
- 允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成
- 支持软件重用。重要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来
- 系统维护和增强系统性能简单
- 允许对一些如吞吐量、死锁等属性的分析
- 支持并行执行

![img](https://pic3.zhimg.com/80/v2-e028fd4095501c1ccbb1ce3d8ec3613e_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-eb4f3e8143659d5dcc62c8456974be21_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-01e49fe0f2a02b228623a0c8da3aa73c_720w.jpg)

#### 2. 面向对象风格

在面向对象体系结构中，软件工程的模块化、信息隐藏、抽象和重用原则得到了充分的体现。在这种体系结构中，数据表示和相关原语操作都被封装在抽象数据类型中。在这种风格中，对象是构件，也成为抽象数据类型的实例。对象与对象之间，通过函数调用和过程调用来进行交互。

![img](https://img-blog.csdnimg.cn/20191222103103145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

![image-20211213195152540](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211213195152540.png)

优点：

- 一个对象对外隐藏了自己的详细信息
- 对象将数据和操作封装在一起
- 继承和封装方法为对象服用提供了技术支持

缺点：

- 如果一个对象要调用另一个对象，则必须知道它的标识和名称
- 会产生连锁反应

#### 3. 事件驱动风格

事件驱动就是在当前系统的基础之上，根据事件声明和发展状况来驱动整个应用程序运行。

事件驱动体系结构的基本思想是：系统对外部的行为表现可以通过它对事件的处理来实现。在这种体系结构中，构件不再直接调用过程，而是声明事件。系统其他构件的过程可以在这些事件中进行注册。当触发一个事件的时候，系统会自动调用这个事件中注册的所有过程。因此，触发一个事件会引起其他构件的过程调用。

![img](https://img-blog.csdnimg.cn/20191222103121828.png)

优点：

- 事件声明者不需要知道哪些构件会响应事
- 提高了软件复用能力
- 便于系统升级

缺点：

- 构件放弃了对计算的控制权，完全由系统来决定
- 存在数据传输问题

#### 4. 分层风格

在分层风格中，系统将划分为一个层次结构。

每一层都具有高度的内聚性，包含抽象程度一致的各种构件，支持信息隐藏。

分层有助于将复杂系统划分为独立的模块，从而简化程序的设计和实现。

通过分解，可以将系统功能划分为一些具有明确定义的层，较高层是面对特定问题，较低层具有一般性。

每层都为上层提供服务，同时又利用了下层的逻辑功能。在分层体系结构中，每一层只对相邻层可见。层次之间的连接件是协议和过程调用。用以实现各层之间的交互。

![img](https://img-blog.csdnimg.cn/20191222103354587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

优点：

- 设计者可以将系统分解为一个增量的步骤序列从而完成复杂的业务逻辑。
- 每一层之多和相邻的上下两层进行交互。
- 只要给相邻层提供相同的接口。

缺点：

- 并非所有系统都能够按照层次来进行划分。
- 很难找到一种合适和正确的层次划分方法。
- 在传输数据是，需要经过多个层次。
- 多层结构难以调试。

#### 5. 数据共享风格

数据共享风格也成为仓库风格。

在这种风格中，有两种不同类型的软件元素：一种是中央数据单元，也成为资源库，用于表示系统的当前状态；另一种是相互依赖的构件组，这些构件可以对中央数据单元实施操作。中央数据单元和构件之间可以进行信息交换，这是数据共享体系结构的技术实现基础。

根据所使用的控制策略不同，数据共享体系结构可以分为两种类型，一种是传统的数据库，另一种是黑板。

如果由输入流中的事件来驱动系统进行信息处理，把执行结构存储到中央数据单元，则这个系统就是数据库应用系统。

如果由中央数据单元的当前状态来驱动系统运行，则这个系统就是黑板应用系统。

黑板是数据共享体系结构的一个特例，用以解决状态冲突并处理可能存在的不确定性知识源。

黑板常用于信号处理，如语音和模式识别，同时在自然语言处理领域中也有广泛的应用，如机器翻译和句法分析。

一个典型的黑板系统主要包括知识源、中央控制单元、控制单元。

![img](https://img-blog.csdnimg.cn/2019122210412161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

优点：

- 便于多客户共享大量数据，而不必关心数据是何时产生的、由谁提供的及通过何种途径来提供
- 便于将构件作为知识源添加到系统中来

缺点：

- 对共享数据结构，不同知识源要达成一致
- 需要同步机制和加锁机制来保证数据的完整性和一致性，增大了系统设计的复杂度

#### 6. 解释器风格

解释器作为一种体系结构，主要用于构建虚拟机，用以弥合程序语义和计算机硬件之间的间隙。实际上，解释器是利用软件来创建的一种虚拟机，因此，解释器风格又被称为虚拟机风格。

![img](https://img-blog.csdnimg.cn/20191222105003331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

优点：

- 能够提高应用程序的抑制能力和变成语言的跨平台移植能力。
- 实际测试工作可能费城复杂，测试代价极其昂贵，具有一定的风险性。

缺点：

- 由于使用了特定了语言和自定义操作规则，因此增加了系统运行的开销。

- 解释器系统难以设计和测试。

#### 7. 反馈控制环风格

反馈控制环是一种特定的数据流结构。传统数据流结构是线性的，而控制连续循环过程的体系结构应该是环形的。

反馈控制环系统主要包括以下三个部分：

- 过程，指操纵过程变量的相关机制。
- 数据元素，指连续更新的过程变量，包括输入变量、控制变量、操纵变量和相关参考值。
- 控制器，通过控制规则来修正变量，收集过程的实际状态和目标状态，调节变量以驱动实际状态朝目标状态前进。

![img](https://img-blog.csdnimg.cn/20191222105034195.png)

优点：

- 过程控制是连续的，可以利用各种构件和相关规则来设计反馈控制环系统，实现各种功能。
- 反馈控制环结构能够处理复杂的自适应问题，机器学习就是一个例子。

### SADPBA模型

- 需求分析阶段
- 体系设计阶段
- 系统设计阶段

三个空间

- 功能设计空间
- 体系结构设计空间
- 系统设计空间

### 软件体系评估的目标

- 预测软件质量
- 分析体系结构识别设计的潜在风险，确认质量需求是否得到满足

### 质量属性的含义

说明软件整体性质的特征集合

### SAAM、ATAM评估模型的基本概念

SAAM:
场景生成-----讨论和头脑风暴的过程
SAAM评估方法-描述
1.表达清晰
2.形式多样
3.驱动场景完善
因此，场景生成与体系结构描述是迭代的。
ATAM:
