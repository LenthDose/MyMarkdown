# 第1章 计算机系统漫游

## 1.1 信息就是位+上下文

hello程序的生命周期是从一个源程序（或者说源文件开始的），即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。

源程序实际上就是一个由值0和1组成的位序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。

hello程序是以字节序列的方式储存在文件中的。

## 1.2 程序被其他程序翻译成不同的格式

为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级机器语言指令，然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的，这个翻译过程分为四个阶段完成，执行这四个阶段的程序一起构成了编译系统。

![image-20211208033512450](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033512450.png)

- 预处理阶段；预处理器（cpp）根据以字符#开头的命令，修改原始的C程序
- 编译阶段：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序
- 汇编阶段：汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。
- 链接阶段：链接器（ld）负责处理将print函数存在于的printf.o的单独的预编译文件中合并到hello.o程序中，结果得到hello文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行



## 1.4 处理器读并解释存储在内存中的指令

### 1.4.1 系统的硬件组成

![image-20211208033545832](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033545832.png)

***1.总线***

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数是一个基本的系统参数，各个系统中都不尽相同。

***2.I/O设备***

I/O设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或适配器与I/O总线相连。区别在于它们的封装方式，控制器是I/O设备本身或者系统的主印制电路板上的芯片组，而适配器是一块插在主板插槽上的卡

***3.主存***

*主存*是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

***4.处理器***

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。*处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。*

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。

处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。

寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都由唯一的名字。ALU（算术/逻辑单元）计算新的数据和地址值。CPU在指令的要求下可能会执行这些操作：加载、存储、操作、跳转

### 1.4.2运行hello程序

![image-20211208033605160](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033605160.png)

![image-20211208033614498](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033614498.png)

![image-20211208033625637](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033625637.png)

## 1.5 高速缓存

针对处理器与主存之间的差异，采用了更小更快的存储设备，称为高速缓存存储器（cache memory），作为暂时的集结区域，存放处理器近期可能会需要的信息。L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。

![image-20211208033646033](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033646033.png)

## 1.6 存储设备形成层次结构

每个计算机系统中的存储设备都被组织成了一个存储器层次结构

![image-20211208033658715](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033658715.png)

## 1.7 操作系统管理硬件

可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的此操作都必须通过操作系统。

操作系统由两个基本功能：

- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。

文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

![image-20211208033718761](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033718761.png)



### 1.7.1 进程

进程是操作系统对一个正在运行的程序的一种手写。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。

*并发运行*则是在说一个进程的指令和另一个进程的指令是交错进行的。

无论是在单核还是在多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是*上下文*，包括许多信息：比如PC和寄存器文件的当前值，以及主存的内容。

从一个进程到另一个进程的切换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。

![image-20211208033733652](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033733652.png)

### 1.7.2 线程

在现代系统中，一个进程实际上可以由多个称为*线程*的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据

### 1.7.3 虚拟内存

*虚拟内存*是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为*虚拟地址空间*

![image-20211208033749280](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033749280.png)

- 程序代码和数据：对所有的进程来说，代码是从同一固定地址开始，紧接着是和C全局变量相对的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。
- 堆：堆可以在运行时动态地扩展和收缩
- 共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域
- 栈：编译器用栈来实现函数调用，用户栈在程序执行期间可以动态地扩展和收缩
- 内核虚拟内存：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作

### 1.7.4 文件

文件就是字节序列，每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。

## 1.8 系统之间利用网络通信

当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

![image-20211208033801549](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033801549.png)

## 1.9 重要主题

### 1.9.1 Amdahl定律

定律：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速度。

若系统执行某应用程序需要时间为T<sub>old</sub>，假设系统某部分所需执行时间与该时间的比例为α，而该部分性能提升比例为k。即该部分初始所需时间为αT<sub>old</sub>，现在所需时间为(αT<sub>old</sub>)/k。因此，总的执行时间为T<sub>new</sub>=(1-α)T<sub>old</sub>+(αT<sub>old</sub>)/k=T<sub>old</sub>[(1-α)+α/k]，可以计算加速比S=T<sub>old</sub>/T<sub>new</sub>=1/(1-α)+α/k

### 1.9.2 并发和并行

**1.线程级并发**

并发是一个通用的概念，指一个同时具有多个活动的系统；

并行指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用

![image-20211208033836552](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033836552.png)

超线程：有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。

**2.指令级并行**

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。

**3.单指令、多数据并行**

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。

提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。

### 1.9.3 计算机系统中抽象的重要性

![image-20211208033848390](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033848390.png)



# 第2章 信息的表示和处理

## 2.1 信息存储

### 2.1.1 十六进制表示法

最低有效位（ least significant bit，LSB）指的是一个二进制数字中的第0位（即最低位）。

最高有效位（ most significant bit，MSB）指的是一个n位二进制数字中的n-1位，具有最高的权值2^(n-1)。

![image-20211208033939749](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033939749.png)

在C语言中，以0x或0X开头的数字常量被认为是十六进制的值。

### 2.1.2 字数据大小

每台计算机都有一个字长，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为ω的机器而言，虚拟地址的范围为0~2<sup>ω</sup>-1

32位程序或64位程序，区别在于该程序是如何编译的，而不是其运行的机器类型。

![image-20211208033955470](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208033955470.png)

### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储位连续的字节序列，对象的地址为所使用字节中最小的地址。

排列表示一个对象的字节有两个通用的规则：考虑一个ω位的整数，其中x<sub>ω-1</sub>是最高有效位，而x<sub>0</sub>是最低有效位。

小端法：从最低有效字节到最高有效字节的顺序存储对象

![image-20211208034012431](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034012431.png)

大端法：从最高有效字节到最低有效字节的顺序存储。

![image-20211208034021852](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034021852.png)

在字0x01234567中，高位字节的十六进制位0x01，而地位字节位0x67

![image-20211208034105038](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034105038.png)

可以看出，Linux32、Windows和Linux64是小端法机器，Sun是大端法机器。

### 2.1.6 布尔代数简介

![image-20211208034118721](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034118721.png)

可以将4个布尔运算扩展到位向量的运算，位向量就是固定长度为ω、由0和1组成的串。

位向量可以用来表示有限集合。

### 2.1.7 位级运算

![image-20211208034147002](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034147002.png)

确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。

位级运算的一个常见用法就是实现掩码运算，这里的掩码是一个位模式，表示从一个字中选出的位的集合。例如：掩码0xFF表示一个字的低位字节，位级运算x&0xFF生成一个由x的最低有效字节组成的值，而其他的字节就被置为0。x=0x89ABCDEF，其表达式将得到0x000000EF。

### 2.1.8 C语言中的逻辑运算

![image-20211208034205233](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034205233.png)

逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或者0，分别表示结果为TRUE或FALSE。

逻辑运算符&&和||与它们相对应的位级运算&和|之间第二哥重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

### 2.1.9 移位运算

左移：x向左移动k位，丢弃最高的k位，并在右端补k个0，移位量应该是一个0~ω-1之间的值

机器支持两种形式的右移：逻辑右移和算术右移

- 逻辑右移是在左端补k个0
- 算数右移是在左端补k个最高有效位的值

![image-20211208034218616](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034218616.png)

几乎所有的编译器/机器组合都对符号数使用算术右移。对于无符号数，右移必须是逻辑的。

## 2.2 整数表示

![image-20211208034229804](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034229804.png)

### 2.2.1 整型数据类型

![image-20211208034244468](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034244468.png)

![image-20211208034251737](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034251737.png)

### 2.2.2 无符号数的编码

**原理**：无符号数编码的定义
$$
\vec{x}=[x_{ω-1},x_{ω-2},...,x_0]\\
B2U\omega(\vec{x})\Leftrightarrow
\sum^{\omega-1}_{i=0}{x_i2_i}
$$
无符号数的二进制表示有一个很重要的属性，也就是每个介于0~2<sup>ω</sup>-1之间的数都有唯一一个ω位的值编码。

**原理**：无符号编码的唯一性

函数*B*2*U*^ω^是一个双射

### 2.2.3 补码编码

***有符号数的计算机表示负数的方式是补码形式。***在这个定义中，将字的最高有效位解释为负权。

**原理**：补码编码的定义
$$
\vec{x}=[x_{ω-1},x_{ω-2},...,x_0]\\
B2T\omega(\vec{x})\Leftrightarrow
-x_{\omega-1}2^{\omega-1}+
\sum^{\omega-1}_{i=0}{x_i2_i}
$$
最高有效位x<sub>ω-1</sub>也称为符号位，它的“权重”为-2<sup>ω-1</sup>,是无符号表示中权重的负数。符号位被设置位1时，表示值为负，设置为0时，值为非负
$$
TMin_\omega=-2^{\omega-1}\\
TMax_\omega=\sum^{\omega-2}_{i=0}2^i=2^{\omega-1}\\
B2T\omega:[0,1]^{\omega}\rightarrow[TMin_\omega,...,TMax_\omega]
$$
同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的ω位的补码编码。

**原理**：补码编码的唯一性

函数*B*2*T*<sub>ω</sub>是一个双射

![image-20211208034309962](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034309962.png)

*注意*：

- 第一：补码的范围是不对称的：
  $$
  |TMin_\omega|=|TMax_\omega|+1
  $$
  TMin没有与之对应的正数，之所以会有这样的不对称性，是因为一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位设置为0的）表示非负数。因为0是非负数，也就意味着能表示的整数比负数少一个。

- 第二：最大的无符号数值刚好比补码的最大值的两倍大一点：
  $$
  UMax_\omega=2TMax_\omega+1
  $$
  补码表示中所有表示负数的位模式在无符号表示中都变成了正数。

  关于整数数据类型的取值范围和表示，Java明确要求采用补码表示，取值范围与图2-10中的64位情况一样，在Java中，单字节数据类型称为byte，而不是char。这是位了保证无论在什么机器上运行，Java程序都能表现地完全一样

  

### 2.2.4 有符号数和无符号数之间的转换

C语言允许在各种不同的数字数据类型之间做强制类型转换

如果将有符号数强制类型转换成无符号数，将负数转换成无符号数可能会得到0。如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得到TMax。

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式

将short强制类型转换位unsigned short改变数值，但是不改变位表示。

将unsigned强制类型转换成int，底层的位表示保持不变。

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

无符号数和补码之间的关系：
$$
1+UMax_\omega=2^\omega
$$
**原理**：补码转换为无符号数
$$
TMin_\omega\leq x\leq TMax_\omega\\
T2U_\omega(x) = \left\{
  				\begin{array}{lr}
    					x+2^\omega & , x < 0\\
    					x & , x \ge 0
					  	\end{array}
				\right.
$$


如图所示，当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。

![image-20211208034519262](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034519262.png)

**原理**：无符号数转换为补码
$$
0\le u \le UMax_\omega\\
U2T_\omega(u)=\left\{
			   \begin{array}{lr}
    					u & , u \le TMax_\omega\\
    					u-2^\omega & , u > TMax_\omega
					  	\end{array}
				\right.
$$
对于小的数，从无符号到有符号的转换将保留数字的原值。对于大的数，数字将被转换为一个负数值。

![image-20211208034435271](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034435271.png)

### 2.2.5 C语言中的有符号数与无符号数

由于C语言对同时包含有符号和无符号数表达式的这种处理方式，当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的来执行这个运算。

![image-20211208034531824](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034531824.png)



### 2.2.6 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要简单地再表示的开头添加0。这种做法被称为零扩展。

**原理**：无符号数的零扩展
$$
\vec{u}=[u_{\omega-1},u_{\omega-2},...,u_0]\\
\vec{u}'=[0,...,0,u_{\omega-1},u_{\omega-2},...,u_0]\\
\omega'>\omega\\
B2U_\omega(\vec{u})=B2U_{\omega'}(\vec{u}')
$$
要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值
$$
\vec{x}=[x_{\omega-1},x_{\omega-2},...,x_0]\\
\vec{x}'=[x_{\omega-1},...,x_{\omega-1},x_{\omega-1},x_{\omega-2},...,x_0]\\
B2T_\omega(\vec{x})=B2T_{\omega'}(\vec{x}')
$$

### 2.2.7 截断数字

**原理**：截断无符号数
$$
\vec{x}=[x_{\omega-1},x_{\omega-2},...,x_0]\\
\vec{x}'=[x_{k-1},x_{k-2},...,x_0]\\
x=B2U_\omega(\vec{x})\\
x'=B2U_k(\vec{x}')\\
x'=xmod2^k
$$
所有被截取的位其权重形式都为2<sup>i</sup>，其中i>=k，因此2<sup>i</sup>mod2<sup>k</sup>=0

**原理**：截断补码数值
$$
\vec{x}=[x_{\omega-1},x_{\omega-2},...,x_0]\\
\vec{x}'=[x_{k-1},x_{k-2},...,x_0]\\
x=B2U_\omega(\vec{x})\\
x'=B2T_k(\vec{x}')\\
x'=U2T_k(xmod2^k)
$$

## 2.3 整数运算

### 2.3.1 无符号加法

参数x和y定义运算+<sup>u</sup><Sub>ω</sub>，其中0<=x,y<2<sup>ω</sup>,该操作是把整数和x+y截断为ω位得到的结果，再把这个结果看做是一个无符号数

![image-20211208034633940](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034633940.png)

**原理**：无符号数加法
$$
0 \le x, y <2^\omega的x和y有：\\
x+_{\omega}^{u}y=\left\{
				\begin{array}{lr}
				x+y, &x+y<2^\omega\\
				x+y-2^\omega,& 2^\omega\le x+y <2^{\omega+1}
				\end{array}
				\right.
$$
![image-20211208034648714](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034648714.png)

如果x+y<2<sup>ω</sup>，和的ω+1位表示中的最高位会等于0，因此丢弃它不会改变这个数值。

如果2<sup>ω</sup><=x+y<2<sup>ω+1</sup>，和的ω+1位表示中的最高位会等于1，因此丢弃它就相当于从和当中减去2<sup>ω</sup>

算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。当执行C程序时，不会将溢出作为错误而发出信号。

**原理**：检测无符号数加法中的溢出
$$
对于范围0 \le x, y \le UMax中的x和y，令s=x+_{\omega}^{u}y。\\
则对计算s，当且仅当s<x（或者s<y)时，发生了溢出
$$
**原理**：无符号数求反
$$
对于满足0 \le x<2^\omega的任意x，其\omega位的无符号逆元-_{\omega}^{u}x由下式给出\\
-_{\omega}^{u}x=\left\{
				\begin{array}{lr}
				x,& x=0\\
				2^\omega-x,& x>0
				\end{array}
				\right.
$$

### 2.3.2 补码加法

**原理**：补码加法
$$
对满足-2^{\omega-1}\le x,y \le 2^{\omega-1}-1的整数x和y，有：\\
x+_{\omega}^{t}y=\left\{
				 \begin{array}{lr}
				 x+y-2^\omega,& 2^{\omega-1}\le x+y & 正溢出\\
			x+y,& -2^{\omega-1}\le x+y \le 2^{\omega-1}&正常\\
				x+y+2^\omega,& x+y<-2^{\omega-1}&负溢出
				 \end{array}
				\right.
$$




**原理**：检测补码加法中的溢出
$$
对于满足TMin_\omega \le x,y \le TMax_\omega的x和y，令s=x+_{\omega}^{t}y。\\
当且仅当x>0,y>0，但s \le 0 时，计算s发生了正溢出。\\
当且仅当x<0,y<0，但s \ge 0 时，计算s发生了负溢出。
$$
![image-20211208034713447](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034713447.png)

### 2.3.3 补码的非

**原理**：补码的非
$$
对满足TMin_\omega\le x \le TMax_\omega的x，其补码的非-^{t}_{\omega}x由下式给出\\
-^{t}_{\omega}x=\left\{
				\begin{array}{lf}
				TMin_\omega,& x=TMin_\omega \\ 
				-x,& x>TMin_\omega
				\end{array}
				\right.
$$
也就是说，对ω位的补码加法来说，TMin<sub>ω</sub>是自己的加法的逆，而对其他任何数值x都有-x作为其加法的逆。

### 2.3.4 无符号乘法

**原理**：无符号数乘法
$$
对满足0 \le x,y \le UMax_\omega的x和y有：\\
x*\,_{\omega}^{u}y=(x \cdot y)mod\, 2^\omega
$$

### 2.3.5 补码乘法

**原理**：补码乘法
$$
对满足TMin_\omega \le x,y \le TMax_\omega的x和y有：\\
x*\,_{\omega}^{t}y=U2T_\omega((x \cdot y)mod\,2^\omega)
$$

### 2.3.6 乘以常数

**原理**：乘以2的幂
$$
设x为位模式[x_{\omega-1},\,x_{\omega-2},\,..., \, x_0]表示的无符号整数。\\
那么，对于任何k \ge 0，我们都认为[x_{\omega-1},\,x_{\omega-2},\,..., \, x_0,\,0,\,...,\,0]\\
给出了x2^k的 \omega+k位的无符号表示，这里右边增加了k个0
$$
比如，当ω=4时，11表示为[1011]。k=2时将其左移得到6位向量[101100]，即可编码为无符号数11*4=44。

**原理**：与2的幂相乘的无符号乘法
$$
C变量x和k有无符号数值x和k，且0 \le k < \omega, 则C表达式x<<k产生数值x* \,_{\omega}^{u}2^k。
$$
**原理**：与2的幂相乘的补码乘法
$$
C变量x和k有无符号数值x和k，且0 \le k < \omega, 则C表达式x<<k产生数值x* \,_{\omega}^{t}2^k。\\
$$
无论是无符号运算还是补码运算，乘以2的幂都可能会导致溢出。

由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。

### 2.3.7 除以2的幂

![image-20211208034807111](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034807111.png)

**原理**：除以2的幂的无符号除法
$$
C变量的x和k有无符号数值x和k，且0 \le k <\omega,则C表达式x>>k产生数值\lfloor x/2^k \rfloor
$$
![image-20211208034818629](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034818629.png)

**原理**：除以2的幂的补码除法，向下舍入
$$
C变量的x和k分别有补码值x和无符号数值k，且0 \le k <\omega,则当执行算术移位时\\
C表达式x>>k产生数值 \lfloor x/2^k \rfloor
$$
**原理**：除以2的幂的补码除法，向上舍入
$$
C变量x和k分别有补码值x和无符号数值k，且0 \le k <\omega，则当执行算术位移时\\
C表达式（x+(1<<k)-1)>>k产生数值 \lceil x/2^k \rceil
$$
除以2的幂可以通过逻辑或算术右移来实现，但是这种方法不能推广到除以任意常数

## 2.4 浮点数

浮点表示对形如V=x × 2^y^的有理数进行编码

### 2.4.1 二进制小数

### 2.4.2 IEEE浮点表示

IEEE浮点标准用V=(-1)<sup>s</sup>×M×2<sup>E</sup>的形式来表示一个数：

- **符号**：s决定这数负数(s=1)还是正数(s=0)，而对于数值0的符号位解释作为特殊情况处理
- **尾数**：M是一个二进制小数，它的范围是1~2-ε，或者是 0~1-ε。
- **阶码**：E的作用是对浮点数加权,这个权重是2的E次幂（可能是负数）

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

- 一个单独的符号位s直接编码符号s
- k位的阶码字段*exp*=e<sub>k-1</sub>...e<sub>1</sub>e<sub>0</sub>编码阶码E
- n位小数字段*frac*=f<sub>n-1</sub>...f<sub>1</sub>f<sub>0</sub>编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0

![image-20211208034844488](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034844488.png)

根据exp的值，被编码的值可以，被编码的的值可以分成三种不同的情况

![image-20211208034853329](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208034853329.png)

**情况1：规格化的值**

当*exp*的位模式既不全位0（数值0），也不全为1（单精度数值为255，双精度数值为2047）时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置形式表示的有符号整数。也就是说，阶码的值是E=*e*-*Bias*，其中*e*是无符号数，而*Bias*是一个等于2<sup>k-1</sup>的偏置值。

小数字段*frac*被解释为描述小数值*f*，其中0<=*f*<1。尾数定义为M=1+*f*，这种方式有时也叫做隐含的以1开头的表示。

**情况2：非规格化的值**

当阶码域为全0时，所表示的数是非规格化形式。在这种情况下，阶码值是E=1-*Bias*，而尾数的值是M=*f*，也就是小数字段的值，不包含隐含的开头的1。

**情况3：特殊值**

最后一类数值是当指阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷，当*s*=0时+∞，或者当*s*=1时是-∞。当我们把两个非常大的数相乘，或者除以0时，无穷能够表示**溢出**的结果。当小数域为非零时，结果值被称为“NaN“，即”不是一个数（Not a Number）“的缩写。

k位阶码和n位小数的浮点表示的一般属性

### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。

IEEE浮点格式定义了四种不同的舍入方式。默认的方法时找到最接近的匹配，而其他三种可用于计算上界和下界

| 方式       | 1.40 | 1.60 | 1.50 | 2.50 | -1.50 |
| ---------- | ---- | ---- | ---- | ---- | ----- |
| 向偶数舍入 | 1    | 2    | 2    | 2    | -2    |
| 向零舍入   | 1    | 1    | 1    | 2    | -1    |
| 向下舍入   | 1    | 1    | 1    | 2    | -2    |
| 向上舍入   | 2    | 2    | 2    | 3    | -1    |

### 2.4.5 浮点运算

### 2.4.6 C语言中的浮点数

当在*int*、*float*和*double*格式之间进行强制转换时，程序改变数值和位模式的原则如下：

- 从*int*转换成*float*，数字不会溢出，但可能被舍入
- 从*int*或*float*转换成*double*，因为*double*有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值
- 从*double*转换成*float*，因为范围要小一些，所以值可能溢出成+∞或-∞。另外，由于精确度较小，它还可能被舍入
- 从*float*或者*double*转换成*int*，值将会向零舍入



# 第3章 程序的机器级表示

## 3.2 程序编码

```c
linux> gcc -Og -o p p1.c p2.c 
```

命令gcc指的就是GCC C编译器。也可以简单地用cc来启动它。

编译选项-Og告诉编译器使用生成符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系难以理解。

### 3.2.1 机器级代码

对于机器级编程来说有两种抽象

- 第一种是由指令集体系结构或指令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
- 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

x86-64的机器代码和原始的C代码差别非常大

- *程序计数器*（通常称为“PC”，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它门用来实现控制或数据流中的条件变化
- 一组向量寄存器可以存放一个或多个整数或浮点数值

### 3.2.2 代码示例

机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

关于机器代码和它的反汇编表示的特性值得注意：

- x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数较少，而那些不太常用或操作数较多的指令所需字节数较多‘
- 设计指令格式的方式是，从某个给定位置开始，可以将自己唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码
- 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。

### 3.2.3 关于格式的注解

```
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	 1f - 0f
	.long	 4f - 1f
	.long	 5
0:
	.string	 "GNU"
1:
	.align 8
	.long	 0xc0000002
	.long	 3f - 2f
2:
	.long	 0x3
3:
	.align 8
4:

```

所有以“.”开头的行都是指导汇编器和链接器工作的伪指令

### 3.3.3 数据格式

由于是从16位体系结构扩展成32位的，Intel用术语“字”表示16位数据类型，32位数位“双字”，64位数“四字”。

![image-20211208155341862](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155341862.png)

大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如：数据传输指令有四个变种：*movb*(传输字节)、*movw*(传送字)、*movl*(传送双字)和*movq*(传送四字)。浮点数使用的是一组完全不同的指令和寄存器。



## 3.4 访问信息

一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

![image-20211208155408902](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155408902.png)

嵌套的方框标明的，指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以范围跟最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。

在常见的程序里不同的寄存器扮演不同的角色，其中最特别的是栈指针%rsp，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。

什么是**调用者保存**和**被调用者保存**？

> 在编译器的设计中有个概念叫做“被调用者保存”和“调用者保存”，可以近似的按子函数保存和父函数保存对应来理解，这一概念的出现完全是由于寄存器资源个数有限造成的。当父函数在调用子函数时，由于子函数可能访问到父函数用于保存数值的寄存器，为了互不干扰和造成覆盖，编译器就制定了相应的规则，%eax、%edx和%ecx被划分为“调用者保存”寄存器，顾名思义，这些寄存器上面存储的值，需要调用者（父函数）自己想办法先备份好，否则过会子函数直接使用这些寄存器时将无情的覆盖。如何备份？当然是事先压入栈中，等子函数调用完，再通过出栈恢复这些寄存器原本在父函数运行时的旧值；另外三个寄存器%ebx、%esi、%edi被划分为“被调用者保存”寄存器，同样的，这些寄存器上有值，在使用前需要被调用者（子函数）自己想办法帮调用者（父函数）进行备份，具体方法就是子函数在覆盖他们之前，先进行入栈备份，等子函数返回时，再出栈还原父函数运行时这些寄存器上的旧值。
>
> 简而言之，寄存器要被无数父函数子函数重复使用，如何合理使用寄存器？那只能是通过栈来进行备份，这样才能使得寄存器在特定的运行时段存储相应合理的值。区别仅仅是具体某个寄存器的备份工作是由父函数来操作还是由子函数来操作，这就由编译器来进行约定俗成。



### 3.4.1 操作数指示符

大多数指令又一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式。

![](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155437973.png)

源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。所以各种不同的操作数的可能性被分位三种类型：

- 第一种类型是*立即数*，用来表示常数值。书写方式是‘$’ 后面跟一个用标准C表示法表示的整数，-577或0x1F。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 第二种类型是*寄存器*，它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位和64位。用r<sub>a</sub>来表示任意寄存器a，用引用R[r<sub>a</sub>]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引
- 第三种类型是*内存引用*，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号*M*<sub>b</sub>[*Addr*]表示对存储在内存中从地址*Addr*开始的*b*个字节值的引用。

有多种不同*寻址*模式，允许不同形式的内存引用。*Imm*(*r<sub>b</sub>*,*r<sub>i</sub>*,*s*)表示的是最常用的形式。这样的引用有四个组成部分：

- 一个立即数偏转*Imm*
- 一个基址寄存器*r<sub>b</sub>*
- 一个变址寄存器*r<sub>i</sub>*
- 一个比例因子*s*，*s*必须是1、2、4或者8
- 基址和变址寄存器都必须是64位寄存器





### 3.4.2 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

最简单形式的数据传送指令——MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。主要区别在于它们操作的数据大小不同：分别是1、2、4、8字节。

![image-20211208155735061](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155735061.png)

源操作数指定的值是一个立即数，存储在寄存器中或内存中。目的操作数指定一个位置，要么是一个寄存器或者一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。寄存器部分的大小必须于指令最后一个字符（'b','w','l','q')指定的大小匹配

> 关于mov命令的后缀，肯定与内存引用中的寄存器的长度无关，而是与另一个寄存器的长度有关

大多数情况下，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高4位字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0.

MOV指令示例给出了源和目的类型的五种可能的组合

![image-20211208155751275](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155751275.png)

图3-4中记录的最后一条指令是处理64位立即数数据的。常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64立即数值作为源操作数，并且只能以i寄存器作为目的。

这两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制。每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。

![image-20211208155813328](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155813328.png)

*cltp*指令没有操作数：它总是以寄存器*%eax*作为源，*%rax*作为符号扩展结果的目的。它的效果与指令*movslq%eax,%rax*完全一致，只是编码更紧凑

### 3.4.3 数据传输示例

![image-20211208155834110](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208155834110.png)

C语言所谓的“指针”就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像*x*这样的局部变量通常时保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。

### 3.4.4 压入和弹出栈数据

栈是一种数据结构，可以添加或删除值，通过*push*操作把数据压入栈中，通过*pop*操作删除数据；属性：弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现作为一个数组，总是从数组的一段插入和删除元素。这一端被称为栈顶

![image-20211208160011800](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160011800.png)

栈向下增长，栈顶元素的地址是所有栈中元素地址中最低的。栈指针*%rsp*保存着栈顶元素的地址。

![image-20211208160027015](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160027015.png)

*pushq*指令的功能是把数据压入到栈上，*popq*指令是弹出数据。这些指令都只有一个操作数——压入的数据源和弹出的数据目的。

指令*pushq %rbp*的行为等价于两条指令：

![image-20211208160034748](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160034748.png)

它们之间的区别是在机器代码中*pushp*指令编码为1个字节，上面两条指令一共需要8个字节。

指令*popq %rax*等价于两条指令：

![image-20211208160043374](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160043374.png)

因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所有程序可以用标准的内存寻址方法访问栈内的任意位置。

pop指令是通过修改栈顶指针所指向的内存地址来实现数据删除的，实际上值仍然会保存在内存2位置，直到被另一条入栈操作覆盖。无论如何*%rsp*指向的地址总是栈顶



## 3.5 算术和逻辑操作

大多数操作都分成了指令累，这些指令类有各种不同大小操作数的变种（只有*leap*没有其他大小的变种）。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

![image-20211208160104525](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160104525.png)



### 3.5.1 加载有效地址

*加载有效地址(load effective address)*指令*leaq*实际上是*mvoq*指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![image-20211208160124003](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160124003.png)



### 3.5.2 一元和二元操作

一元操作只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器或者内存位置。

二元操作的第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或内存位置。第二个操作数可以是寄存器或内存位置，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

### 3.5.3 移位操作

移位操作，先给出移位量，第二项给出的是要移位的数。可进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器*%cl*中。

x86-64中，移位操作对*ω*位长的数据值进行操作，移位量是由*%cl*寄存器的低*m*位决定的，这里2<sup>ω</sup> = *ω*。高位会被忽略。例如，当寄存器*%cl*的十六进制值为*0xFF*时，指令*salb*会移7位，*salw*会移15位，*sall*会移31位，*salq*会移63位。

移位操作的目的操作数可以是一个寄存器或是一个内存位置

### 3.5.4 讨论

大多数指令，既可以用于无符号运算，也可以用于补码运算。

![image-20211208160219377](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160219377.png)

通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。

### 3.5.5 特殊的算术操作

两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。Intel把16字节的数称为八字(oct word)。

![image-20211208160233003](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160233003.png)

*imulq*指令由两种不同的形式。其中一种，是IMUL指令类中的一种。这种形式的*imulq*指令是一个“双操作数”乘法指令。它从两个64位操作数产生一个64位乘积。

x86-64指令集还提供了两条不同的“单操作数“乘法指令，以计算两个64位值的全128位成绩——一个是无符号乘法(*mulq*)，而另一个是补码乘法(*imulq*)。这两条指令都要求一个参数必须在寄存器*%rax*中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器*%rax*(高64位)和*%rax*(低64位)中。

有符号除法指令*idivl*将寄存器*%rdx*(高64位)和*rax*(低64位)中的128位作为被除数，而除数作为指令的操作数给出。指令将商保存在寄存器*%rax*，将余数存储在寄存器*%rdx*中。

对于大多数64位除法应用来说，被除数页常常是一个64位的值。这个值应该存放在*%rax*中，*%rdx*的位应该设置为全0(无符号运算)或者*%rax*的符号位(有符号运算)。

无符号除法使用*divq*指令。通常，寄存器*%rdx*会事先设置为0。

![img](https://img-blog.csdnimg.cn/20190202123734289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5ODU2MTY5,size_16,color_FFFFFF,t_70)

为什么高64位的寄存器用的是32位的*%edx*？

因为高64位被设置成全0，所以可用*%edx*来存储，不用*%rdx*是因为*%rdx*用来存储余数了。

## 3.6 控制

### 3.6.1 条件码

除了整数寄存器，CPU还维护着一组单个位的条件码(condition code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：

- *CF*：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
- *ZF*：零标志。最近的操作得出的结果为0。
- *SF*：符号标志。最近的操作得到的结果为负数
- *OF*：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

*leaq*指令不改变任何条件码，因为它使用来进行地址计算的。

下图中列出的所有指令都会设置条件码：

![image-20211208160407998](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160407998.png)

还有两类指令（有8、16、32和64位形式），它们只设置条件码而不改变任何其他寄存器

![image-20211208160418521](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160418521.png)

CMP指令根据两个操作数之差来设置条件码而不更新目的寄存器之外，CMP指令与SUB指令的行为是一样的。在ATT格式中，列出操作数的顺序是相反的。如果两个操作数相等，这些指令会将零标志设置为1，而其他的标志可以用来确定两个操作数之间的关系。

TEST指令的行为和AND指令一页，除了它们只设置条件码而不改变目的寄存器的值。



### 3.6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

1. 可以根据条件码的某种组合，将一个字节设置为0或者1
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件地出传送数据

根据C表达式来设置条件码：

![image-20211208160443925](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160443925.png)

将一个字节设置为0或者1，这一整类指令称为SET指令，它们之间的区别在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操作数大小。例如：指令*setl*和*setb*表示”小于时设置(*set less*)“和”低于时设置(*set below*)。

![image-20211208160601578](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160601578.png)

一条SET指令的目的操作数时低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。

某些底层的机器指令可能有多个 名字，称之为“同义名”，编译器和反汇编器会随意决定使用哪个名字。

虽然所有的算术和逻辑操作都会设置条件码，但是各个SET命令的描述都适用的情况是：执行比较指令。

### 3.6.3 跳转指令

正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。

下图列举了不同的跳转指令。*jmp*指令是无条件跳转。它可以直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转的，即跳转目标是从寄存器或内存位置中读出的。直接跳转是类似“.L1”，间接跳转是“*L1*”。

指令*jmp* *%rax*用寄存器*%rax*中的值作为跳转目标，指令*jmp* *(%rax)*以*%rax*中的值作为读地址，从内存中读出跳转目标。

![image-20211208160633621](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160633621.png)

根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。同SET指令一样，一些底层的机器指令有多个名字，条件跳转只能是直接跳转。

### 3.6.4 跳转指令的编码

跳转指令有几种不同的编码，但是最常用的都是PC相对的。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

![image-20211208160709213](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160709213.png)

当执行PC相对寻址时，程序计数器的值时跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。这种惯例可以追溯到早期的实现，当时的处理器会将更新程序计数器作为执行一条指令的第一步。

跳转指令提供了一种实现条件执行(*if*)和几种不同循环结构的方式。

### 3.6.5 用条件控制来实现条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

C语言中的*if-else*语句的通用形式模板如下：

```
if(*test-expr*)
	then-statment
else
	else-statment
```

*test-expr*是一个整数表达式，它的取值为0(”假“)或者为非0(“真”)。

对于这种通用形式，汇编实现通常会使用下面这种形式，用C语法来描述控制流：

![image-20211208160732495](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160732495.png)

汇编器为*then-statement*和*else-statement*产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。

### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是非常低效。

一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后在根据条件是否满足从中选取一个。

处理器通过使用流水线来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分。这种方法通过重叠连续指令的步骤来获得高性能。当机器遇到条件跳转(“分支”)时，只有当分支条件求值完成之后，才能决定分支往哪走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠，指令流水线中就会充满着指令。

==*如何确定分支预测错误的处罚*==

假设预测错误的概率是*p*，如果没有预测错误，执行代码的时间是*T*~OK~,而预测错误的处罚是*T*~MP~。作为*p*的一个函数，执行代码的平均时间是$T_{avg}(p)=(1-p)T_{OK}+p(T_{OK}+T_{MP})=T_{OK}+pT_{MP}$

另一方面，无论测试的数据是是什么，编译出来使用条件传送的代码所需的时间都是大约8个时钟周期。控制流不依赖于数据，这使得处理器更容易保持流水线是满的。

----

下图列举了x86-64上一些可用的条件传送指令。每条指令都有两个操作数：源寄存器或者内存地址*S*和目的寄存器*R*。这些指令的结果取决于条件码的值。源值可以从内存或源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

源和目的的值可以是16位、32位或64位长。不支持单字节的条件传送。

![image-20211208160754300](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160754300.png)

同条件跳转不同，处理器无须预测测试的结果就可以执行条件传送。处理器只是读源值，检查条件码，然后要么更新目的寄存器，要么保持不变。

![image-20211208160812983](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160812983.png)

这段代码包含两个代码序列：一个对*then-expr*求值，另一个对*else-expr*。条偶见跳转和无条件跳转结合起来使用是为了保证只有一个序列执行

基于条件传送的代码，会对*then-expr*和*else-expr*都求值，最终值的选择基于对*test-expr*的求值。可以用抽象代码描述：

![image-20211208160821323](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160821323.png)

序列中的最后一条语句是用条件传送实现的——只有当测试条件*t*满足时，*vt*的值才会被复制到*v*中

不是所有的条件表达式都可以用条件传送来编译。无论测试结果如何，抽象代码都会对*then-expr*和*else-expr*求值。如果这两个表达式中的任意一个可能产生错误条件或副作用。

总的来说，条件数据传输提供了一种用条件控制转移来实现条件操作的替代策略。



### 3.6.7 循环

C语言提供了多种循环结构，汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。GCC和其他汇编器产生的循环代码主要基于两种基本的循环模式

**1. do-while循环**

do-while语句的通用形式如下

```C
do
	body-statement
	while(test-expr);
```

翻译成条件和goto语句

```C
loop:
	body-statement
	t=test-expr
	if(t)
		goto loop:
```

**2. while循环**

while语句的通用形式如下

```
while(test-expr)
	body-statement
```

第一种翻译方法，称之为跳转到中间，它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。

```
	goto test;
loop:
	body-statement
test:
	t = test-expr
	if(t)
		goto loop    
```

第二种翻译方法，称之为*guarded-do*,首先用条件分支，如果初始条件不成立就跳过循环你，把代码变换为*do-while*循环。当使用较高优化等级编译时，例如使用命令行选项-O1，GCC会采用这种策略。

![image-20211208160911117](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160911117.png)

**for循环**

for循环的通用形式

```
for（init-expr; test-expr; update-expr)
	body-statement
```

GCC为for产生的代码时while循环的两种翻译之一，这取决于优化的等级。跳转到中间策略会得到如下goto代码：

![image-20211208160945856](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160945856.png)

而*guarded-do*策略得到：

![image-20211208160954476](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208160954476.png)

C语言中的三种形式的所有循环——*do-while*、*while*和*for*——都可以用一种简单的策略来翻译，产生包含一个或多个条件分支的代码。控制的条件转移提供了将循环翻译成机器代码段的基本机制。

### 3.6.8 switch语句

*switch*语句可以根据一个整数索引值进行多重分支。跳转表是一个数组，表项*i*是一个代码段的地址，这个代码实现当开关索引值等于*i*时程序应该采取的动作。



## 3.7 过程

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

要提供对过程的机器级支持，必须要处理许多不同的属性。假设过程*P*调用过程*Q*，*Q*执行后返回到*P*。这些动作包括下面一个或多个机制：

- *传递控制*：在进入过程*Q*的时候，程序计数器必须被设置为*Q*的代码的起始地址，然后在返回时，要把程序计数器设置为*P*中调用*Q*后面那条指令的地址。
- *传递数据*：*P*必须能够向Q提供一个或多个参数，*Q*必须能够向*P*返回一个值。
- *分配和释放内存*：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间

x86-64的过程实现包括一组特殊的指令和一些对机器资源(例如寄存器和程序内存)使用的约定规则。

### 3.7.1 运行栈

C语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。

![image-20211208161028671](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161028671.png)

当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧。当前正在执行的过程的帧总是在栈顶。大多数过程的帧栈都是定长的，在过程的开始就分配好了。通过寄存器，过程P可以传递最多6个参数，但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。

为了提高空间和时间效率，x84-64过程只分配自己所需要的栈帧部分。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以这样处理。

### 3.7.2 转移控制

在x86-64机器中，这个信息是用指令call Q调用过程Q来记录。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。

call和ret指令的一般形式

![image-20211208161040203](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161040203.png)

call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。

![image-20211208161058934](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161058934.png)



### 3.7.3 数据传送

x86-64中，大部分过程间的数据传送是通过寄存器实现的。

x86-64中，可以通过寄存器最多传递6个整型参数，寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。

![image-20211208161117623](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161117623.png)

如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。要把参数1~6复制到对应的寄存器，把参数7 ~ n放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。

![image-20211208161138475](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161138475.png)

### 栈上的局部存储

局部数据存放在内存中，常见的情况包括：

- 寄存器不足够存放所有的本地数据
- 对一个局部变量使用地址运算符‘&’，因此必须能够为它产生一个地址
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为”局部变量“。

运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。

![image-20211208161213049](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161213049.png)

### 3.7.5 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。

根据惯例，寄存器*%rbx*、*rbp*和*r12~r15*被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为”保存的寄存器“的一部分。

所有其他的寄存器，除了栈指针*%rsp*，都分类为调用者保存寄存器，这就意味着任何函数都能修改它们。”调用者保存”：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P（调用者）的责任。

![image-20211208161314694](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161314694.png)

### 3.7.6 递归过程

栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用。

![image-20211208161330114](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161330114.png)



## 3.8 数组分配和访问

### 3.8.1 基本原则

对于数据类型*T*和整型常数*N*，声明：$T A[N];$

起始位置表示为*x~A~*。这个声明有两个效果，首先，它在内存种分配一个*L • N*字节的连续区域，这里*L*是数据类型*T*的大小（单位为字节）。其次，它引入了标识符*A*，可以用*A*来作为指向数组开头的指针，这个指针的值就是*x~A~*。可以用0~N-1的整数索引来访问该数组元素。数组元素*i*会被存放在地址为$x_A+L \cdot i $的地方

![image-20211208161345657](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161345657.png)

### 3.8.2 指针运算

C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的的大小进行伸缩。如果p是一个指向类型为T的数据的指针，*p*的值为*x~p~*，那么表达式*p+i*的值为$x_p+L \cdot i $，这里L是数据类型T的大小。

单操作数操作符‘&’和‘ * ’可以产生指针和间接引用指针。也就是，对于一个表示某个对象的表达式*Expr*，&*Expr*是给出该对象地址的一个指针。对于一个表示地址的表达式*AExpr*，**AExpr*给出该地址出的值。因此，表达式*Expr*与* *&Expr*是等价的。

假设整型数组*E*的起始地址和整数索引*i*分别存放在寄存器*%rdx*和*%rcx*中。

![image-20211208161403978](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161403978.png)

### 3.8.3 嵌套的数组

要访问多维数组的元素，编译器会以数组起始为基地址，（可能需要经过伸缩的）偏移量为索引，产生计算期望的元素的偏移量，然后适用某种MOV指令。通常来说，对于一个声明如下的数组：$T D[R][C];$它的数组元素$D[i][j]$的内存地址为$\&D[i][j]=x_D+L(C \cdot i+j)$

![image-20211208161418695](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161418695.png)

### 3.8.4 定长数组

当程序要用一个常数作为数组的维度或缓冲区的大小时，最好通过#define声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。



### 3.8.5 变长数组

在变长数组的C版本中，可以将一个数组声明如下：

```c
int var_ele(long n, int A[n][n], long i, long j){
	return A[i][j];
}
```

参数n必须在参数$A[n][n]$之前，函数就可以在遇到这个数组的时候计算出数组的维度。

![image-20211208161451653](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161451653.png)

如果允许使用优化，GCC能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式会导致的乘法。

## 3.9 异质的数据结构

C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制，*结构*，用关键字*struct*来声明，将多个对象集合到一个单位中；*联合*，用关键字*union*来声明，允许用几种不同的类型来引用一个对象

### 3.9.1 结构

类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

![image-20211208161524819](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161524819.png)

要产生一个指向结构内部对象的指针，只需将结构的地址加上该字段的偏移量。

![image-20211208161533455](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161533455.png)

结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

### 3.9.2 联合

联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。

![image-20211208161548208](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161548208.png)

在一台x86-64Linux机器上编译时，字段的偏移量、数据类型S3和U3的完整大小如下：

![image-20211208161556691](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161556691.png)

对于类型*union U3* *的指针 *p*，*p* -> *c* 、*p* -> *i[0]*和*p* ->*v*引用的都是数据结构的起始位置，一个联合的总的大小等于它最大字段的大小。

一种应用情况是，事先直到一个对数据结构中的两个不同字段的使用时互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。

联合还可以用来访问不同数据类型的位模式

### 3.9.3 数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须时某个值K（通常是2、4或8）的倍数。这种*对齐限制*简化了形成处理器和内存系统之间接口的硬件设计。

对齐原则是任何K字节的基本对象的地址必须是K的倍数。

![image-20211208161613464](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161613464.png)

```
.align 8
```

就保证了它后面的数据的起始地址是8的倍数，因为每个表项长8个字节，后面的元素都会遵守8字节对齐的限制。

对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求，而结构本身对它的起始地址也有一些对齐要求。

![image-20211208161711059](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161711059.png)

编译器结构的末尾可能需要一些填充，这样结构数组中的每个元素都会满足它的对齐要求

![image-20211208161718867](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161718867.png)



## 3.10 在机器级程序中将控制与数据结合起来

### 3.10.1 理解指针

- *每个指针都对应一个类型*：这个类型表明该指针指向的是哪一类对象。例如：

  ```
  int *ip;
  char **cpp;
  ```

  变量*ip*是一个指向int类型对象的指针，而*cpp*指针指向的对象自身就是一个指向*char*类型对象的指针。通常，如果对象类型为*T*，那么指针的类型为*T*。特殊的void*类型代表通用指针。指针类型不是机器代码的一部分，它们是C语言提供的一种抽象，帮助程序员避免寻址错误。

- *每个指针都有一个值*：这个值是某个指定类型的对象的地址。特殊的NULL(0)值表示该指针没有指向任何地方。

- *指针用‘ & ’运算符创建*：*leaq*指令是设计用来计算内存引用的地址的，&运算符的机器代码实现常常用这条指令来计算表达式的值。

- *操作符用于间接引用指针*：其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。

- *数组与指针紧密联系*：一个数组的名字可以像一个指针变量一个引用（但是不能修改）。数组引用(a[3])与指针运算和间接引用(*a+3)有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。

- *将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值*：强制类型转换的一个效果是改变指针运算的伸缩

- *指针也可以指向函数*：这些引用可以被程序的某个其他部分调用

  ![image-20211208161737913](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161737913.png)

### 3.10.2 使用GDB调试器

![image-20211208161810569](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161810569.png)

很多常用的库函数，包括*strcpy*、*strcat*和*srprintf*都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列[97]。这样的情况就会导致缓冲区溢出漏洞。

### 3.10.3 内存越界引用和缓冲区溢出

一种特别常见的状态破坏称为*缓冲区溢出*。通常，在栈中分配某个字符串数组来保持一个字符串，但是字符串的长度超出了为数组分配的空间。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击安全系统的方法。

### 3.10.4 对抗缓冲区溢出攻击

**1.栈随机化**

栈随机化的思想使得栈的位置在程序每次运行时都有变化，即使许多机器都运行同样的代码，它们的栈地址都是不同的。

在Linux系统中，栈随机化已经变成了标准行为，它是更大的一类技术中的一种，这类技术称为*地址空间布局随机化(ASLR)*。

![image-20211208161853646](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161853646.png)

**2. 栈破坏检测**

计算机的第二道防线是能够检测到何时栈已经被破坏了。

在最近的GCC版本在产生代码中加入了一种*栈保护者*机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的*金丝雀*值。

![image-20211208161906273](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161906273.png)

这个*金丝雀值*，也称为哨兵值，是在程序每次运行时随机产生的。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了，如果改变了，那么程序异常中止。

栈保护很好地防止了缓冲区溢出攻击存储在程序栈上的状态。它只会带来很小的性能损失，特别是因为GCC只在函数中有局部*char*类型缓冲区的时候才插入这样的代码。

**3. 限制可执行代码区域**

最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。

### 3.10.5 支持变长栈帧

为了管理变成栈帧，x86-64代码使用寄存器*%rbp*作为帧指针（有时称为基指针（base pointer）。

![image-20211208161929093](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161929093.png)

可以看到代码必须把*%rbp*之前的值保存到栈中，因为它是一个被调用者保存寄存器。然后在函数的整个执行过程中，都使得*%rbp*指向那个时刻栈的位置，然后用固定长度的局部变量相对于*%rbp*的偏移量来引用它。

## 3.11浮点代码

AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为*%ymm0~%ymm15*。每个YMM寄存器都是256位（32字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于*float*）或64位（对于*double*）。汇编代码用寄存器的SSE XMM寄存器名字*%xmm0~%xmm15*来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位（16字节）。

![image-20211208161944219](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161944219.png)

### 3.11.1 浮点传送和转换操作

下图给出了一组在内存和XMM寄存器之间以及从一个XMM寄存器到另一个不做任何转换的传送浮点数的指令。引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中，要么保存在XMM寄存器中。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则32位内存数据满足4字节对齐，64位数据满足8字节对齐。

![image-20211208161954824](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208161954824.png)

下图给出了浮点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。这些都是对单个数据值进行操作的标量指令。

图3-47中的指令把一个从XMM寄存器或内存中读出的浮点值进行转换，并将结果写入以一个通用寄存器。把浮点值转换成整数时，指令会执行截断，把值向0进行舍入，这是C和大多数其他变成语言的要求。

![image-20211208162012216](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162012216.png)

图3-48中的指令把整数转换成浮点数。它们使用的是不太常见的三操作数格式，有两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二个操作数，因为它的值只会影响结果和高位字节。而我门的目标必须是XMM寄存器。

![image-20211208162021606](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162021606.png)



### 3.11.2 过程中的浮点代码

在x86-64中，XMM寄存器用来向汉纳树传递浮点参数，以及从函数返回浮点值。可以看到如下规则：

- XMM寄存器*%xmm0~%xmm7*最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器，可以通过栈传递额外的浮点参数。
- 函数使用寄存器*%xmm0*来返回浮点值。
- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中的任意一个。

![image-20211208162047026](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162047026.png)

### 3.11.3浮点运算操作

下图描述了一组执行算术运算的标量AVX2浮点指令。每条指令都有一个（S~1~）或两个（S~1~，S~2~）源操作数，和一个目的操作数D。第一个源操作数S~1~可以是一个XMM寄存器或一个内存位置。第二个源操作数和目的操作数都必须是XMM寄存器。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。

![image-20211208162057780](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162057780.png)





# 第4章 处理器体系结构

一个处理器支持的指令和指令的字节级编码称为它的*指令集体系结构（ISA）*。

因为受x86-64指令集的启发，它被俗称为“x86”，所以我们称我哦们的指令集为“Y86-64”指令集。与x86-64相比，Y86-64指令集的数据类型、指令和寻址方式都要少一些。它的字节级编码也比较简单，机器代码没有相应的x86-64代码紧凑。

## 4.1 Y86-64指令集体系结构

定义一个指令集体系结构包括定义各种状态单元，指令集和它们的编码，一组编程规范和异常事件处理。

### 4.1.1 程序员可见的状态

Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态。

![image-20211208162210320](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162210320.png)

- 每个程序寄存器存储一个64位的字。寄存器*%rsp*被入栈、出栈、调用和返回指令作为栈指针。寄存器没有固定的含义或固定值。

- 3个一位的条件码：ZF、SF和OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。

- 程序计数器(PC)存放当前正在执行指令的地址

- 内存从概念上来说是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译称实际或物理地址，指明数据实际存在内存中哪个地方

- 程序状态的最后一个部分是状态码*Stat*，它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。

  

### 4.1.2 Y86-64指令

Y86-64指令集基本上是x86-64指令集的一个子集。它只包括8字节整数操作，寻址方式较少，操作也较少。

![image-20211208162249026](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162249026.png)

Y86-64指令的一些细节：

- x86-64的*movq*指令分成了4个不同的指令，分别显示地指明源和目的的格式。源可以是立即数(*i*)、寄存器(*r*)或内存(*m*)。指令名字的第一个字母就表明了源的类型。目的可以是寄存器(*r*)或内存(*m*)。指令名字的第二个字母指明了目的的类型。

  两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。在地址计算中，我们不支持第二变址寄存器和任何寄存器值的伸缩。同x86-64一样，我们不允许从一个内存地址直接传送到另一个内存地址，也不允许将立即数传送到内存。

- 有4个整数操作指令。图中的*OPq*。它们是*addq*、*subq*、*andq*和*xorq*。它们只对寄存器数据进行操作，而x86-64还允许内存数据进行这些操作。这些指令会设置3个条件码*ZF*、*SF*和*OF*

- 7个跳转指令是*jmp*、*jle*、*jl*、*je*、*jne*、*jge*和*jg*。根据分支指令的类型和条件代码的设置来选择分支。分支条件和x86-64的一样。

- 有6个条件传送指令：*cmovle*、*cmovl*、*cmove*、*cmovne*、*cmovge'*和*cmovg*。这些指令的格式与寄存器-寄存器传送指令*rrmovq*一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。

- *call*指令将返回地址入栈，然后跳到目的地址。*ret*指令从这样的调用中返回。

- *pushq*和*popq*指令实现了入栈和出栈

- *halt*指令停止指令的执行。x86-64中有一个与之相当的指令*hlt*。x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86-64来说，执行*halt*指令会导致处理器停止，并将状态码设置为*HLT*。

### 4.1.3 指令编码

![image-20211208162413970](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162413970.png)

还给出了指令的字节级编码。每条指令需要1~10个字节不等，这取决于需要哪些字段。每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分4位：高4位是代码(code)部分，低4位是功能(function)部分。代码值为0 ~ 0xB。功能值只有在一组相关指令共用一个代码时才有用。

图给出了整数操作、分支和条件传送指令的具体编码。

![image-20211208162422964](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162422964.png)

15个寄存器中每个都有一个相对应的范围在0到0xE之间的寄存器标识符(register ID)。Y86-64中的寄存器编号跟x86-64中的相同。程序寄存器在CPU中的一个寄存器文件中，这个寄存器文件就是一个小的、以寄存器ID作为地址的随机访问存储器。在指令编码中以及在我们的硬件设计中，当需要指明不应访问任何寄存器时，就用ID值0xF来表示。

![image-20211208162430972](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162430972.png)

有的指令只有一个字节长，而有的需要操作数的指令编码就更长一些。首先，可能有附加的寄存器指示符字节，指定一个或两个寄存器。在图4-2中这些寄存器字段能成为rA和rB。从指令的汇编代码表示中可以看到，根据指令类型，指令可以用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。没有寄存器操作数的指令，例如分支指令和*call*指令，就没有寄存器指示符字节。那些只需要一个寄存器操作数的指令将另一个寄存器指示符设为0xF。

有些指令需要一个附加的4字节常数字。这个字能作为*irmovq*的立即数数据，*rmmovq*和*mrmovq*的地址指示符的偏移量，以及分支指令和调用指令的目的地址。**注意：分支指令和调用指令的目的是一个绝对地址，而不像IA32中那样使用PC相对寻址方式。**

指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码嵌入在程序的其他字节中，只要从序列的第一个字节开始处理，仍然可以很容易地确定指令序列。



### 4.1.4 Y86-64异常

对Y86-64来说，程序员可见的状态包括状态码*Stat*，它描述程序执行的总体状态。

![image-20211208162442897](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162442897.png)

对于Y86-64，当遇到这些异常的时候，就简单地让处理器停止执行指令。在更完整的设计中，处理器通常会调用一个异常处理程序，这个过程被指定用来处理遇到的某种类型的异常。

### 4.1.4 一些Y86-64指令的详情

大多数Y86-64指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意。

*pushq*指令会把指针减8，并且将一个寄存器的值写入内存中。因此，当执行*pushq %rsp*指令时，处理器的行为是不确定的，因为要入栈的寄存器会被同一条指令修改。通常有两种不同的约定：1）压入*%rsp*的原始值，2）压入减去8的%rsp的值

## 4.2 逻辑设计和硬件控制预压HCL

### 4.2.1 逻辑门

逻辑门是数字电路的基本单元。它们产生的输出，等于它们输入位值的某个布尔函数。

![image-20211208162500011](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162500011.png)

逻辑门总是活动的。一旦一个门的输入变化了，在很短的时间内，输出就会相应的变化。

### 4.2.2 组合电路和HCL布尔表达式

将很多的逻辑门组合称一个网，就能构建计算块，称为组合电路。如何构建这些网有几个限制：

- 每个逻辑门的输入必须连接到下述选项之一：1）一个系统输入（称为主输入），2）某个存储器单元的输出，3）某个逻辑门的输出
- 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障
- 这个网必须使无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的贿赂会导致该网络计算的函数有歧义

图4-10是一个简单组合电路的例子

![image-20211208162512528](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162512528.png)

图4-11是一个简单的组合电路，称多路复用器（通常称为“MUX”）

![image-20211208162519757](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162519757.png)

HCL表达式很清楚地表明了组合逻辑电路和C语言中逻辑表达式的对应指出。它们都是用布尔操作来对输入进行计算的函数。这两种表达计算的方法之间有以下区别：

- 因为组合电路是由一系列的逻辑门组成，它的属性是输出持续地相应输入的变化。如果电路的输入变化了，在一定的延迟之后，输出也会相应地变化。相比之下，C表达式只会在程序执行过程中被遇到时才进行求值
- C的逻辑表达式只允许参数时任意整数，0表示FALSE，其他任何值都表示TRUE。而逻辑门只对值0和1进行操作
- C的逻辑表达式有各属性就是它们可能只被部分求值。如果一个AND或OR操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了。

### 4.2.3 字级的组合电路和HCL整数表达式

通常我们设计能对数据字进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。

执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。

![image-20211208162531667](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162531667.png)

在HCL中，我们将所有字级的信号都声明为int，不指定字的大小。

在画字级电路的时候，我们用中等粗度的线来表示携带字的每个位的线路，而用虚线来表示布尔信号结果。

图4-13是字级的多路复用电路。这个电路根据控制输入位*s*，产生一个64位的字*Out*，等于两个输入字*A*或者*B*中的一个。这个电路由64个相同的子电路组成，每个子电路的结构都类似于图4-11中的位级多路复用器。

![image-20211208162547112](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162547112.png)

在HCL中，多路复用函数是用情况表达式来描述的。情况表达式的通用格式如下：

![image-20211208162603484](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162603484.png)

这个表达式包含一系列的情况，每种情况*i*都由一个布尔表达式*select~i~*和一个整数表达式*expr*，前者表明什么时候选择这种情况，后者指明的是得到的值。

![image-20211208162620915](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162620915.png)

算术/逻辑单元（ALU）是一种很重要的组合电路，图4-15是它的一个抽象的图示。这个电路有三个输入：标号为*A*和*B*的两个数据输入，以及一个控制输入。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。

![image-20211208162638453](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162638453.png)



### 4.2.4 集合关系

在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

![image-20211208162646802](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162646802.png)

在这个电路中，两位的信号*code*就可以用来控制对4个数据字A、B、C和D做选择。根据可能的*code*值，可以用相等测试来表示信号*S1*和*S0*的产生：

$bool s1 = code == 2  || code == 3$

$bool s0 = code == 1 || code == 3$

![image-20211208162703676](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162703676.png)

### 4.2.5 存储器和时钟

组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生*时序电路*，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由用一个*时钟*控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：

- *时钟寄存器（简称寄存器）*存储单个位或字。时钟信号控制寄存器加载输入值
- *随机访问存储器（简称内存）*存储多个字，用地址来选择该读或该写哪个字

在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。

在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址是寄存器ID。

寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿沿时，值才会从寄存器的输入传送到输出。Y86-64处理器会用时钟寄存器保存升序计数器（PC）、条件代码（CC）和程序状态（Stat）

![image-20211208162800918](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162800918.png)

寄存器文件由两个*读端口*（A和B），还有一个*写端口*（W）。

![image-20211208162825678](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162825678.png)

这样一个多端口随机访问存储器允许同时进行多个读和写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。

每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个数据输出或对应该程序寄存器的输入值。地址是用图中编码表示的寄存器标识符。两个读端口有地址输入*srcA*和*srcB*和数据输出*valA*和*valB*。写端口有地址输入*dstW*以及数据输入*valW*。

虽然寄存器文件不是组合电路，因为它有内部存储。不过，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。

向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入*valW*上的值会被写入输入*dstW*上的寄存器ID指示的程序寄存器。当*dstW*设为特殊的ID值0xF时，不会写任何程序寄存器。

如果更新一个寄存器，同时在读端口上用一个寄存器ID，会看到一个从旧值到新值的变化。

处理器有一个随机访问存储器来存储程序数据：

![image-20211208162815191](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162815191.png)

这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。同寄存器文件一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入*address*上提供一个地址，并将*write*控制信号设置为0，那么在经过一些延迟之后，存储在那个地址上的值会出现在输出data上。如果地址超出了范围，*error*信号会设置为1，否则就设置为0.写内存是由时钟控制的：我们将*address*设置为期望的地址，将*data in*设置为期望的值，而*write*设置为1.然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读操作来说，如果地址是不合法的，*error*信号会设置为1。这个信号是由组合逻辑产生的，因为所需要的边界检查存储就是地址输入的函数，不涉及保存任何状态。

我们的处理器还包括另外一个只读存储器，用来读指令。大多数实际系统中，这两个存储器被合并为一个具有装端口的存储器：一个用来读指令，另一个用来读或者写数据。

### 4.3 Y86-64的顺序实现

### 4.3.1 将处理组织成阶段

关于各个阶段以及各阶段内执行操作的简略描述：

- **取指**(fetch)：取指阶段从内存读取指令字节，地址为程序计数器(PC)的值。从指令中抽取出指令指示符字节的两个四位部分，称为*icode*(指令代码)和*ifun*(指令功能)。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符*rA*和*rB*。它还可能取出一个四字节常数字*valC*。它按顺序方式计算当前指令的下一条指令的地址*valP*。*valP*等于PC的值加上已取出指令的长度。
- **译码**(decode)：译码阶段从寄存器文件读入最多两个操作数，得到值*valA*和/或*valB*。通常，它读入指令*rA*和*rB*字段指明的寄存器，不过有些指令是读寄存器*%rsp*的。
- **执行**(execute)：在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据*ifun*的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值称为*valE*。也可能设置条件码，对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由*ifun*给出），如果条件成立，则更新目标寄存器。对一条跳转指令来说，这个阶段会决定是不是应该选择分支。
- **访存**(memory)：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为*valM*。
- **写回**(write back)：写回阶段最多可以写两个结果到寄存器文件
- **更新PC**(PC update)：将PC设置成下一条指令的地址。

使用图4-17中所示的代码来描述不同Y86-64指令的处理：

![image-20211208162841186](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162841186.png)

图4-18给出了对*OPq*(整数和逻辑运算)、*rrmovq*(寄存器-寄存器传送)和*irmovq*(立即数-寄存器传送)累的指令所需的处理

![image-20211208162849780](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162849780.png)

整数操作指令的处理遵循上面列出的通用模式。在取值阶段，我们不需要常数字，所以*valP*就计算为PC+2。在译码阶段，我们要读两个操作数。在执行阶段，它们和功能指示符*ifun*一起再提供给ALU，*valE*就成了指令结果。这个计算使用表达式*valB OP valA*来表达的，这里*OP*代表*ifun*指定的操作。这些指令在访存阶段什么也不做，而在写回阶段，*valE*被写入寄存器*rB*，然后PC设为*valP*，整个指令的执行就结束了。

![image-20211208162918228](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162918228.png)

执行*rrmovq*指令和执行算术运算类似。不过，不需要取第二个寄存器操作数。我们将ALU的第二个输入设为0，先把它和第一个操作数相加，得到*valE*= *valA*，然后再把这个值写到寄存器文件。对*irmovq*的处理类似，除了ALU的第一个输入为常数值*valC*。另外，因为是长指令格式，对于*irmovq*，程序计数器必须加10。所有这些指令都不改变条件码。

------

图4-19给出了内存读写指令*rmmovq*和*mrmovq*所需要的处理。用ALU来加*valC*和*valB*，得到内存操作的有效地址(偏移量与基址寄存器值之和)。在访存阶段，会将寄存器值*valA*写到内存，或者从内存中读出*valM*。

![image-20211208162933662](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162933662.png)

![image-20211208162942331](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162942331.png)

------

图4-20给出了处理*pushq*和*popq*指令所需的步骤：

![image-20211208162958569](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162958569.png)

在译码阶段，用*%rsp*作为第二个寄存器操作数的标识符，将栈指针赋值为*valB*。在执行阶段，用ALU将栈指针减8。减过8的值就是内存写的地址，在写回阶段还会存会到*%rsp*中。将*valE*作为写操作的地址。

![image-20211208163013657](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163013657.png)

*popq*指令的执行与*pushq*的执行类似，除了在译码阶段要读两次栈指针以外。在执行阶段，用ALU给栈指针加8，但是用没加过8的原始值作为内存操作的地址。在写回阶段，要用加过8的栈指针更新栈指针寄存器，还要将寄存器*rA*更新为内存中读出的值。用没加过8的值作为内存读地址。

------

图4-21表明了三类控制转移指令的处理：各种跳转、*call*和*ret*：

![image-20211208163027840](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163027840.png)

在执行阶段，检查条件码和跳转条件来确定是否要选择分支，产生出一个一位信号*Cnd*。在更新PC阶段，检查这个标志，如果这个标志为1，就将PC设为*valC*（跳转目标），如果为0，就设为*valP*（下一条指令的地址）。

![image-20211208163058449](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163058449.png)

对指令*call*，我们要将*valP*，也就是*call*指令后紧跟着的那条指令的地址，压入栈中。在更新PC阶段，将PC设为*valC*，也就是调用目的地。对指令*ret*，在更新PC阶段，将*valM*，即从栈中取出的值，赋值给PC。

![image-20211208163108974](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163108974.png)

![image-20211208163131884](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163131884.png)



### 4.3.2 SEQ硬件结构

![image-20211208163140083](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163140083.png)

- **取指**：将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器计算*valP*，增加了的程序计数器

- **译码**：寄存器文件有两个读端口A和B，从这两个端口同时读寄存器值*valA*和*valB*。

- **执行**：执行阶段会根据指令的类型，将算术/逻辑单元（ALU）用于不同的目的。对于整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或计算有效地址，或者只是简单地加0，将一个输入传递到输出。

  条件码寄存器（CC）有三个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号*Cnd*

- **访存**：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。

- **写回**：寄存器文件有两个写端口，端口E用来写ALU计算出来的值，而端口M用来写从数据内存中读出的值。

- **PC更新**：程序计数器的新值选择自：*valP*，下一条指令的地址；*valC*，调用指令或跳转指令的目标地址；*valM*，从内存读取的返回地址

![image-20211208163152179](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163152179.png)

- ***白色方框表示时钟寄存器。***程序计数器PPC是SEQ中唯一的时钟寄存器
- ***浅蓝色方框表示硬件单元***。这包括内存、ALU等
- ***控制逻辑块用灰色圆角矩形表示***。这些块用来从一组信号源中进行选择，或者用来计算一些布尔函数。
- ***线路的名字在白色圆圈中说明***
- ***宽度为字长的数据连接用中等粗度的线表示***。每条这样的线实际上都代表一簇64根线，并列地连在一起，将一个字从硬件的一个部分传送到另一部分
- ***单个位的连接用虚线来表示***。这代表芯片上单元与块之间传递的控制值。

![image-20211208163210839](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163210839.png)

### 4.3.3 SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备：时钟存储器（程序计数器和条件码寄存器），随机访问存储器（寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或控制——只要输入变化了，值就通过逻辑门网络传播。由于指令内只用来读取指令，可以将这个单元看成是组合逻辑。

这些单元通过一个时钟信号来控制，它触发将新值装在到寄存器以及将值写到随机访问存储器。每个时钟周期，程序计数器都会装载新年的指令地址。只有在执行整数运算指令时，才会装在条件码寄存器。只有在执行*rmmovq*、*pushq*或*call*指令时，才会写数据内存。寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器，可以用页数的寄存器ID*0xF*作为端口地址，来表明在此端口不应该执行写操作。

**原则**：从不回读

*处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态*

![image-20211208163244430](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163244430.png)

![image-20211208163303371](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163303371.png)

### 4.3.4 SEQ阶段的实现

![image-20211208163317123](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163317123.png)

除了图中的指令以外，还包括了对*nop*和*halt*指令的处理。*nop*指令只是简单地经过各个阶段，除了要将PC加1，不进行任何处理。*halt*指令使得处理器状态被设置为*HLT*，导致处理器停止运行。

#### 1.取指阶段

![image-20211208163327995](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163327995.png)

取指阶段包括指令内存硬件单元。以PC作为第一个字节的地址，这个单元一次从内存读出10个字节。

第一个字节被解释成指令字节，（标号为“Split”的单元）分为两个4位的数。标号为”icode“和”ifun“的控制逻辑块计算指令和功能码，或者使之等于从内存读出的值，或者当指令地址不合法时（由信号*imem_error*指明），使这些值对应于*nop*指令。标号为”Align“的硬件单元会处理剩下的9个字节，将它们放入寄存器字段和常数字中。根据*icode*的值，我们可以计算三个一位的信号：

- *instr_valid*：这个信号用来发现不合法的指令
- *need_regids*：当被计算出的信号*need_regids*为1时，字节1被分开装入寄存器指示符rA和rB中，否则，被设为*0xF(RNONE)*，表明没有指明寄存器。
- *need_valC*：根据信号*need_regidsd*的值，要么根据1~8来产生*valC*，要么根据字节2~9来产生

PC增加器硬件单元根据当前的PC以及两个信号*need_regids*和*need_valC*的值，产生信号*valP*。对于PC值*p*、*need_regids*值*r*以及*need_valC*值*i*，增加器产生值*p+1+r+8i*

#### 2.译码和写回阶段

![image-20211208163336675](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163336675.png)

寄存器文件有四个端口。它支持同时进行两个读（在端口A和B上）和两个写（在端口E和M上）。每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器ID，而数据连接是一组64根线路，既可以作为寄存器文件的输出字，也可以作为它的输入字。两个读端口的地址输入为*srcA*和*srcB*，两个写端口的地址输入为*dstA*和*dstB*。如果某个地址宽口上的值为特殊标识符*0xF*，则表明不需要访问寄存器。

根据指令代码*icode*以及寄存器指示值*rA*和*rB*，可能还会根据执行阶段计算出的*Cnd*条件信号。寄存器ID*srcA*表明应该读那个寄存器以产生*valA*。寄存器ID*dstE*表明写端口E的目的寄存器，计算出来的值*valE*将放在那里。

#### 3. 执行阶段

![image-20211208163348507](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163348507.png)

执行阶段包括算术/逻辑端元（ALU）。这个单元根据*alufun*信号的设置，对输入*aluA*和*aluB*执行ADD、SUBTRACT、AND或EXECLUSIVE-OR运算。ALU的输出就是*valE*信号。

执行阶段的第一步就是每条指令的ALU计算。列出的操作数*aluB*在前面，后面是*aluA*，这样是为了爆炸*subq*指令是*valB*减去*valA*。

执行阶段还包括条件码寄存器。标号为”cond“的硬件单元会根据条件码和功能码来确定是否进行条件分支或条件数据传送，它产生信号*Cnd*，用于设置条件传送的*dstE*，也用在条件分支的下一个PC逻辑中。对于其他指令，取决于指令的功能码和条件码的设置，*Cnd*信号可以被设置为1或0。

#### 4. 访存阶段

![image-20211208163356744](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163356744.png)

访存阶段的任务就是读或写程序数据。两个控制块产生内存地址和内存输入数据的值。另外两个产生表明应该执行读操作还是写操作的控制信号。当执行读操作时，数据内存产生值*valM*。

访存阶段最后的功能是根据取值阶段产生的*icode*、*imem_error*、*instr_valid*值以及数据内存产生的*dmem_error*信号，从指令执行的结果来计算状态码*Stat*

#### 5. 更新PC阶段

![image-20211208163406407](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163406407.png)

SEQ中最后一个阶段会产生程序计数器的新值。依据指令的类型和是否要选择分支，新的PC可能是*valC*、*valM*或*valP*

## 4.4 流水线的通用原理

流水线话的一个重要特性的就是提高了系统的***吞吐量***，也就是单位时间内服务的顾客总数，不过也会轻微的增加延迟，也就是服务一个用户所需要的时间。

### 4.4.1 计算流水线

![image-20211208163415401](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163415401.png)

在现代逻辑设计中，电路延迟以微微秒或皮秒(ps)，也就是10^-12^秒为单位来计算。实心的长方形表示这些指令执行的时间。这个实现中，在开始下一条指令之间必须完成前一个。这个系统的最大吞吐量为：

$吞吐量\ = \frac{1条指令}{(20+300)ps} \cdot \frac{1000ps}{1ns} \approx 3.12GIPS$

我们以每秒千兆条指令（GIPS），也就是每秒十亿条指令，为单位来描述吞吐量。从头到尾执行一条指令所需要的时间称为延迟。

假设将系统执行的计算分成三个阶段（A、B和C），每个阶段需要100ps

![image-20211208163424359](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163424359.png)

然后在各个阶段之间放上*流水线寄存器*，这样每条指令都会按照三步经过这个系统，从头到尾需要三个完整的时钟周期。将系统的吞吐量提高到原来的2.67倍，代价是增加了一些硬件，以及延迟的少了增加。延迟变大时由于增加的流水线寄存器的时间开销。

### 4.4.2 流水线操作的详细说明

![image-20211208163431139](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163431139.png)

图4-34给出了前面看到的三阶段流水线的流水线图。流水线阶段之间的指令转移是由时钟信号来控制的，每隔120ps，信号从0上升至1，开始下一组流水线阶段的计算。

![image-20211208163447647](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163447647.png)

图4-35 跟踪了时刻240~360之间的电路活动。

指令*I1*经过阶段C，*I2*经过阶段B，而*I3*经过阶段A。

- ①：就在时刻240时钟上升前，阶段A中计算的指令*I2*的值以及达到了第一个流水线寄存器的输入，但是该寄存器的状态和输出还保持为指令*I1*在阶段A中计算的值。指令*I1*在阶段B中计算的值以及到达了第二个流水线寄存器的输入。
- ②：当时钟上升时，这些输入被加载到流水线寄存器中，称为寄存器的输出。
- ③：阶段A的输入被设置成发起指令*I3*的计算，然后信号传播通过各个阶段的组合逻辑，就像曲线化的波阵面表明的那样，信号可能以不同的速率通过各个不同的部分。
- ④：在时刻360之前，结果只到达流水线寄存器的输入。当时刻360时钟上升时，各条指令会前进经过一个流水线阶段。

可以看到减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输入还不是合法的值。

### 4.4.3 流水线的局限性

#### 1. 不一致的划分

![image-20211208163458281](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163458281.png)

在这个系统中，通过这些阶段的延迟从50ps到150ps不等。通过所有阶段的延迟和仍为300ps，不过，运行时钟的速率是由最慢的阶段的延迟限制。流水线图表明， 每个时钟周期，阶段A都会空闲100ps，而阶段C会空闲50ps，只有阶段B会一直处于活动状态，另外，由于时钟周期减慢了，延迟也增加了。

#### 2. 流水过深，收益反而下降

![image-20211208163507663](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163507663.png)

通过将流水线的阶段数加倍，将性能提高了1.71，虽然将每个计算时钟的时间缩短了两倍，但是由于通过流水线寄存器的延迟，吞吐并没有加倍。这个延迟成了流水线吞吐量的一个制约因素。在这个设计中，这个延迟占到了整个时钟周期的28.6%。

为了提高时钟效率，现代处理器采用了很深的（15或更多的阶段）流水线。

### 4.4.4 带反馈的流水线系统

图4-38举例说明了将流水线引入含有反馈路径的系统中的危险。在原来的系统中，每条指令的结果都反馈给下一条指令。流水线（图4-38b）就说明了这个情况，*I1*的结果称为*I2*的输入，依此类推。

![image-20211208163519632](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163519632.png)

### 4.5.1 SEQ+：重新安排计算阶段

移动PC阶段，使得它的逻辑在时钟周期开始时活动，使它计算当前指令的PC值。在SEQ+中，创建状态寄存器来保存在一条指令执行过程中计算出来的信号。当一个新的时钟周期开始时，这些信号值通过同样的逻辑来计算当前指令的PC。这些寄存器标号为“pIcode”、“pCnd”等等，来指明在任一给定的周期，它们保存的时前一个周期中产生的控制信号。

![image-20211208163542142](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163542142.png)

> SEQ+有一个很奇怪的特色，那就是没有硬件寄存器来存放程序计数器。而是根据前一条指令保存下来的一些状态信息动态地计算PC。这就是一个小小的证明——可以以一种与ISA隐含着的概念模型不同的方式来处实现处理器，只要机器能正确执行任意的机器语言程序

SEQ到SEQ+中状态单元的改变时一种很通用的改进的例子，这种改进称为*电路重定时*。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水席系统中各个阶段之间的延迟。

### 4.5.2 插入流水线寄存器

在创建一个流水线化的Y86-64处理器的最初尝试中，要在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新排列，得到PIPE-处理器，这里的“-”代表这个处理器和最终的处理器设计相比，性能要差一点。



流水线寄存器在该图中用黑色方框表示，每个寄存器包括不同的字段，用白色方框表示。每个流水线寄存器可以存放多个字节和字。白色的方框表示实际的硬件组成。

流水线寄存器按如下方式标号：

- F：保存程序计数器的预测值
- D：位于取指和译码阶段之间。它保存关于最新取出的指令的信息。即将由译码阶段进行处理。
- E：位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息。即将由执行阶段进行处理。
- M：位于执行和访存阶段之间。它保存最新执行的指令结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。
- W：位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成*ret*指令时，它还要向PC选择逻辑提供返回地址。

![image-20211208163732228](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163732228.png)

这个图描述了每条指令通过的流水线各个阶段的行进过程，时间从左往右增大。

![image-20211208163741483](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163741483.png)

指令是自底向上的流动的。周期5时的扩展图表明的流水线阶段，取指阶段在底部，写回阶段在最上面，同流水线与硬件图表明的一样。

### 4.5.3 对信号进行重新排列和标号

顺序实现SEQ和SEQ+在一个时刻只处理一条指令，诸如*valC*、*srcA*和*valE*这样的信号值有唯一的值。在流水线化的设计中，与各个指令相关连的这些值有多个版本，会随着指令一起流过系统。

例如，在PIPE-的详细结构中，有4个标号为“Stat”的白色方框，保存着4条不同状态的状态码。采用的命名机制，通过在信号名前面加上大写的流水线寄存器名字作为前缀，存储在流水线寄存器中的信号可以唯一地被表示。如：*D_stat*、*E_stat*、*M_stat*和*W_stat*。

引用某些在一个阶段内刚刚计算出来的信号。它们的命名时在信号名前面加上小写的阶段名的第一个字母作为前缀，如*f_stat*和*m_stat*。

可以看到整个处理器的实际状态*Stat*时根据流水线寄存器W中的状态值，由写回阶段中的块计算出来的。

SEQ+和PIPE-的译码阶段都产生信号*dstE*和*dstM*，它们指明值*valE*和*valM*的目的寄存器。

在SEQ+中，我们可以将这些信号直接连到寄存器文件写端口的地址输入。

在PIPE-中，会在流水线中一直携带这些信号穿过执行和访存阶段你，直到写回阶段才送到寄存器文件。这样做是为了确保写端口的地址和数据输入是来自同一条指令。否则，会将处于写回阶段的指令的值写入，而寄存器ID却来自于处于译码阶段的指令。

作为一条通用原则，我们要保存一个流水线阶段中的指令的所有信息。

PIPE-中有一个块在相同表示形式的SEQ+中没有的，==那就是译码阶段中标号为“Select A“的块。这个块会从来自流水线寄存器D的*valP*或从寄存器文件A端口中读出的值选择一个，作为流水线寄存器E的值*valA*。==包括这个块是为了减少要携带给流水下寄存器E和M的状态数量。在所有的指令中，只有*call*在访存阶段需要*valP*的值。只有跳转指令在执行阶段（当不需要进行跳转时）需要*valP*的值。而这些指令又都不需要从寄存器文件中读出的值。因此合并这两个信号，将它们作为信号*valA*携带穿过流水线，从而减少流水线寄存器的状态数量。这样做就消除了SEQ和SEQ+中标号为”Data“的块。

流水线寄存器包括一个状态码*Stat*字段，开始时时在取指阶段计算出来的，访存阶段有可能会被修改。

### 4.5.4 预测下一个PC

流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。

如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之和，才知道是否要选择分支。类似地，如果取出的指令是*ret*，要到指令通过访存阶段，才能确定返回地址。

除了条件转移指令和*ret*之外，根据取指阶段中计算出的信息，能够确定下一条指令的地址。对于*call*和*jmp*来说，下一条指令的地址是指令中的常数字*valC*，而对于其他指令来说就是*valP*。因此，通过预测PC的下一个值，在大多数情况下，我们能达到每个时钟周期发射一条新指令的目的。对于条件转移来说，即可以预测选择了分支，新的PC值应为*valC*，也可以预测没有选择分支，那么新PC值应为*valP*。

猜测分支方向并根据猜测开始取指的技术称为*分支预测*。我们的设计只使用了简单的策略，即总是预测选了条件分支，因而预测PC的新值为*valC*。

同条件转移不同，*ret*指令的返回值几乎是无限的，因为返回地址是位于栈顶的字，其内容可以是任意的。在设计中，不会试图对返回地址做任何测试，只是简单地暂停处理新指令，直到*ret*指令通过写回阶段。

PIPE-的取指阶段，如图4-41底部所示，负责预测PC的下一个值，以及为取指选择实际的PC。

标号为”Predict PC“的块会从PC增加器计算出的*valP*和取出的指令中得到*valC*中进行选择。这个值存放在流水线寄存器F中，作为程序计数器的预测值。

标号为”Select PC“的块类似于SEQ+的PC阶段中标号为”PC“的块。它从三个值中选择一个作为指令内存的地址：预测的PC，对于到达流水线寄存器M的不选择分支的指令来说是*valP*的值（存储在寄存器*M_valA*），或是当*ret*指令到达流水线寄存器W（存储在*W_valM*）时的返回地址的值。

### 4.5.5 流水线冒险

将流水线技术引入一个带反馈的系统，当相邻指令间存在相关时会导致出现问题。这些相关有两种形式：

- 数据相关：下一条指令会用到这一条指令计算出的结果
- 控制相关：一条指令要确定下一条指令的位置，例如在执行跳转、调用和返回指令时。

这些相关可能会导致流水线产生计算错误，称为冒险。冒险也分为两类：数据冒险和控制冒险。

不会造成数据冒险的例子：

![image-20211208163848694](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163848694.png)

------

第一个*irmovq*指令已经通过了写回阶段，而第二个*irmovq*还处于写回阶段，对程序寄存器*%rax*的写要到周期7开始，时钟上升，才会发生。结果，会读出*%rax*的错误值。

![image-20211208163856331](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163856331.png)

------

当*irmovq*指令和*addq*指令之间只有一条*nop*指令，必须检查周期5内流水线的行为，此时*addq*已经通过译码阶段，但是寄存器*rdx*还处于写回阶段，而*%rax*还处于访存阶段，会得到两个错误的操作数

![image-20211208163925537](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163925537.png)

------

当去掉*irmovq*指令和*addq*指令之间所有*nop*指令，此时*addq*通过译码阶段，而寄存器*%rdx*处于访存阶段，*%rax*处于执行阶段。

![image-20211208163933506](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163933506.png)

> 数据冒险的类型
>
> - 程序寄存器：寄存器文件的读写是在不同阶段进行的，导致不同指令之间可能出现不希望的相互作用。
> - 程序计数器：更新和读取程序计数器之间的冲突导致了控制冒险。
> - 内存：对数据内存的读和写都发生在访存阶段。在一条读内存的指令到达这个阶段之前，前面所有要写内存的指令都已经完成了这个阶段。另外，在访存阶段中写数据的指令和在取指阶段中读指令也有冲突，因为指令和数据内存访问的是同一个地址空间。
> - 条件码寄存器：在执行阶段中，整数操作会写这些寄存器。条件传送指令会在执行阶段以及条件转移会在访存阶段读这些寄存器。在条件传送或转移到达执行阶段之前，前面所有的整数操作都已经完成了这个阶段了，不会发生冒险
> - 状态寄存器：指令流经流水线的时候，会影响程序状态。我们采用流水线中的每条指令都与一个状态码相关联的机制，使得当异常发生时，处理器能够有条理地停止。

#### 1. 用暂停来避免数据冒险

***暂停***是避免冒险的一直常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样就可以避免数据冒险。

将*addq*指令阻塞在译码阶段时，还必须将紧跟其后的*halt*指令阻塞在取指阶段。通过将程序计数器保持不变就能做到这一点，这样一来，会不断地对*halt*指令进行取指，直到结束。

暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。每次要把一条指令阻塞在译码阶段，就在执行阶段插入一个气泡。气泡就像一个自动产生的*nop*指令——它不会改变寄存器、内存、条件码或程序状态。

![image-20211208163954017](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163954017.png)

但是这样会导致流水线暂停长达三个周期，严重降低了整体的吞吐量。

#### 2. 用转发来避免数据冒险

与其暂停直到写完成，不如将要写的值传到流水线寄存器E作为源操作数。

下图中的译码阶段逻辑发现，寄存器*%rax*是操作数*valB*的源寄存器，而在写端口E上还有一个对*%rax*的未进行的写。只要将提供到端口E的数据字(信号*W_valE*)作为操作数*valB*的值，就能避免暂停。

![image-20211208164002754](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164002754.png)

这种将结果值直接从一个流水线阶段传到较早阶段的技术称为*数据转发*。数据转发需要在基本的硬件结构中增加一些额外的数据连接和逻辑控制。

![image-20211208164054050](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164054050.png)

程序*prog2~prog4*中描述的转发技术的使用都是将ALU产生的以及目标为写端口E的值进行转发，其实也可以转发从内存中读出的以及其目标为写端口M的值。

从访存阶段，可以转发刚刚从数据内存中读出的值(信号*m_valM*)。从写回阶段，可以转发对端口M为进行的写(信号*W_valM*)。这样一共就有五个不同的转发源(*e_valE*、*m_valM*、*M_valE*、*W_valM*和*W_valE*)，以及两个不同的转发目的(*valA*和*valB*)。

图4-49~图4-51的扩展图还表明译码阶段逻辑能够确定是使用来自寄存器文件的值，还是要用转发过来的值。与每个要写回寄存器文件的值相关的是目的寄存器ID。逻辑会这些ID与源寄存器ID*srcA*和*srcB*相比较，以此来检测是否需要转发。可能有多个目的寄存器ID与一个源ID相等。

![image-20211208164117516](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164117516.png)

标号为”Sel+Fwd A“的块是PIPE-中标号为”Select A“的块的功能与转发逻辑的结合。它允许流水线寄存器E的*valA*为已增加的程序计数器值*valP*，从寄存器我呢见A端口读出的值，或者某个转发过来的值。

标号为”Fwd B“的块实现的是源操作数*valB*的转发逻辑。

#### 3. 加载/使用数据冒险

有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。

![image-20211208164129103](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164129103.png)

如下图所示，可以将暂停和转发结合起来，避免加载/使用数据冒险。这个需要修改控制逻辑，但是可以使用现有的旁路路径。

![image-20211208164141066](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164141066.png)

这种用暂停来处理加载/使用冒险的方法称为*加载互锁*。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。因为只有加载互锁会降低流水线的吞吐量，我们几乎可以实现每个时钟周期发射一条新指令的吞吐量目标。

#### 4. 避免控制冒险

当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。

对于*ret*指令，下面给出了示例程序

![image-20211208164157926](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164157926.png)

图4-55给出了希望流水线如何来处理*ret*指令

![image-20211208164203614](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164203614.png)

*ret*经过译码、执行和访存阶段时，流水线不能做任何有用的活动。只能在流水线中插入三个气泡。一旦*ret*指令到达写回阶段，PC选择逻辑就会将程序计数器设为返回地址，然后取指阶段就会取出位于返回点的指令。

要处理预测错误的分支，考虑下面用汇编代码表示的程序：

![image-20211208164218085](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164218085.png)

![image-20211208164224947](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164224947.png)

### 4.5.6 异常处理

异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。指令集体系结构包括三种不同的内部的异常：

- *halt*指令
- 有非法指令和功能码组合的指令
- 取指或数据读写试图访问一个非法地址

在使用非法指令地址的情况中，没有实际的异常指令，但是想象在非法地址处有一种“虚拟指令”会有所帮助。在一个更完整的设计中，处理器会继续调用异常处理程序，这是操作系统的一部分。

在一个流水线化的系统中，异常处理包括一些细节问题。例如：

1. 可能同时有多条指令会引起异常，必须确定处理器应该向操作系统报告哪个异常。==基本原则是：由流水线最深的指令引起的异常，优先级最高。==
2. 当取出一条指令，开始执行时，导致了一个异常，由于分支预测错误，取消了该指令。
3. 一条指令导致了一个异常，但是它后面的指令在异常指令完成之前改变了部分状态。![image-20211208164248005](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164248005.png)

如果一条指令在其处理中于某个阶段产生了一个异常，*Stat*字段被设置成指示异常的种类。==异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现出现了异常，并停止执行。==

为了避免异常指令之后的指令更新任何程序员可见的状态，当处于访存或写回姐u但中的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或数据内存。

处理细节问题：

当流水线出现一个或多个异常，信息存放在流水线寄存器的状态字段中。异常时间不会对指令流有任何影响，除了会禁止流水线中后面的指令更新程序员可见的状态，直到异常指令到达最后的流水线阶段。

1. 因为指令到达写回阶段的顺序与在非流水线化的处理器中执行的顺序相同，可以保证第二条遇到异常的指令会第一个到达写回阶段，程序停止执行，寄存器W中的状态码会被记录为程序状态。
2. 如果取出了某条指令之后有取消了，所有关于这条指令的异常状态信息也都会被取消。所有导致异常的指令后面的指令都不能改变程序员可见的状态。

### 4.5.7 PIPE各阶段的实现

#### 1. PC选择和取值阶段

![image-20211208164315392](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164315392.png)

PC选择逻辑从三个程序计数器源中进行选择，当一条预测错误的分支进入访存阶段时，会从流水线寄存器M(信号*M_valA*)中读出该指令*valP*的值。当ret指令进入写回阶段时，会从流水线寄存器。其他情况会使用存放在流水线寄存器F(信号*F_predPC*)中的PC的预测值。

![image-20211208164328541](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164328541.png)

当取出的指令为函数调用或跳转时，PC预测逻辑会选择*valC*，否则就选择*valP*

![image-20211208164335547](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164335547.png)

同SEQ不一样，必须䩕指令状态的计算分成两个部分。在取指阶段，可以测试由于指令地址越界引起的内存错误，还可以发现非法指令或*halt*指令，而这必须推迟到访存阶段才能发现非法数据地址。

#### 2. 译码和写回阶段

![image-20211208164348773](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164348773.png)

当*D_icode*与*call*或*jxx*的指令代码相匹配时，这个块就会选择*D_valP*作为它的输出。

有5个不同的转发源，每个都有一个数据字和一个目的寄存器ID：

![image-20211208164358784](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164358784.png)

如果不满足任何转发条件，这个块就应该选择*d_rvalA*作为它的输出，也就是从寄存器端口A中读出的值。

![image-20211208164412615](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164412615.png)

上述代码转发源的顺序优先级是由HCL代码中检测5个目的寄存器ID的顺序来确定的，如果选择了其他任何顺序，对某些程序来说，流水线就会出错。

![image-20211208164617556](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164617556.png)

当转发逻辑必须在两个都以源寄存器为目的值中选择一个，流水线总是给处于最早流水线阶段中的转发源以较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令。只有指令*popq %rsp*会关心在访存或写回阶段中的两个源之间的转发优先级，因为只有这条指令能同时写两个寄存器。

写回阶段的一小部分保持不变。唯一要考虑的特殊情况是当写回阶段有气泡时：![image-20211208164630144](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164630144.png)

#### 3. 执行阶段

![image-20211208164642190](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164642190.png)

信号*e_valE*和*e_dstE*作为转发源，指向译码阶段。一个区别标号为*Set CC*的逻辑信号以*m_stat*和*W_stat*作为输入，这个逻辑决定了是否要更新条件码。这些信号被用来检查一条导致异常的指令正在通过后面的流水线阶段的情况，对任何条件码的更新都会被禁止。

#### 4. 访存阶段

![image-20211208164648970](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164648970.png)

PIPE中没有SEQ中标号为“Data”的块。这个块是用来在数据源*valP*和*valA*中选择的，但是现在由译码阶段中标号为’Sel+Fwd A“的块来指向。

### 4.5.8 流水线控制逻辑

#### 2. 发现特殊控制条件

![image-20211208164727931](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164727931.png)

- 当*ret*指令通过流水线时，要想发现它，只要检查译码、指向和访存阶段中指令的指令码。
- 发现加载/使用冒险要检查执行阶段中的指令类型，并把它的目的寄存器与译码阶段中指令的源寄存器相比较。
- 当跳转指令在执行阶段时，流水线控制逻辑应该能发现预测错误的分支，当指令进入访存阶段时，它就能设置从错误预测中恢复所需要的条件。当指令处于执行阶段时，信号*e_Cnd*指明是否要选择分支。
- 通过检查访存和写回阶段中的指令状态值，就能发现异常指令。对于访存阶段，使用在这个阶段中计算出来的信号*m_stat*，而不是使用流水线寄存器的*M_stat*。这个内部信号包含着可能的数据内存地址错误

#### 3. 流水线控制机制

- 在正常操作下，这两个输入都设为0，使得寄存器加载它的输入作为新的状态。
- 当暂停信号设为1时，禁止更新状态，寄存器保持它以前的状态，这使得它可以将指令阻塞在某个流水线阶段中。
- 当气泡信号设置为1实，寄存器状态会设置成某个固定的复位位置，得到一个等效于*nop*指令的的状态。一个流水线寄存器的复位配置的0、1模式是由流水线寄存器中字段的集合决定的。

![image-20211208164737944](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164737944.png)

下图给出了各个流水线寄存器在三种特殊情况下应该采取的行动。

![image-20211208164746705](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164746705.png)

#### 4. 控制条件的组合

图中所示的是译码、执行和访存阶段的块。暗色的方框代表要出现这种条件必须要满足的特别限制。

![image-20211208164753134](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164753134.png)

从图中可以看出，大多数控制条件是互斥的。只有用箭头标明的两种组合可能同时出现。

组合A中执行阶段中有一条不选择分支的跳转指令，而译码阶段中有一条*ret*指令。出现这种组合要求*ret*位于不选择分支的目标处。流水线控制逻辑应该发现分支预测错误，因此取消*ret*指令。

合并组合A条件的控制动作，得到以下流水线控制动作：

![image-20211208164800914](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164800914.png)

组合情况A的处理与预测错误的分支相似，只不过在取指阶段是暂停。在下一个周期，PC选择逻辑会选择跳转后面那条指令的地址，而不是预测的程序计数器值，所以流水线寄存器F发生了什么是没关系的。

组合B包括一个加载/使用冒险，其中加载指令设置寄存器*%rsp*，然后*ret*指令用这个寄存器作为源操作数，因为它必须从栈中弹出返回地址。流水线控制逻辑应该将*ret*指令阻塞在译码阶段。

合并组合B条件的控制动作，得到以下流水线控制动作。

![image-20211208164807505](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164807505.png)

#### 5.控制逻辑实现

图4-68是流水线控制逻辑的整体结构

![image-20211208164815934](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164815934.png)

### 4.5.9 性能分析

可以通过计算PIPE执行一条指令所需要的平均时钟周期数的估计值，来量化这些处罚对整体性能的影响，这种衡量方法称为CPI(Cycles Per Instruction,每指令周期数)。这种衡量值是流水线平均吞吐量的倒数，不过时间单位是时钟周期，而不是微微秒。

如果忽略异常带来的性能损失，另一种思考CPI的方法是，每个周期，执行阶段要么会处理一条指令，然后这条指令继续通过剩下的阶段，直到完成；要么会处理一个由于三种特殊情况之一而插入的气泡。如果这个阶段一共处理了*C~i~*条指令和*C~b~*个气泡，那么处理器总共需要大约*C~i~+C~b~*个时钟周期来执行*C~i~*指令。可以用下面的方法来计算这个基准程序的CPI：

$CPI = \frac{C_i+C_b}{C_i} = 1.0 \ + \frac{C_b}{C_i}$

这个项表明执行一条指令平均要插入多少个气泡。因为只有三种指令类型会导致插入气泡，可以将这个处罚项分成解分成三个部分：

$CPI  = 1.0 + lp + mp+rp$

*lp*是加载处罚插入气泡的平均数，*mp*是预测错误分支处罚，*rp*是*ret*返回处罚。

为了估计每种处罚，需要知道相关指令的出现频率，以及对每种指令特殊情况出现的频率。对CPI的计算，使用下面这组频率：

- 加载指令占所有执行指令的25%。其中20%会导致加载/使用冒险
- 条件分支指令占所有执行指令的20%，其中60%会选择分支，而40%不选择分支
- 返回指令占所有执行指令的2%

![image-20211208164832966](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164832966.png)



# 存储器部分

## 1. 存储技术

### 1.1 随机访问存储器

随机访问存储器（RAM）分为两类：静态的和动态的。

**1. 静态RAM**

SRAM将每个位存储在一个双稳态的存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有一个属性，它可以无限期地保持在两个不同的电压配置或状态之一。

![image-20211113181901532](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113181901532.png)

由于SRAM存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值。

**2. 动态RAM**

DRAM将每个位存储为一个对电容的充电。这个电容非常小，通常只有大约30毫微微法拉。DRAM存储器可以制造得非常密集——每个的单元由一个电容和一个访问晶体管组成。但是，与SRAM不同，DRAM存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。

![image-20211113182515782](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113182515782.png)

**3. 传统的DRAM**

DRAM芯片中的单元被分成*d*个超单元，每个超单元都有*ω*个DRAM单元组成。一个*d*×*ω*的DRAM总共存储了*dω*位信息。超单元被组织成一个*r*行*c*列的长方形阵列，这里*rc=d*。每个超单元有形如（*i*，*j*）的地址，这里*i*表示行，*j*表示列。

![image-20211113182610897](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113182610897.png)

每个DRAM芯片被来连接到某个称为*内存控制器*的电路，这个电路可以一次传送*ω*位到每个DRAM芯片或一次从每个DRAM芯片传出*ω*位。DRAM把超单元（*i*，*j*）的内容发回给控制器作为响应。行地址*i*称为RAS请求。列地址*j*称为CAS请求。RAS和CAS请求共享相同的DRAM地址引脚。

![image-20211113182821555](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113182821555.png)

电路设计者将DRAM组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。二维阵列组织的缺点是必须分两步发送地址，增加了访问时间。

**4. 内存模块**

DRAM芯片封装在*内存模块*中，它插到主板的扩展槽上。下图展示了一个内存模块的基本思想：用8个64Mbit的8M×8的DRAM芯片，总共存储64MB，这8个芯片编号为0~7。每个超单元存储主存的一个字节，而用相应超单元地址为$(i,j)$的8个超单元来表示主存中字节地址A处的64位字。

![image-20211113183249334](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113183249334.png)

**5. 增强的DRAM**

- 快页模式DRAM（FPM DRAM）：FPM允许对同一行连续地访问可以直接从行缓冲区得到服务。
- 扩展数据输出DRAM（EDO DRAM）：FPM DRAM的一个增强形式，它允许各个CAS信号在时间上靠得更紧密一点。
- 同步DRAM：SDRAM能够比异步的存储器更快地输出它的超单元内容。
- 双倍数据速率同步DRAM：DDR SDRAM是对SDRAM的一种增强，它通过使用两个始终沿作为控制信号，从而使DRAM的速度翻倍。
- 视频RAM：VRAM的思想与FPM DRAM类似。

**6. 非易失性存储器**

非易失性存储器即使在关电后，仍然保存着它们的信息。现在由很多种非易失性存储器，由于历史原因，虽然ROM种有的类型可以读也可以写，但是它们整体上都被称为只读存储器（Read-Only Memory，ROM）。ROM是以它们能够被重编程（写）的次数和对它们进行重编程所用的机制来区分的。

- PROM（Programmable ROM，可编程ROM）只能被编程一次。PROM的每个存储器单元有一种熔丝，只能用高电流熔断一次。
- 可擦可写编程ROM（Erasable Programmable ROM，EPROM）有一个透明的石英窗口，允许光达到存储单元。EPROM能够被擦除和重编程的次数的数量级可以达到1000次。
- 电子可擦除PROM（Electricity Erasable PROM， EEPROM）类似于EPROM，但是它不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。EEPROM能够被编程的次数的数量级可以达到10^5^次。
- 闪存是一类非易失性存储器，基于EEPROM，它已经称为了一种重要的存储技术。

存储在ROM设备种的程序通常被称为固件。当一个计算机系统通电以后，它会运行存储在ROM种的固件。一些系统的固件提供了少量基本的输入和输出函数——例如PC的BIOS例程。

**7. 访问主存**

数据流通过称为总线的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务。

![image-20211113184539361](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113184539361.png)



### 1.2 磁盘存储

磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。

**1. 磁盘构造**

磁盘是由*盘片*构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片得以固定的旋转速率旋转，通常是5400~15000转每分钟。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。

![image-20211113185354084](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113185354084.png)

整个装置通常被称为磁盘驱动器，我们通常简称为磁盘，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。

**2. 磁盘容量**

一个磁盘可以记录的最大位数称为它的最大容量，或者简称为容量。磁盘容量是由以下技术因素决定的：

- 记录密度：磁道一英寸的段种可以放入的位数。
- 磁道密度：从盘片中心出发半径上一英寸的段内可以有的磁道数。
- 面密度：记录密度与磁道密度的乘积。

一个磁盘的容量：
$$
磁盘容量=\frac{字节数}{扇区} \times \frac{平均扇区数}{磁道} \times \frac{磁道数}{表面} \times \frac{表面数}{盘片} \times \frac{盘片数}{磁盘}
$$
**3. 磁盘操作**

磁盘用读/写头来读写存储在磁性表面的位，而读写头连接到一个传动臂一端。通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为寻道。

![image-20211113192848720](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113192848720.png)

磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：

- 寻道时间：为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为*寻道时间*。寻道时间*T~seek~*依赖于读/写头以前的位置和传动臂在盘面上移动的速度。

- 旋转时间；一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读/写头下。这个步骤的性能依赖于当读/写头到达目标扇区时盘面的位置以及磁盘的旋转速度。最大旋转延迟是：
  $$
  T_{max \, rotation} = \frac{1}{RPM} \times \frac{60s}{1min}
  $$
  平均旋转时间是最大旋转延迟的一半

- 传送时间：当目标扇区的第一个位位于读/写头下时，驱动器就可以开始读或者写该扇区的内容。一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。一个扇区以秒位单位的平均传送时间：
  $$
  T_{avg \, transfer} = \frac{1}{RPM} \times \frac{1}{(平均扇区数/磁道)} \times \frac{60s}{1min}
  $$

**4. 逻辑磁盘块**

为了对操作系统隐藏复杂性，现代磁盘将它们的构造呈现为一个简单的视图，一个B个扇区大小的逻辑块的序列，磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际磁盘扇区之间的映射关系。

**5. 连接I/O设备**

有三种不同类型的设备连接到总线：

- 通用串行总线控制器是一个连接到USB总线的设备的中转机构。

- 图形卡包含硬件和软件逻辑，它们负责代表CPU在显示器上画像素。

- 主机总线适配器将一个或多个磁盘连接到I/O总线，使用的是一个特别的主机总线接口定义的通信协议。

  ![image-20211113195027201](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195027201.png)

**6. 访问磁盘**

CPU使用一种称为内存映射I/O的技术来向I/O设备发射命令。在使用内存映射I/O的系统中，地址空间中有一块地址是为与I/O设备通信保留的。每个这样的地址称为一个I/O端口。当一个设备连接到总线时，它与一个或多个端口相关联。

![image-20211113195245462](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195245462.png)

设备可以自己执行读或者写总线事务而不需要CPU干涉的过程，称为*直接内存访问（DMA）*。这种数据传送称为DMA传送。在DMA传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给CPU发送一个中断信号来通知CPU。

### 1.3 固态硬盘

固态硬盘是一种基于闪存的存储技术。一个SSD封装由一个或多个闪存芯片和闪存翻译成组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译成是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。

![image-20211113195806618](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195806618.png)

一个闪存由B个块的序列组成，每个块由P页组成。通常，页的大小是512字节~4KB，块是由32 ~ 128页组成的，块的大小为16KB~512KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页。一旦一个块磨损之后，就不能再使用了。

![image-20211113195840573](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113195840573.png)

随机写很慢，有两个原因。首先，擦除块需要相对较长的时间，1ms级的，比访问页所需的时间要高一个数量级。其次，如果写操作试图修改一个包含已经有数据的页*p*，那么这个块中所有带有用数据的页都必须被复制到一个新块，然后才能进行对页*p*的写。

## 2. 存储器层次结构

一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在最高处(L0)，是少量快速的CPU寄存器，CPU可以在一个时钟周期内访问它们。接下来是一个或多个小型到中型的基于SRAM的高速缓存存储器，可以在几个CPU时钟周期内访问它们。然后是一个大的基于DRAM的主存，可以在几十到几百个始终周期内访问它们。接下来来是慢速但是容量很大的本地磁盘。

![image-20211113214941075](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113214941075.png)

### 2.1 存储器层次结构中的缓存

高速缓存（cache）是一个小而快速的存储设备，它作为存储在更大、更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存。

存储器层次结构的中心思想是，对于每个*k*，位于*k*层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。

第k+1层的存储器被划分成连续的数据对象组块，称为块。每个块都有一个唯一的地址或名字，使之区别于其他的块。块是可固定大小的，也可以是可变大小的。

![image-20211113215155327](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113215155327.png)

在任何时刻，第k层的缓存包含第k+1层块的一个子集的副本。

数据总是以块大小为传递单元在第k层和第k+1层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。一般而言，层次结构中较底层的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。
**1. 缓存命中**

当程序需要地*k*+1层的某个数据对象*d*时，它首先在当前存储在第*k*层的一个块中查找*d*。如果*d*刚好缓存在第*k*层中，那么就是所说的缓存名字。该程序直接从第*k*层读取d，根据存储器层次结构的性质，这要比从第*k*+1层读取*d*更快。

**2. 缓存不命中**

如果第*k*层中没有缓存数据对象*d*，就是*缓存不命中*。当发生缓存不命中时，第*k*层的缓存从第*k*+1层缓存中取出包含*d*的那个块，如果第*k*层的缓存已经满了，可能就会覆盖现存的一个块。

覆盖一个现存的块的过程称为*替换*或*驱逐*这个块。被驱逐的这个块有时也称为牺牲块。决定该替换哪个块是由缓存的替换策略来控制的。

**3. 缓存不命中的种类**

如果第*k*层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时被称为*冷缓存*，此类不命中称为*强制性不命中*或*冷不命中*。冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存暖身之后的稳定状态中出现。

只要发生了不命中，第*k*层的缓存就必须执行某个放置策略，确定把它从第*k*+1层中取出的块放在哪里。最灵活的替换策略是允许来自第*k*+1层的任何块放在第*k*层的任何块中。对于存储器层次结构中高层的缓存，它们是用硬件来实现的，而且速度是最优的。这个策略实现起来通常很昂贵，因为随机地放置块，定位起来代价很高。

因此，硬件缓存通常使用的是更严格的放置策略，这个策略将第*k*+1层的某个块限制放置在第*k*层块的一个小的子集中。

这种限制性的放置策略会引起一种不命中，称为*冲突不命中*，在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。

程序通常是按照一系列阶段来运行的，每个阶段访问缓存块的某个相对稳定不变的集合。

**4. 缓存管理**

存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。在每一层上，某种形式的逻辑必须管理缓存。管理缓存的逻辑可以是硬件、软件，或者是两者的结合。

### 2.2 存储器层次结构概念小结

概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：

- 利用时间局部性：由于时间局部性，同一数据对象可能会被使用多次。一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。
- 利用空间局部性：块通常包含有uoge数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。

## 3. 高速缓存存储器

由于CPU和主存之间逐渐增大的差距，系统设计者被迫在CPU寄存器文件和主存之间插入了一个小的SRAM高速缓存存储器，称为L1高速缓存。L1高速缓存的访问速度几乎和寄存器一样快，典型地是大约4个时钟周期。

![image-20211113224353042](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113224353042.png)

随着内存和主存之间的性能差距不断增大，系统设计者在L1高速缓存和主存之间又插入了一个更大的高速缓存，称为L2高速缓存，可以在大约10个时钟周期内访问到它。

### 3.1  通用的高速缓存存储器组织结构

考虑一个计算机系统，其中每个存储器地址有*m*位。形成M=2^2^个不同的地址。如图所示，这样一个机器的高速缓存被组织成一个有S=2^s^个高速缓存组的数组。每个组包含E个高速缓存行。每个行是由一个B=2^b^字节的数据块组成的，一个有效位指明这个行是否包含有意义的信息，还有*t=m-(b+s)*个标记位（是当前块的内存地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块

![image-20211113225323604](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225323604.png)

一般而言，高速缓存的结构可以用元组(S,E,B,m)来描述。高速缓存的大小C指的是所有块的大小的和。标记位和有效位不包括在内。因此，C=S×E×B。

![image-20211113225537542](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225537542.png)

### 3.2 直接映射高速缓存

根据每个组的高速缓存行数E，高速缓存被分为不同的类。每个组只有一行（E=1）的高速缓存称为*直接映射*高速缓存。直接映射高速缓存是最容易实现和理解的。

![image-20211113225736507](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113225736507.png)

高速缓存确定一个请求是否命中，然后抽取处被请求的字的过程，分为三步：1）组选择；2）行匹配；3）字抽取

**1. 直接映射高速缓存中的组选择**

在这一步中，高速缓存从*ω*的地址中间抽取出*s*个组索引位。这些位被解释成一个对应于一组号的无符号整数。

![image-20211113230233517](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113230233517.png)

**2. 直接映射高速缓存中的行匹配**

在高速缓存中很容易，选中的组只有一个高速缓存行。这个行的有效位设置了，所以我们知道标记和块中的位是有意义的。因为这个高速缓存行中的标记位与地址中的标记位相匹配。

![image-20211113230430756](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113230430756.png)

**3. 直接映射高速缓存中的字选择**

块偏移位提供了所需要的字的第一字节的偏移，字节偏移是到这个数组的一个索引。

**4. 直接映射高速缓存中不命中时的行替换**

对于直接映射高速缓存来说，每个组只包含一行，替换策略非常简单：用新取出的行替换当前的行。

### 3.3 组相连高速缓存

直接映射高速缓存中冲突不命中造成的问题源于每个组只有一行这个限制。*组相联高速缓存*放松了这条限制，所以每个组都保存有多于一个的高速缓存行。一个1<E<C/B的高速缓存通常称为E路组相联高速缓存。

![image-20211113231332116](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113231332116.png)

**1. 组相联高速缓存中的组选择**

它的组选择与直接映射高速缓存的组选择一样，组索引标识组。

**2. 组相联高速缓存中的行匹配和字选择**

组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂，因为它必须检查多个行的标记位和有效位，以确定所请求的字是否在集合中。传统的内存是一个值的数组，以地址作为输入，并返回存储在那个地址的值。另一方面，相联存储器是一个(key, value)对的数组，以key为输入，返回与输入的key相匹配的(key, value)中的value值。因此，可以把组相联高速缓存中的每个组都看成一个小的相连存储器，key是标记和有效位，而value就是块的内容。

![image-20211113232943725](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113232943725.png)

行匹配的重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行，寻找一个有效的行，其标记与地址中的标记相匹配。

![image-20211113233146248](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233146248.png)

### 3.4 全相联高速缓存

全相联高速缓存是由一个包含所有高速缓存行的组(即E=C/B)组成的。

![image-20211113233413642](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233413642.png)

**1. 全相联高速缓存中的组选择**

全相联高速缓存中的组选择非常简单，因为只有一个组。地址中没有组索引位，地址只被划分成了一个标记和一个块偏移。

![image-20211113233503290](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233503290.png)

**2. 全相联高速缓存中的行匹配和字选择**

全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，它们之间的区别主要是规模大小的问题。

![image-20211113233634787](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211113233634787.png)

因为高速缓存电路必须并行地搜索许多相匹配的标记，构造一个又大又快的相连高速缓存很困难，而且很昂贵。因此，全相联高速缓存知识和做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器。

## 4. 高速缓存参数的性能影响

有许多指标来衡量高速缓存的性能：

- 不命中率：在一个程序执行或程序的一部分执行期间，内存引用不命中的比率。它是这样计算的：不命中数量/引用数量
- 命中率：命中的内存引用比。它等于1-不命中率
- 命中时间：从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。对于L1高速缓存来说，命中时间的数量级是几个时钟周期。
- 不命中处罚：由于不命中所需要的额外的时间。L1不命中需要从L2得到服务的除法，通常是数10个周期



