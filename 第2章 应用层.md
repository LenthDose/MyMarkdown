[TOC]

# 第2章 应用层

## 2.1 应用层协议原理

网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是在网络层及下面层次起作用

### 2.1.1 网络应用程序体系结构

两种主流体系结构：

- 客户-服务器体系结构
- 对等体系结构(P2P)

### 2.1.2 进程通信

一个**进程**可以被认为是运行在端系统种的一个程序

#### 1.客户和服务器进程

在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时等到联系的进程是服务器

#### 2. 进程与计算机网络之间的接口

- 进程通过一个称为**套接字**的软件接口向网络发送报文和从网络接收报文
- 套接字称为应用程序和网络之间的**应用程序编程接口**
- 应用程序开发者对于运输层的控制仅限于
  - 选择运输层协议
  - 也许能设定几个运输层参数，如最大缓存和最大报文长度等

#### 3. 进程寻址

为了标识该接收进程，需要定义两种信息：

- 主机的地址
- 在目的主机中指定接收进程的标识符

### 2.1.3 可供应用程序使用的运输服务

#### 1. 可靠数据传输

为了支持这些应用，必须做一些工作以确爆由应用程序的一段发送的数据正确、完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务，就认为提供了**可靠数据传输**

#### 2. 吞吐量[^ ]

- 可用吞吐量就是发送进程能够向接收进程交付比特的速率
- 具有吞吐量要求的应用程序被称为**带宽敏感的应用**
- **弹性应用**能够根据当时可用的带宽或多或少地利用可供使用的吞吐量

#### 3. 定时

运输层协议也能提供定时保证

#### 4. 安全性

运输协议能够为应用程序提供一种或多种安全性服务

### 2.1.4 因特网提供的运输服务

因特网为应用程序提供了两个运输层协议，即UDP和TCP

#### 1. TCP服务

TCP服务模型包括面向连接服务和可靠数据传输服务

- 面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器相互交换运输层控制信息。这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，**一个TCP连接**就在两个进程的套接字之间建立了。*这条连接时全双工的，即连接双方的进程可以在此连接上同时进行报文转发。*当应用程序结束报文发送时，必须拆除该连接
- 可靠数据传送服务：通信进程能够依靠TCP，误差所、按适当顺序交付所有发送的数据。当应用程序的一段将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余
- 拥塞控制机制：当发送放和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程

#### 2. UDP服务

- UDP是一直不提供不必要服务的轻量级运输协议，它仅提供最小服务
- UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的

#### 3. 因特网运输协议锁不提供的服务

对吞吐量或定时保证

### 2.1.5 应用层协议

- 应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文
- **应用层协议**定义了：
  - 交换的报文类型，例如请求报文和响应报文
  - 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的
  - 字段的语义，即这些字段中的信息的含义
  - 确定一个进程何时以及如何发送报文，对报文进行响应的规则
- 应用层协议只是网络应用的一部分
- Web的应用层协议是HTTP，它定义了在浏览器和Web服务器之间传输的报文格式和序列
- 用于电子邮件的主要应用层协议就是SMTP

------



## 2.2 Web和HTTP

### 2.2.1 HTTP概况

- Web的应用层协议是**超文本传输协议**
- HTTP由两个程序实现：一个客户程序和一个服务器程序
- **HTTP**定义了这些报文的结构以及客户和服务器进行报文交换的方式
- Web页面是由对象组成的
- HTTP使用TCP作为它的支撑运输协议
- 因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个**无状态协议**

### 2.2.2 非持续连接和持续连接

- **非持续连接**：每个请求/响应对是经一个单独的TCP连接发送
- **持续连接**：所有的请求及其响应经相同的TCP连接发送
- HTTP在默认方式下使用持续连接

#### 1. 采用非持续连接的HTTP

- 往返时间（RTT)的定义：该事件是指一个短分组从客户到服务器然后再返回客户所花费的时间
- RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延
- 总的响应时间就是两个RTT加上服务器传输HTML文件的时间

#### 2.采用持续连接的HTTP

- 第一，必须为每一个请求的对象建立和维护一个全新的连接
- 第二，就像我们刚描述的那样，每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象
- HTTP的默认模式是时延带流水线的持续连接

### 2.2.3 HTTP报文格式

#### 1.HTTP请求报文

下面提供了一个典型的HTTP请求报文

```
GET/somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent:Mozilla/5.0
Accept-language: fr
```



- HTTP请求报文的第一行叫作请求行，其后继的行叫作首部行

- 请求行有3个字段：方法字段、URL字段和HTTP版本字段

- 方法字段可以取几种不同的值：GET、POST、HEAD、PUT和DELETE

- 首部行Host: www.someschool.edu指明了对象所在的主机，该首部行提供的信息是Web代理高速缓存所要求的

- 通过包含Connection: close 首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接

- User-agent： 首部行用来指明用户代理，即向服务器发送请求的浏览器类型，这个首部行是有用的，因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本

  <img src="https://chenxiaoyan-oss-img-typroa.oss-cn-beijing.aliyuncs.com/img/20210323230021.png"/>

- 使用GET方法时实体体为空，而使用POST方法时，才使用该实体体

- 当用户提交表单时，HTTP客户常常使用POST方法

- HTML表单经常使用GET方法，并在（表单字段中）所请求的URL中包括输入的数据

- HEAD方法：当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象

- PUT方法：需要向Web服务器上传对象的应用程序使用

- DELETE方法：允许用户或者应用程序删除Web服务器上的对象

#### 2. HTTP响应报文

典型的HTTP响应报文

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3(CentOS)
Last-Modified: Tue,18 Aug 2015 15:11:03 GMT
Content-Lenght: 6821
Content-Type: text/html
(data data data data data data...)
```

- 它有三个部分：一个初始状态行，6个首部行，然后是实体体

- 实体体部分是报文的主要部分，即它包含了所请求的对象本身

- 状态行有3个字段：协议版本字段、状态码和相应状态信息

- 首部行：

  - 服务器用Connection：close首部行告诉客户，发送完报文后将关闭TCP连接
  - Date：首部行指示服务器产生并发送该响应报文的日期和时间。（这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间）
  - Server：首部行指示该报文是由一台Apache Web服务器产生的，它类似于HTTP请求报文中的User-agent：首部行
  - Last-Modified：首部行指示了对象创建或者最后修改的日期和时间
  - Last-Modified：首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要
  - Content-Length：首部行指示了被发送对象中的字节数
  - Content-Type：首部行指示了实体体总的对象是HTML文本

  ![image-20210121013105820](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210121013105820.png)

- 一些常见的状态码和相关的短语包括：
  - 200 OK：请求成功，信息在返回的相应报文中
  - 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL
  - 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解
  - 404 Not Found：被请求的文档不在服务器上
  - 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本

### 2.2.4 用户与服务器的交互：cookie

- cookie技术有4个组件
  - 在HTTP响应报文中的一个cookie首部行
  - 在HTTP请求报文中的一个cookie首部行
  - 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理
  - 位于Web站点的一个后端数据库

![image-20210121014941166](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210121014941166.png)

- cookie可以用于标识一个用户
- cookie可以在无状态的HTTP之上建立一个用户会话层

### 2.2.5 Web缓存

- Web缓存器也叫代理服务器，它是能够代表初始Web服务器来满足HTTP请求的网络实体

- Web缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户
- 在因特网上部署Web缓存器由两个原因
  - Web缓存器可以大大减少对客户请求的响应时间
  - Web缓存器能从整体上大大减少因特网上的Web流量，从而改善了所有应用的性能
- 通过使用内容分发网络（CDN），Web缓存器正在因特网种发挥着越来越中重要的作用

### 2.2.6 条件GET方法

HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是条件GET方法，如果：

- 请求报文使用GET方法，并且

- 请求报文中包含一个“If -Modified-Since：”首部行。那么，这个HTTP请求报文就是一个条件GET请求报文

  ------

  

## 2.3 因特网中的电子邮件

- 因特网电子邮件有3个组成部分：
  - 用户代理
  - 邮件服务器
  - 简单邮件传输协议
- 邮件服务器形成了电子邮件体系结构的核心
- SMTP是因特网电子邮件中主要的应用层协议

### 2.3.1 SMTP

SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器

### 2.3.2 与HTTP的对比

- 这两个协议都用于从一台主机向另一台主机传送文件：HTTP从Web服务器向Web客户（通常是一个浏览器）传送文件（也称为对象）；SMTP从一个邮件服务器向另一个邮件服务器传送文件（即电子邮件报文）。
- 当进行文件传送时，持续的HTTP和SMTP都使用持续连接
- HTTP主要时一个拉协议，即在方便的时候，某些人在Web服务器上装在信息，用户使用HTTP从该服务器拉取这些信息。特别是TCP连接是由想接收文件的机器发起的。
- SMTP基本上是一个推协议，即发送邮件服务器把文件推向接收邮件服务器。特别是，这个TCP连接是由要发送该文件的机器发起的

### 2.3.3 邮件报文格式

一个典型的报文首部

```
From：alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life
```

### 2.3.4 邮件访问协议

目前有一些流行的邮件访问协议，包括第三版的邮局协议、因特网邮件访问协议以及HTTP

![image-20210121232949355](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210121232949355.png)

SMTP用来将邮件从发送方的邮件服务器传输到接收方的邮件服务器；SMTP也用来将邮件从发送方的用户代理传送到发送方的邮件服务器。如POP3这样的邮件访问协议用来将邮件从接收方的邮件服务器传送到接收方的用户代理

#### 1.POP3

POP3是一个极为简单的邮件访问协议

#### 2.IMAP

#### 3.基于Web的电子邮件

------



## 2.4 DNS：因特网的目录服务

- 主机的一种标识方法是用它的主机名
- 主机也可以使用所谓IP地址进行标识

### 2.4.1 DNS提供的服务

- 我们需要一种能进行主机名到IP地址转换的目录服务，这就是域名系统（DNS）的主要任务
- DNS是：

  - 一个由分层的DNS服务器实现的分布式数据库
  - 一个使得主机能够查询分布式数据库的应用层协议
  - DNS协议运行在UDP之上，使用53号端口
  - DNS通常是由其他应用层协议所使用的，包括HTTP，SMTP和FTP，将用户提供的主机名解析为IP地址
  - DNS还一个一些重要的服务
    - 主机别名
    - 邮件服务器别名
    - 负载分配 DNS也用于在冗余的服务器之间进行负载分配

### 2.4.2 DNS工作机理概述

- DNS的一种简单设计是在因特网上只使用一个DNS服务器，该服务器包含所有的映射，这种集中式设计的问题包括：
  - 单点故障：如果该DNS服务器崩溃，整个因特网随之瘫痪
  - 通信容量：单个DNS服务器不得不处理所有的DNS查询
- 远距离的集中式数据库：单个DNS服务器不可能“邻近”所有查询客户
  - 维护：单个DNS服务器将不得不为所有的因特网主机保留记录。

####  1. 分布式、层次数据库

- 大致说来，有3种类型的DNS服务器：根DNS服务器、顶级域（TLD）DNS服务器和权威服务器

![image-20210121233830715](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210121233830715.png)

- 根服务器：有400多个根名字服务器遍及全世界。这些根名字服务器由13个不同的组织管理。根名字服务器提供TLD服务器的IP地址
- 顶级域（DNS）服务器：对于每个顶级域和所有国家的顶级域，都有TLD服务器（或服务器集群）。TLD服务器提供了权威服务器DNS服务器的IP地址
- 权威DNS服务器：在因特网上具有公共可访问主机的美俄个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址

![](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210121234423454.png)

- 还有另一类重要的DNS服务器，称为本地DNS服务器。严格来说，一个本地DNS服务器并不属于该服务器的层次结构，但它对DNS层次结构是至关重要的
- 当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台本地DNS服务器的IP地址
- TLD服务器只是直到中间的某个DNS服务器，该中间DNS服务器依次才能知道用于该主机的权威DNS服务器
- 从理论上讲，任何DNS查询既可以是迭代的也能是递归的

#### 2.DNS缓存

- 实际上，为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术
- DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息
- 本地DNS服务器也能缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链种的根DNS服务器。事实上，因为缓存，除了少数DNS查询外，根服务器都被绕过了

### 2.4.3 DNS记录和报文

- 共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（RR），RR提供了主机名到IP地址的映射。

- 每个DNS回答报文包含了一条或多条资源记录

- 资源记录是一个包含了下列字段的4元组

  ```
  （Name, Value, Type, TTL)
  ```

- TTL是该记录的生存时间，它决定了资源记录应当从缓存种删除的时间

- Name和Value的值取决于Type：

  - 如果Type=A，则Name是主机名，Value是该主机名对应的IP地址。因此，一台类型为A的资源记录提供了标准的主机名到IP地址的映射。例如：

    ```
    （relay1.bar.foo.com,145.37.93.126,A)
    ```

  - 如果Type= NS，则Name是个域（如foo.com），而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如：

    ```
    （foo.com, dns.foo.com, NS)
    ```

  - 如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名，例如：

    ```
    （foo.com, relay1.bar.foo.com, CNAME）
    ```

  - 如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名。举例来说：

    ```
    （foo.com, mail.bar.foo.com, MX)
    ```

    为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录

- 如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含用于该主机名的类型A记录（即使该DNS服务器不是其权威DNS服务器，它也可能在缓存中包含有一条类型A记录）

- 如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应于包含主机名的域；它还将包括一条类型A记录，该记录提供了在NS记录的Value字段中的DNS服务器的IP地址

#### 1.DNS报文

- 前12个字节是首部区域，其中有几个字段   
  - 标识符：用于标识该查询，会被复制到对查询的回答的报文中，以便让客户用它来匹配发送的请求和接收到的回答
- 问题区域包含正在进行的查询信息，包括：
  - 名字字段：包含正在被查询的主机名字
  - 类型字段：指出有关该名字的正在被询问的问题类型
- 在来自DNS服务器的回答中，回答区域包含了对最初请求的名字的资源记录，在回答报文的回答区域中可以包含多条RR，因此一个主机能够有多个IP地址
- **权威区域**包含了其他权威服务器的记录
- **附加区域**包含了其他有帮助的记录

#### 2.在DNS数据库中插入记录

- 第一件事是在注册登记机构注册域名
- 当你向某些注册登记机构注册域名时，需要向该机构提供你的基本和辅助权威DNS服务器的名字和IP地址，该注册登记机构确保将一个类型NS和一个类型A的记录输入TLDcom服务器
- 还必须确保用于Wen服务器的类型A资源记录和用于邮件服务器的MX资源记录被输入你的权威DNS服务器中

------

### 2.5 P2P文件分发

- 最为流行的P2P文件分发协议是BitTorrent

#### 1.P2P体系结构的扩展性

![image-20210124232536692](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210124232536692.png)

- us表示服务器接入链路的上载速率
- ui表示第i对等方接入链路的上载速率
- di表示了第i对等方接入链路的下载速率
- F表示被分发的文件长度
- N表示要获得的该文件副本的对等方数量
- 分发时间是所有N个对等方得到该文件的副本所需要的时间，表示为Dcs

![image-20210124233018356](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210124233018356.png)

- 因为分发时间取决于每个对等方如何向其他对等方分发该文件的各个部分

  ![image-20210124233413590](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210124233413590.png)

  ![image-20210124233424376](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210124233424376.png)

- 这种扩展性的直接成因是：对等方除了是比特的消费者外还是它们的重新分发者

#### 2.BitTorrent

- BitTorrent是一种用于文件分发的流行P2P协议
- 参与一个特定文件分发的所有对等方的集合被称为一个洪流
- 每个洪流具有一个基础设施节点，称为追踪器

------

# 第3章 运输层

## 3.1 概述和运输层服务

- 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能
- 应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施细节
- ![image-20210124234433567](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210124234433567.png)
- 运输层协议是在端系统中而不是在路由器中实现
- 运输层将从发送应用程序进程接收到报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段。实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以及生成运输层报文段
- 网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段
- 网络应用程序可以使用多种的运输层协议，每种协议都能为调用的应用程序提供一组不同的运输层服务

### 3.1.1 运输层和网络层的关系

- 网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信
- 运输层协议只工作在端系统中
- 在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）
- 中间路由器既不处理也不识别运输层加在应用层报文的任何信息
- 计算机网络中可以安排多种运输层协议，每种协议为应用程序提供不同的服务模式
- 运输协议能够提供的服务常常受限于底层网络层协议的服务模型
- 然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务，也就是说网络层协议会使分组丢失、篡改和冗余，运输协议也能为应用程序提供可靠的数据传输服务
- 即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取

### 3.1.2 因特网运输层概述

- TCP和UDP的分组统称为报文段，而将数据报名称保留给网络层分组
- 因特网网络层协议有一个名字叫IP，即网际协议。IP为主机之间提供逻辑通信，IP的服务模型是**尽力而为交付服务**。这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为**不可靠服务**
- 每台主机至少有一个网络层地址，即所谓的IP地址
- UDP和TCP所提供的服务模型
  - UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务
  - 将主机间交付扩展到进程间交付被称为**运输层的多路复用**与**多路分解**

- UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。
- 进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务
- TCP为应用程序提供了几种附加服务
  - 首先，它提供**可靠数据传输**
  - 通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程
  - TCP还提供**拥塞控制**，拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备
  - TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽，这可以通过调节TCP连接的发送端发送进网络的流量速率来做到
- UDP传输的应用程序可以根据其需要以其愿意的任何速率发送数据

## 3.2 多路复用与多路分解

- 多路复用与多路分解服务是所有计算机网络都需要的
- 在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字
- 由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式却决于它是UDP还是TCP套接字
- 在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字
- 将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解**
- 在源主机从不同套接字中收集数据块，并为每个数据块封装首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到udp网络层，所有这些工作称为**多路复用**
- 它们与在某层（在运输层或别处）的单一协议何时被位于接下来的较高层的多个协议使用有关
- 多路复用要求：
  - 套接字有唯一标识符
  - 每个报文段有特殊字段来指示该报文段所要交付到的套接字
  - 这些特殊字段是**源端口号字段**和**目的端口号字段**
  - 0~1023范围的端口号称为周知端口号，是受限制的，这是值它们保留给诸如HTTP和FTP之类的周知应用层协议来使用的。当我们在开发一个新的应用程序时，必须为其分配一个端口号

#### 1. 无连接的多路复用与多路分解

- 一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号
- 如果两个UDP报文段有不同的源IP地址和/或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程

#### 2. 面向连接的多路复用与多路分解

- TCP套接字是由一个四元组(源IP地址，源端口号，目的IP地址，目的端口号)来标识的
- 两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求
- 服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字

#### 3. Web服务器与TCP

- 该服务器能够根据源IP地址和源端口号来区分来自不同客户端的报文段
- 事实上，当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建具有新连接套接字的新线程（线程可被看作是一个轻量级的子进程）
- 这种套接字的频繁创建和关闭会严重地影响一个繁忙的Web服务器性能

## 3.3 无连接运输：UDP

- 运输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据
- UDP只是做了运输协议能够做的最少的工作
- UDP从应用进程到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层
- 有许多应用更适合用UDP，原因主要有以下几点：
  - 关于发送什么数据以及何时发送的应用层控制更为精细
    - 采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层
    - 因为实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失，TCP服务模型并不是特别适合这写应用的需要
  - 无须建立连接
    - UDP不会引入建立连接的时延，这可能是DNS运行在UDP上而不是运行在TCP之上的主要原因
    - HTTP使用TCP而不是UDP，因为对于具有文本数据的Web网页来说，可靠性是至关重要的
  - 无连接状态
    - TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数
  - 分组首部开销小
    - 每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销

### 3.3.1 UDP报文段结构

- 通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能）
- 长度字段指示了在UDP报文段中的字节数（首部加数据）
- 接收方使用检验和来检查在该报文端中是否出现了差错
- 实际上，计算检验和时，除了UDP报文段以外还包括了IP首部的一些字段

### 3.3.2 UDP检验和

- UDP检验和提供了差错检测功能
- 检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发送了改变
- 发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段
- 提供检验和的原因：不能保证源和目的之间的所有链路都提供差错检测
- 在即无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的**端到端原则**
- 虽然UDP提供差错检测，但是它对差错恢复无能为力
- UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告

## 3.4 可靠数据传输原理



TCP是在不可靠的（IP）端到端网络层之上实现的可靠数据传输协议

### 3.4.1 构造可靠数据传输协议

#### 1. 经完全可靠信道的可靠数据传输：rdt1.0

首先考虑最简单的情况，即底层信道是完全可靠的

![image-20210310220547653](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210310220547653.png)

图显示了rdt1.0发送方和接收方的有限状态机（FSM）的定义。

FSM描述图中的箭头指示了协议从一个状态变迁到另一个状态。

如果对一个事件没有动作，或没有就事件发生而采取了一个动作，我们将在横线上方或下方使用符号A，以分别明确地表示缺少动作或事件。FSM的初始状态用虚线表示

#### 2. 经具有比特差错信道的可靠数据传输：rdt2.0









### 3.5 面向连接的运输：TCP

#### 3.5.1 TCP连接

TCP被称为是面向连接的原因是在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互握手，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。

作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP变量。

TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。

TCP连接提供的是全双工服务，意思是：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在进程AB之间相互流通。

TCP连接也总是点对点的，即在单个发送方与单个接收方之间的连接。

TCP的三次握手：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据，第三个报文段可以承载。

TCP将这些数据引导到该连接的发送缓存里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP会不时从发送缓存里取出一块数据传递到网络层。

TCP可以从缓存中取出并放入报文段中的数据数量受限于最大报文段长度（MSS）。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元（MTU））来设置。设置该MSS要保证一个TCP报文段加上TCP/IP首部长度将适合链路层帧。

#### 3.5.2 TCP报文段结构

![image-20210311005824596](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210311005824596.png)

- 源端口号和目的端口号：用于多路复用/分解来自或送到上层应用的数据。
- 报文首部还包括：
  - 32比特的序号字段和确认号字段：用于实现可靠数据传输服务
  - 16比特的接收窗口字段：用于流量控制
  - 4比特的首部长度字段：指示了以32比特的字为单位的TCP首部长度，TCP首部的长度是可变的
  - 可选与变长的选项字段：用于发送方与接收方协商最大报文段长度或在高速网络环境下作用窗口调节因子
  - 标志字段：ACK比特用于指示确认字段中的值是有效的

**1.序号和确认号**

TCP报文段首部中两个最重要的字段是序号字段和确认号字段。这两个字段是TCP可靠传输服务的关键部分。

TCP把数据看成一个无结构的、有序的字节流，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号是该报文段首字节的字节流编号。

一个报文段的确认号是主机A期望从主机B收到的下一字节的序号。

TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累计确认

一条TCP连接的双方均可随机地选择初始序号。

![image-20210324002633157](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210324002633157.png)

#### 3.5.3 往返事件的估计与超时

**1. 估计往返事件**

报文段的样本RTT就是从某报文段被发出（即交给IP）到对该报文段的确认被收到之间的时间量。

大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT，TCP也不为已被重传的报文段计算SampleRTT，它仅为传输一次的报文段测量SampleRTT。

因为路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT值会随之波动，所以任何给定的SampleRTT值也许都是非典型的，为了估计一个典型的RTT，TCP维持一个SampleRTT均值（称为EstiamtedRTT）。一旦获得一个新的SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT：

![image-20210324003315073](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210324003315073.png)

![image-20210324003419000](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210324003419000.png)

除了用于估算RTT外，测量RTT的变化也是有价值的。RTT偏差是DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度。

![image-20210324003554100](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210324003554100.png)

**2.设置和管理重传超时间隔**

超时间隔应该大于等于EstimateRTT，否则将造成不必要的重传，但超时间隔也不应该比EstimatedRTT大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延较大

![image-20210324003846429](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210324003846429.png)

#### 3.5.4 可靠数据传输





































































[^ ]:它是瓶颈链路的传输速率











































