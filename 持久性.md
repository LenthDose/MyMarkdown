# 持久性

## I/O设备

**I/O应该如何集成进系统中？其中的一般机制是什么？如何让它们变得更高效？**

### 36.1 系统架构

典型系统的架构。其中，CPU通过某种内存总线或互连电缆连接到系统内存。图像或其他高性能I/O设备通过常规的I/O总线连接到系统，在许多现代系统中会是PCI或它的衍生形式。最后，更下面是外围总线，比如SCSI、SATA或者USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。

![1615025748539](C:\Users\Silhouette76\Documents\Tencent Files\1548623884\FileRecv\MobileFile\1615025748539.jpg)

分层架构是因为物理布局及造价成本。越快的总线越短，因此高性能的内存总线没有足够的空间连接太多设备。另外，在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式。这样可以让要求高性能的设备（比如显卡）离CPU更近一些，低性能的设备离CPU远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。

### 36.2 标准设备

![1615025994231](C:\Users\Silhouette76\Documents\Tencent Files\1548623884\FileRecv\MobileFile\1615025994231.jpg)第一部分是向系统其他部分展现的硬件接口。同软件一样，硬件也需要一些接口，让系统软件来控制它的硬件操作。因此，所有设备都有自己的特定接口以及典型交互的协议。

第二部分是它的内部结构。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的首先接口。非常简单的设备通常用一个或几个芯片来实现它们的功能。更复杂的设备会包含简单的CPU、一些通用内存、设备相关的特定芯片，来完成它们的工作。

### 36.3 标准协议

一个（简化的）设备接口包含3个寄存器：

- 一个状态寄存器，可以读取并查看设备当前的状态
- 一个命令寄存器，用于通知设备执行某个具体任务
- 一个数据寄存器，将数据传给设备或从设备接收数据。

通过读写这些寄存器，操作系统可以控制设备的行为。

协议如下：

![image-20210306182745768](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210306182745768.png)

该协议包含4步：

- 第1步，操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询设备（基本上，就是问它正在做什么）
- 第2步，操作系统下发数据到数据寄存器
- 第3步，操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。
- 第4步，操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指令成功或失败的错误码）

这个简单的协议好处是足够简单并且有效。但是难免会有一些低效和不方便。

**操作系统检查设备时如何避免频繁轮询，从而降低管理设备的CPU开销？**

### 36.4 利用中断减少CPU开销

有了中断后，CPU不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发CPU跳转操作系统预先定义好的中断服务例程（ISR），或更为简单的中断处理程度。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或错误码），并且唤醒等待I/O的进程继续执行。

中断允许计算与I/O重叠，这是提高CPU利用率的关键。

但是，使用中断并非总是最佳方案。假如有一个非常高性能的设备，它处理请求很快：通常在CPU第一次轮询时就可以返回结果。此时如果使用中断，反而会使系统变慢；切换到其他进程，处理中断，再切换回之前的进程代价不小。

因此，如果设备非常快，那么最好的办法反而是轮询。如果设备比较慢，那么采用允许发生重叠的中断更好。如果设备的速度未知，或者时快时慢，可以考虑混合策略，先尝试轮询一小段时间，如果设备没有完成操作，此时再使用中断。

### 36.5 利用DMA进行更高效的数据传送

DMA引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。

DMA工作过程如下：为了能够将数据传送给设备，操作系统会通过变编程告诉DMA引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉操作系统自己以及完成了数据传输。![image-20210306205920013](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210306205920013.png)



### 36.6 设备交互的方法

**硬件如何与设备通信？是否需要一些明确的指令？或者其他的方式？**

主要有两种方式：

- 第一种方法相对老一些，就是用明确的I/O指令。这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议。

  *这些指令通常是特权指令。操作系统是唯一可以直接与设备交互的实体*

- 第二种方法是内存映射I/O。通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。

  *内存映射I/O的好处时不需要引入新指令来实现设备交互*

### 36.7 纳入操作系统：设备驱动程序

每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用。

**如何保持操作系统的大部分与设备无关，从而对操作系统的主要子系统隐藏设备交互的细节？**

在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序，所有设备交互的细节都封装在其中。

这种封装也有不足的地方。例如：如果有一个设备可以提供很多特殊的功能，但为了兼容大多数操作系统它不得不提供一个通用的接口，这样就使得自身的特殊功能无法使用了。

因为所有需要插入系统的设备都需要安装对应的驱动程序，所以久而久之，驱动程序的代码在整个内核代码中的占比越来越大。任何安装进操作系统的驱动程序，大部分默认都不是激活状态。因为驱动程序的开发者大部分是“业余的”，所以他们更容易写出缺陷，因此时内核崩溃的主要贡献者。

## 磁盘驱动器

**现代磁盘驱动器任何存储数据？接口是什么？数据是如何安排和访问的？**

### 37.1 接口

所有现代驱动器的基本接口都很简单。驱动器由大量扇区（512字节块）组成，每个扇区都可以读取或写入。在具有n个扇区的磁盘上，扇区从0到n-1编号。因此，我们可以将磁盘视为一组扇区，0到n-1是驱动器的地址空间。

### 37.2 基本几何形状

现代磁盘的组件：它是一个圆形坚硬的表面，通过引入磁性变化来永久存储数据。磁盘可能有一个或多个盘片。每个盘片有两面，每面都称为表面。这些盘片通常由一些硬质材料（如铝）制成，然后涂上薄薄的磁性层，即使驱动器断电，驱动器也能持久存储数据位。

数据在扇区的同心圆章的每个表面上被编码。我们称这样的同心圆为一个磁道。一个比奥面包含数以千计的磁道，紧密地排在一起，数百个磁道只有头发的宽度。

要从表面进行读写操作，我们需要一种机制，使我们能够感应（即读取）磁盘上的磁性图案，或者让它们发生变化（即写入）。读写过程由磁头完成；驱动器的每个表面有一个这样的磁头。磁头连接到单个磁盘臂上，磁盘臂在表面上移动，将磁头定位在期望的磁道上。

### 37.3 简单的磁盘驱动器

*单磁道延迟：旋转延迟*

在简单的磁盘中，磁盘不必做太多工作。具体来说，它必须等待期望的扇区旋转到磁头下。这种等待在现代驱动器中经常发生，并且是I/O服务时间的重要组成部分，它有一个特殊的名称：旋转延迟

*多磁道：寻道时间*

寻道，以及旋转，是最昂贵的磁盘操作之一。

寻道有许多阶段：首先是磁盘臂移动时的加速阶段。然后随着磁盘臂全速移动而惯性滑动。然后随着磁盘臂减速而减速。最后，在磁头小心地放置在正确的磁道上时停下来。停放时间通常不小，例如0.5~2ms，因为驱动器必须确定找到正确的磁道。

*一些其他细节*

许多驱动器采用某种形式的磁道偏斜，以确保即使在跨越磁道边界时，顺序读取也可以方便地服务。

扇区往往会偏斜，因为从一个磁道切换到另一个磁道时，磁盘需要时间来重新定位磁头（即便移到相邻磁道）。如果没有这种偏斜，磁头将移动到下一个磁道，但所需的下一个块以及旋转到磁头下，因此去东区将不得不等待整个旋转延迟，才能访问下一个块。

外圈磁道通常比内圈磁道具有更多扇区，这是几何结构的结果。那里空间更多。这些磁道通常被称为多区域磁盘驱动器，其中磁盘被组织成多个区域，区域是表面上连续的一组磁道。每个区域每个磁道具有相同的扇区数量，并且外圈区域比内圈区域更多的扇区。

任何现代磁盘驱动器其都有一个重要组成部分，即它的缓存，由于历史原因有时称为磁道缓冲区。该缓存只是少量的内存（通常大约8MB或16MB），驱动器可以使用这些内存来保存从磁盘读取或写入磁盘的数据。

在写入时，驱动器面临一个选择：它应该在将数据放入其内存之后，还是写入实际磁盘之后，回报写入完成？前者称为后写缓存，后者则称为直写。后写缓存有时会事驱动器看起来“更快“，但可能有危险。如果文件系统或应用程序要求将数据按特定顺序写入磁盘以保证正确性，后写缓存可能会导致问题。

### 37.4 I/O时间：用数学

现在将I/O时间表示为3个主要部分之和：T<sub>I/O</sub>=T<sub>寻道</sub>+T<sub>旋转</sub>+T<sub>传输</sub>

通常比较驱动器用I/O速率（R<sub>I/O</sub>）更容易。R<sub>I/O</sub>=大小<sub>传输</sub>/T<sub>I/O</sub>

假设有两个工作负载：

- 第一个工作负载称为随机工作负载，它向磁盘上的随机位置发出小的（例如4KB）读取请求。
- 第二个称为顺序负载，只是从磁盘连续读取很大的扇区，不会跳过。顺序访问模式很常见，因此也很重要。

磁盘驱动市场的两个重要部分：

- “高性能”驱动器市场，驱动器的设计尽可能快，提供低寻道时间，并快速传输数据。
- “容量：市场，每字节成本时最重要的方面。因此，驱动器速度较慢，但将尽可能多的数据放到可用空间中。

> 尽可能以顺序方式将数据传输到磁盘，并从磁盘传输数据。如果顺序不可行，至少应考虑以大块传输数据：越大越好。如果I/O是以小而随机方式完成的，则I/O性能将收到显著影响。

![image-20210309154902104](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210309154902104.png)

随机工作负载情况下：Cheetah上：T<sub>寻道</sub>=4ms T<sub>旋转</sub>=2ms T<sub>传输</sub>=30us

完全寻道可能需要两到三倍的时间。

平均旋转延迟直接根据RPM计算。15000RPM等于250RPS（每秒转速）。因此，每次旋转需要4ms。平均而言，磁盘将会遇到半圈旋转，因此平均时间为2ms。

最后，传输时间就是传输大小除以峰值传输速率。在这里它小得几乎看不见。

根据公式，Cheetah的T<sub>I/O</sub>大致等于6ms。Cheetah的R<sub>I/O</sub>大约是0.66MB/s。

对Barracuda进行计算，得到T<sub>I/O</sub>约为13.2ms，R<sub>I/O</sub>约为0.31MB/s

------

顺序工作负载，在这里假定一次很长的传输之前有一次寻道和旋转，假设传输的大小为100MB，因此Barracuda的T<sub>I/O</sub>约为800ms，R<sub>I/O</sub>约为125MB/s，Cheetah约为950ms，R<sub>I/O</sub>约为105MB/s

------

![image-20210309160657428](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210309160657428.png)

- 随机和顺序工作负载之间的驱动性能差距很大，对于Cheetah来说几乎是200倍左右，而

对于Barracuda来说差不多是300倍

- 高端”性能“驱动器与低端“容量”驱动器之间的性能差异很大。出于这个原因，人们往往愿意为前者支付最高的价格，同时尽可能便宜地获得后者

### 37.5 磁盘调度

由于I/O的高成本，操作系统在决定发生给磁盘的I/O顺序方面来发挥作用。更具体地说，给定一组I/O请求，磁盘调度程序检查请求并决定下一个要调度的请求。

对于磁盘调度，我们可以很好地猜测“任务”（即磁盘请求）需要多长时间。通过估计请求的查找和可能的旋转延迟，磁盘调度程序可以直到每个请求将花费多长时间，因此选择服务花费最少时间的请求。因此，磁盘调度程序将尝试在其操作中遵循SJF（最短任务优先）的原则。

*SSTF：最短寻道时间优先*

一种早期的磁盘调度方法称为最短寻道时间优先（SSTF）。SSTF按磁道对I/O请求队列排序，选择在最近磁道上的请求先完成。

SSTF不是万能的，第一个问题：主机操作系统无法利用驱动器的几何结构，而是只会看到一系列的块。可以通过最近块优先（NBF）来解决。

第二个问题：饥饿，SSTF会对磁头当前所在位置的内圈磁道有稳定的请求，然后完全忽略对其他磁道的请求。

*电梯（又称SCAN或C-SCAN）*

该算法最初称为SCAN，简单地以跨越磁道的顺序来服务磁盘请求。将一次跨越磁盘称为扫一遍。因此，如果请求的块所属的磁道在这次扫一遍中已经服务过了，它就不会立即处理，而是排队等下一次扫一遍。

C-SCAN是另一种常见的变体，即循环SCAN的缩写。不是在一个方向扫过磁盘，该算法从外圈扫到内圈，然后从内圈扫到外圈，如此下去。

但是SCAN及其变种并没有严格遵守SJF的原则，忽视了旋转。

*SPTF：最短定位时间优先*

如果寻道时间远远高于旋转延迟，那么SSTF及其变体就适用。但是，如果寻道比旋转快得多。

在现代驱动器总，查找和旋转大致相当，因此SPTF是有用的，它提高了性能。然而，它在操作系统中实现起来更加困难，操作系统通常不太清楚磁道边界在哪，也不知道磁头当前的位置（旋转到了哪里）。因此，SPTF通常在驱动器内部执行。

*其他调度问题*

在现代系统中，磁盘可以接收多个分离的请求，它们本身具有复杂的内部调度程序（它们可以准确地实现SPTF。在磁盘控制器内部，所有相关细节都可以得到，包括精确的磁头位置）。因此，操作系统调度程序通常会选择它认为最好的几个请求，并将它们全部发送到磁盘。磁盘然后利用其磁头位置和详细的磁道布局信息等内部信息，以最佳可能（SPTF）顺序服务于这些请求。

磁盘调度程序执行的另一个重要相关任务是I/O合并。调度程序执行的所有请求都基于合并后的请求。合并在操作系统级别尤其重要，因为它减少了发送到磁盘的请求数量，从而降低了开销。

现代调度程序关注的最后一个问题是：在向磁盘发出I/O之前，系统应该等待多久？研究表明，有时最好等待一段时间，即所谓的非工作保全方法。通过等到，新的和“更好”的请求可能会到达磁盘，从而提高整体效率。

## 廉价冗余磁盘阵列（RAID）

**我们如何构建一个大型、快速和可靠的存储系统？关键技术是什么？不同方法之间的折中是什么？**

廉价冗余磁盘阵列是使用多个磁盘一起构建构建更快、更大、更可靠的磁盘系统。

从外部看，RAID看起来像一个磁盘：一组可以读取或写入的块。

在内部，RAID是一个复杂的庞然大物，由多个磁盘、内存（包括易失性和非易失性）以及一个或多个处理器来管理系统。硬件RAID非常像一个计算机系统，专门用于管理一组磁盘。

与单个磁盘相比，RAID具有许多优点：

- 性能，并行使用多个磁盘可以大大加快I/O时间
- 容量，大型数据集需要大型次磁盘
- RAID可以提高可靠性。在多个磁盘上传输数据（无RAID技术）会使数据容易受到单个磁盘丢失的影响。通过某种形式的冗余，RAID可以容许损失一个磁盘并保持运行。

RAID对于主机系统看起来就像一个大磁盘，透明的好处在于它可以简单地用RAID替换磁盘，而不需要更换一行软件。操作系统和客户端应用程序无须修改，就可以继续运行。通过这种方式，透明极大地提高了RAID的可部署性，使用户和管理员可以使用RAID，而不必担心软件兼容性问题。

### 38.1 接口和RAID内部

当文件系统向RAID发出逻辑I/O请求时，RAID内部必须计算要访问的磁盘（或多个磁盘）以完成请求，然后发出一个或多个物理I/O来执行此操作。

RAID系统通常构建为单独的硬件盒，并通过标准连接接入主机。然而，在内部，RAID相当复杂。它包括一个微控制器，运行固件以直到RAID的操作。它还包括DRAM这样的易失性存储器，在读取和写入时缓冲数据块。在某些情况下，还包括非易失性存储器，安全地缓冲写入。它甚至可能包含专用的逻辑电路，来执行奇偶校验计算。在很高的层面上，RAID是一个非常专业的计算机系统：它有一个处理器，内存和磁盘。然而，它不是运行应用程序，而是运行专门用于操作RAID的软件。

### 38.2 故障模型

假设第一个故障模型，称为故障—停止故障模型。在这种模式下，磁盘可以处于两种状态之一：工作状态或故障状态。使用工作状态的磁盘时，所有块都可以读取或写入。相反，当磁盘出现故障时，我们认为它永久丢失。

### 38.3 如何评估RAID

- 第一个方面是容量。在给定一组N个磁盘的情况下，RAID的客户端可用的容量有多少？没有冗余，是N。不同的是，如果有一个系统保存每个块的两个副本，我们将获得N/2的有用容量。不同的方案通常介于两者之间。
- 第二个方面是可靠性，设计允许有多少磁盘故障？
- 第三个方面是性能，性能难以评估，因为它在很大程度上取决于磁盘阵列提高的工作负载。因此在评估性能之前，首先提出一组应该考虑的典型工作负载。



### 38.4 RAID0级：条带化

第一个RAID级别实际上不是RAID级别，因为没有冗余。

![image-20210309220614922](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210309220614922.png)

基本思想：以轮转方式将磁盘阵列的块分布在磁盘上。这种方法的目的是对数组的连续块进行请求时，从阵列中获取最大的并行性。我们将同一行中的块称为条带。

![image-20210309220937315](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210309220937315.png)

*大块大小*

一方面，大块大小主要影响阵列的性能。例如：大小较小的大块意味着许多文件将跨多个磁盘进行条带化，从而增加了对单个文件的读取和写入的并行性。但是，跨多个磁盘访问块的定位时间会增加，因为整个请求的定位时间由所有驱动器上请求的最大定位时间决定。

另一方面，较大的大块大小减少了这种文件内的并行性，因此依靠多个并发请求来实现高吞吐量。但是，较大的大块大小减少了定位时间。例如；如果一个文件放在一个块中并放置在单个磁盘上，则访问它时发送的定位时间将只是单个磁盘的定位时间。

*回到RAID-0分析*

从容量的角度来看，它是顶级的：给定N个磁盘，条件化提供N个磁盘的有用容量。从可靠性的角度来看，条带化也是顶级的。最糟糕的是，任何磁盘故障都会导致数据丢失。最好，性能非常好：通常并行使用磁盘来为用户I/O请求提供服务。

*评估RAID性能*

在分析RAID性能时，可以考虑两种不同的性能指标

- 首先是单请求延迟，了解单个I/O请求对RAID的满意度非常有用，因为它可以揭示单个逻辑I/O操作期间可以存在多少并行性。
- 第二个是RAID的稳态吞吐量，即许多并发请求的总带宽。由于RAID常用于高性能环境，因此稳态带宽至关重要。

为了理解吞吐量，假设有两种类型的工作负载：顺序负载和随机负载

- 对于顺序的工作负载，假设对阵列的请求大部分是连续的
- 对于随机工作负载，假设每个请求都很小，并且每个请求都是到磁盘上不同的随机位置。

顺序和随机工作负载会导致磁盘的性能特征差异很大

- 对于顺序访问，磁盘以最高效的模式运行，花费很少时间寻道并等待旋转，大部分时间都在传输数据。
- 对于随机访问，大部分时间花在寻道和等待旋转上，花在传输数据上的时间相对较少。

*再次回到RAID-0分析*

从延迟角度来看，单块请求的延迟应该与单个磁盘的延迟几乎相同

从稳态吞吐量的角度来看，期望获得系统的全部带宽，因此，吞吐量等于N（磁盘数量）乘以S（单个磁盘的顺序带宽）。对于大量的随机I/O，我们可以再次使用所有的磁盘，从而获得N●RMB/s。

### 38.5 RAID1级：镜像

对于镜像系统，我们只需生产系统中每个块的多个副本，每个副本应该放在一个单独的磁盘上，这样做可以容许磁盘故障

![image-20210309225745283](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210309225745283.png)

在这个例子中，数据在这些镜像对之间条带化。

从镜像阵列读取块时，RAID有一个选择：它可以读取任一副本。

在写入块时：RAID必须更新两个副本的数据，以保持可靠性，这些写入可以并行进行。

*RAID-1分析*

- 从容量的角度，RAID-1价格昂贵，在镜像级别=2的情况下，只能获得峰值有用容量的一般，对于N个磁盘，镜像的有用容量为N/2.
- 从可靠性的角度，RAID-1表现良好，它可以容许任何一个磁盘的故障，最多可容许N/2个磁盘故障，这取决于哪些磁盘故障。
- 从性能的角度，从单个读取请求的延迟来看，它与单个磁盘上的延迟相同。所有RAID-1都会将读取导向一个副本。写入有点不同：在完成写入之前，需要完成两次物理写入。这两个写入并行发生，因此时间大致等于单次写入的时间。因为逻辑写入必须等待两个物理写入完成，所以它两个请求中最差的寻道和旋转延迟，因此比写入单个磁盘略高。

分析稳态吞吐量：

- 顺序写入磁盘时，每个逻辑写入必定导致两个物理写入，所以顺序写入镜像阵列期间获得的最大带宽时（N/2●S），即峰值带宽的一半。
- 随机读取，RAID-1提供N●R MB/s

### 38.6 RAID4级：通过奇偶检验节省空间

基于奇偶校验的方法试图使用较少的容量，从而克服由镜像系统付出的巨大空间损失，代价时性能降低。

![image-20210311021135868](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210311021135868.png)

为了计算奇偶性，使用异或（XOR）函数，对于给定的一组比特，如果比特中有偶数个1，则所有这些比特的XOR返回0，如果有奇数个1，则返回1。

*RAID-4 分析*

- 从容量的角度：RAID-4使用1个磁盘作为它所保护的每组磁盘的奇偶校验信息，容量是（N-1）
- 从可靠性的角度：RAID-4容许1个磁盘故障，不容许更多。如果丢失多个磁盘，即无法重建丢失的数据。
- 从性能的角度：连续读取性能利用除奇偶校验磁盘以外的所有磁盘，因此提供（N-1）●S MB/s的峰值有效带宽

RAID-4可以执行一种简单优化，称为全条带写入。

随机读取的有效性能是：（N-1）●R MB/s

RAID-4中的I/O延迟：

- 单次读取只映射到单个磁盘，延迟等同于的那个磁盘请求的延迟。
- 单次写入的延迟需要两次读取，然后两次写入。
- 读写操作可以并行进行，总延迟大约是单个磁盘的两倍

### 38.7 RAID5级：旋转奇偶校验

![image-20210311023326473](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210311023326473.png)

RAID-5的工作原理与RAID-4几乎完全相同，只是它将奇偶检验块跨驱动器旋转

*RAID-5 分析*

RAID-5的大部分分析与RAID-4相同

随机读取性能稍好一点，因为可以利用所有的磁盘

### 38.8 RAID比较 ：总结

![image-20210311023554793](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20210311023554793.png)