# 第1章 简介

## 1.3 线程带来的风险

### 1.3.1 安全性问题

线程安全性是非常复杂的，在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。

### 1.3.2 活跃性问题

当某个操作无法继续执行下去时，就会发生活跃性问题。

## 1.4 线程无处不在

每个Java应用程序都会使用线程。当JVM启动时，它将为JVM的内部任务创建后台线程，并创建一个主线程来运行main方法。

# 第2章 线程安全性

要编写线程安全的代码，其核心在于要对访问操作进行管理，特别是对==共享的==和==可变的==状态的访问。

从非正式的意义上来说，对象的状态是指存储在状态变量中的数据。对象的状态可能包括其他依赖对象的域。在对象的状态中包含了任何可能影响其外部可见行为的数据。

“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。指的是在程序中访问对象的方式，而不是对象要实现的功能。

Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显示锁以及原子变量。

> 当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
>
> - 不在线程之间共享该状态变量
> - 将状态变量修改为不可变的变量
> - 在访问状态变量时使用同步

完全由线程安全类构成的程序不一定就是线程安全的，而线程安全类中也可以包含非线程安全的类。

在任何情况中，只有当类中仅包含自己的状态时，线程安全类才是有意义的。

## 2.1 什么是线程安全性

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，就称这个类是线程安全的。

由于单线程程序也可以看成是一个多线程程序，如果某个类在单线程环境中都不是正确的，那么它肯定不会是线程安全的。

>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

>无状态对象一定是安全的。

## 2.2 原子性

### 2.2.1 竞态条件

最常见的竞态条件类型就是“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步动作。

### 2.2.3 复合操作

要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。

>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作来说，这个操作是一个以原子方式执行的操作。哦              

当在无状态的类中添加一个状态时秒如果该状态完全由线程安全的对象来管理，那么这个类仍是线程安全的。

## 2.3 加锁机制

>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

### 2.3.1 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块。

静态synchronized方法以Class对象作为锁。

Java的内置锁相当于一种互斥体，这意味着最多只有一个线程能持有这种锁。

并发环境中的原子性与事务应用程序中的原子性有着相同的含义——一组语句作为一个不可分割的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。

### 2..3.2 重入

内置锁是可重入的，如果某个线程试图获得一个已经由它自己持有的锁，是可以成功的。

“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。

重入的一种实现方法是为每个锁关联一个获取计数值和一个所有者线程。

## 2.4 用锁来保护状态

对象的内置锁与其状态之间没有内在的关联。

当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某i个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显示地创建锁对象。

一种常见的加锁约定是：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

## 2.5 活跃性与性能

> 当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码时是否需要很常的时间，无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。



## 第3章 对象的共享

###  3.1 可见性

> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结果

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由只之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。

最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

volatile变量是一种比sychronized关键字更轻量级的同步机制。

> 加锁机制既可以确保可见性又可以确保原子性，而volatile变量之后能确保可见性。

当且仅当满足以下所有条件时，才应该使用volatile变量：

- 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
- 该变量不会与其他状态变量一起纳入不变性条件中
- 在访问变量时不需要加锁

### 3.2 发布与逸出

*“发布”*一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。

当某个不应该发布的对象被发布时，这种情况就被称为*逸出*

发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。

当发布某个对象时，可能会间接地发布其他对象。

当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。

### 3.3 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性最简单方式之一。

当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

在Swing中大量使用了线程封闭技术

线程封闭技术的另一种常见应用是JDBC的Connection对象

在Java语言中并没有强制规定某个变量必须由锁来保护，同样在Java语言中也无法强制将对象封闭在某个线程中。

#### 3.3.1 Ad-hoc线程封闭

Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。

在某些情况下，单线程子系统提供的简便性要胜过Ad-hoc线程封闭技术的脆弱性。

在volatile变量上存在一种特殊的线程封闭。

#### 3.3.2 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。

如果在线程内部上下文中使用非线程安全的对象，那么该对象仍然是线程安全的。

#### 3.3.3 ThreadLocal类

维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。

ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。

假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性。

### 3.4 不变性

满足同步需求的另一种方法是使用不可变对象。

如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性时候不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。

> 不可变对象一定是线程安全的。

不可变对象很简单。它们只有一种状态，并且该状态由构造函数来控制。

不可变性不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍是可变的，因为在final类型的域中可以保存对可变对象的引用。

> 当满足以下条件时，对象才是不可变的：
>
> - 对象创建以后其状态就不能修改
> - 对象的所有域都是final类型
> - 对象是正确创建的（在对象的创建期间，this引用没有逸出）

在不可变对象的内部仍可以使用可变对象来管理它们的状态。

#### 3.4.1 Final域

final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

### 3.5 安全发布

> 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。

> 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：
>
> - 在静态初始化函数中初始化一个对象引用
> - 将对象的引用保存到volatile类型的域或者AtomicReferance对象中
> - 将对象的引用保存到某个正确构造对象的final类型域中
> - 将对象的引用保存到一个由锁保护的域中。

#### 3.5.4 事实不可变对象

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”

> 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

#### 3.5.5 可变对象

> 对象的发布需求取决于它的可变性：
>
> - 不可变对象可以通过任意机制来发布
> - 事实不可变对象必须通过安全方式来发布
> - 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

#### 3.5.6 安全地共享对象

> 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
>
> **线程封闭**：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
>
> **只读共享**：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
>
> **线程安全共享**：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
>
> **保护对象**：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

