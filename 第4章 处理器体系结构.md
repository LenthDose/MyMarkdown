

# 第4章 处理器体系结构

一个处理器支持的指令和指令的字节级编码称为它的*指令集体系结构（ISA）*。

因为受x86-64指令集的启发，它被俗称为“x86”，所以我们称我哦们的指令集为“Y86-64”指令集。与x86-64相比，Y86-64指令集的数据类型、指令和寻址方式都要少一些。它的字节级编码也比较简单，机器代码没有相应的x86-64代码紧凑。

## 4.1 Y86-64指令集体系结构

定义一个指令集体系结构包括定义各种状态单元，指令集和它们的编码，一组编程规范和异常事件处理。

### 4.1.1 程序员可见的状态

Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态。

![image-20211208162210320](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162210320.png)

- 每个程序寄存器存储一个64位的字。寄存器*%rsp*被入栈、出栈、调用和返回指令作为栈指针。寄存器没有固定的含义或固定值。

- 3个一位的条件码：ZF、SF和OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。

- 程序计数器(PC)存放当前正在执行指令的地址

- 内存从概念上来说是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译称实际或物理地址，指明数据实际存在内存中哪个地方

- 程序状态的最后一个部分是状态码*Stat*，它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。

  

### 4.1.2 Y86-64指令

Y86-64指令集基本上是x86-64指令集的一个子集。它只包括8字节整数操作，寻址方式较少，操作也较少。

![image-20211208162249026](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162249026.png)

Y86-64指令的一些细节：

- x86-64的*movq*指令分成了4个不同的指令，分别显示地指明源和目的的格式。源可以是立即数(*i*)、寄存器(*r*)或内存(*m*)。指令名字的第一个字母就表明了源的类型。目的可以是寄存器(*r*)或内存(*m*)。指令名字的第二个字母指明了目的的类型。

  两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。在地址计算中，我们不支持第二变址寄存器和任何寄存器值的伸缩。同x86-64一样，我们不允许从一个内存地址直接传送到另一个内存地址，也不允许将立即数传送到内存。

- 有4个整数操作指令。图中的*OPq*。它们是*addq*、*subq*、*andq*和*xorq*。它们只对寄存器数据进行操作，而x86-64还允许内存数据进行这些操作。这些指令会设置3个条件码*ZF*、*SF*和*OF*

- 7个跳转指令是*jmp*、*jle*、*jl*、*je*、*jne*、*jge*和*jg*。根据分支指令的类型和条件代码的设置来选择分支。分支条件和x86-64的一样。

- 有6个条件传送指令：*cmovle*、*cmovl*、*cmove*、*cmovne*、*cmovge'*和*cmovg*。这些指令的格式与寄存器-寄存器传送指令*rrmovq*一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。

- *call*指令将返回地址入栈，然后跳到目的地址。*ret*指令从这样的调用中返回。

- *pushq*和*popq*指令实现了入栈和出栈

- *halt*指令停止指令的执行。x86-64中有一个与之相当的指令*hlt*。x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86-64来说，执行*halt*指令会导致处理器停止，并将状态码设置为*HLT*。

### 4.1.3 指令编码

![image-20211208162413970](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162413970.png)

还给出了指令的字节级编码。每条指令需要1~10个字节不等，这取决于需要哪些字段。每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分4位：高4位是代码(code)部分，低4位是功能(function)部分。代码值为0 ~ 0xB。功能值只有在一组相关指令共用一个代码时才有用。

图给出了整数操作、分支和条件传送指令的具体编码。

![image-20211208162422964](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162422964.png)

15个寄存器中每个都有一个相对应的范围在0到0xE之间的寄存器标识符(register ID)。Y86-64中的寄存器编号跟x86-64中的相同。程序寄存器在CPU中的一个寄存器文件中，这个寄存器文件就是一个小的、以寄存器ID作为地址的随机访问存储器。在指令编码中以及在我们的硬件设计中，当需要指明不应访问任何寄存器时，就用ID值0xF来表示。

![image-20211208162430972](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162430972.png)

有的指令只有一个字节长，而有的需要操作数的指令编码就更长一些。首先，可能有附加的寄存器指示符字节，指定一个或两个寄存器。在图4-2中这些寄存器字段能成为rA和rB。从指令的汇编代码表示中可以看到，根据指令类型，指令可以用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。没有寄存器操作数的指令，例如分支指令和*call*指令，就没有寄存器指示符字节。那些只需要一个寄存器操作数的指令将另一个寄存器指示符设为0xF。

有些指令需要一个附加的4字节常数字。这个字能作为*irmovq*的立即数数据，*rmmovq*和*mrmovq*的地址指示符的偏移量，以及分支指令和调用指令的目的地址。**注意：分支指令和调用指令的目的是一个绝对地址，而不像IA32中那样使用PC相对寻址方式。**

指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码嵌入在程序的其他字节中，只要从序列的第一个字节开始处理，仍然可以很容易地确定指令序列。



### 4.1.4 Y86-64异常

对Y86-64来说，程序员可见的状态包括状态码*Stat*，它描述程序执行的总体状态。

![image-20211208162442897](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162442897.png)

对于Y86-64，当遇到这些异常的时候，就简单地让处理器停止执行指令。在更完整的设计中，处理器通常会调用一个异常处理程序，这个过程被指定用来处理遇到的某种类型的异常。

### 4.1.4 一些Y86-64指令的详情

大多数Y86-64指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意。

*pushq*指令会把指针减8，并且将一个寄存器的值写入内存中。因此，当执行*pushq %rsp*指令时，处理器的行为是不确定的，因为要入栈的寄存器会被同一条指令修改。通常有两种不同的约定：1）压入*%rsp*的原始值，2）压入减去8的%rsp的值

## 4.2 逻辑设计和硬件控制预压HCL

### 4.2.1 逻辑门

逻辑门是数字电路的基本单元。它们产生的输出，等于它们输入位值的某个布尔函数。

![image-20211208162500011](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162500011.png)

逻辑门总是活动的。一旦一个门的输入变化了，在很短的时间内，输出就会相应的变化。

### 4.2.2 组合电路和HCL布尔表达式

将很多的逻辑门组合称一个网，就能构建计算块，称为组合电路。如何构建这些网有几个限制：

- 每个逻辑门的输入必须连接到下述选项之一：1）一个系统输入（称为主输入），2）某个存储器单元的输出，3）某个逻辑门的输出
- 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障
- 这个网必须使无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的贿赂会导致该网络计算的函数有歧义

图4-10是一个简单组合电路的例子

![image-20211208162512528](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162512528.png)

图4-11是一个简单的组合电路，称多路复用器（通常称为“MUX”）

![image-20211208162519757](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162519757.png)

HCL表达式很清楚地表明了组合逻辑电路和C语言中逻辑表达式的对应指出。它们都是用布尔操作来对输入进行计算的函数。这两种表达计算的方法之间有以下区别：

- 因为组合电路是由一系列的逻辑门组成，它的属性是输出持续地相应输入的变化。如果电路的输入变化了，在一定的延迟之后，输出也会相应地变化。相比之下，C表达式只会在程序执行过程中被遇到时才进行求值
- C的逻辑表达式只允许参数时任意整数，0表示FALSE，其他任何值都表示TRUE。而逻辑门只对值0和1进行操作
- C的逻辑表达式有各属性就是它们可能只被部分求值。如果一个AND或OR操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了。

### 4.2.3 字级的组合电路和HCL整数表达式

通常我们设计能对数据字进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。

执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。

![image-20211208162531667](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162531667.png)

在HCL中，我们将所有字级的信号都声明为int，不指定字的大小。

在画字级电路的时候，我们用中等粗度的线来表示携带字的每个位的线路，而用虚线来表示布尔信号结果。

图4-13是字级的多路复用电路。这个电路根据控制输入位*s*，产生一个64位的字*Out*，等于两个输入字*A*或者*B*中的一个。这个电路由64个相同的子电路组成，每个子电路的结构都类似于图4-11中的位级多路复用器。

![image-20211208162547112](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162547112.png)

在HCL中，多路复用函数是用情况表达式来描述的。情况表达式的通用格式如下：

![image-20211208162603484](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162603484.png)

这个表达式包含一系列的情况，每种情况*i*都由一个布尔表达式*select~i~*和一个整数表达式*expr*，前者表明什么时候选择这种情况，后者指明的是得到的值。

![image-20211208162620915](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162620915.png)

算术/逻辑单元（ALU）是一种很重要的组合电路，图4-15是它的一个抽象的图示。这个电路有三个输入：标号为*A*和*B*的两个数据输入，以及一个控制输入。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。

![image-20211208162638453](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162638453.png)



### 4.2.4 集合关系

在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

![image-20211208162646802](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162646802.png)

在这个电路中，两位的信号*code*就可以用来控制对4个数据字A、B、C和D做选择。根据可能的*code*值，可以用相等测试来表示信号*S1*和*S0*的产生：

$bool s1 = code == 2  || code == 3$

$bool s0 = code == 1 || code == 3$

![image-20211208162703676](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162703676.png)

### 4.2.5 存储器和时钟

组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生*时序电路*，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由用一个*时钟*控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：

- *时钟寄存器（简称寄存器）*存储单个位或字。时钟信号控制寄存器加载输入值
- *随机访问存储器（简称内存）*存储多个字，用地址来选择该读或该写哪个字

在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。

在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址是寄存器ID。

寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿沿时，值才会从寄存器的输入传送到输出。Y86-64处理器会用时钟寄存器保存升序计数器（PC）、条件代码（CC）和程序状态（Stat）

![image-20211208162800918](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162800918.png)

寄存器文件由两个*读端口*（A和B），还有一个*写端口*（W）。

![image-20211208162825678](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162825678.png)

这样一个多端口随机访问存储器允许同时进行多个读和写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。

每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个数据输出或对应该程序寄存器的输入值。地址是用图中编码表示的寄存器标识符。两个读端口有地址输入*srcA*和*srcB*和数据输出*valA*和*valB*。写端口有地址输入*dstW*以及数据输入*valW*。

虽然寄存器文件不是组合电路，因为它有内部存储。不过，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。

向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入*valW*上的值会被写入输入*dstW*上的寄存器ID指示的程序寄存器。当*dstW*设为特殊的ID值0xF时，不会写任何程序寄存器。

如果更新一个寄存器，同时在读端口上用一个寄存器ID，会看到一个从旧值到新值的变化。

处理器有一个随机访问存储器来存储程序数据：

![image-20211208162815191](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162815191.png)

这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。同寄存器文件一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入*address*上提供一个地址，并将*write*控制信号设置为0，那么在经过一些延迟之后，存储在那个地址上的值会出现在输出data上。如果地址超出了范围，*error*信号会设置为1，否则就设置为0.写内存是由时钟控制的：我们将*address*设置为期望的地址，将*data in*设置为期望的值，而*write*设置为1.然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读操作来说，如果地址是不合法的，*error*信号会设置为1。这个信号是由组合逻辑产生的，因为所需要的边界检查存储就是地址输入的函数，不涉及保存任何状态。

我们的处理器还包括另外一个只读存储器，用来读指令。大多数实际系统中，这两个存储器被合并为一个具有装端口的存储器：一个用来读指令，另一个用来读或者写数据。

### 4.3 Y86-64的顺序实现

### 4.3.1 将处理组织成阶段

关于各个阶段以及各阶段内执行操作的简略描述：

- **取指**(fetch)：取指阶段从内存读取指令字节，地址为程序计数器(PC)的值。从指令中抽取出指令指示符字节的两个四位部分，称为*icode*(指令代码)和*ifun*(指令功能)。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符*rA*和*rB*。它还可能取出一个四字节常数字*valC*。它按顺序方式计算当前指令的下一条指令的地址*valP*。*valP*等于PC的值加上已取出指令的长度。
- **译码**(decode)：译码阶段从寄存器文件读入最多两个操作数，得到值*valA*和/或*valB*。通常，它读入指令*rA*和*rB*字段指明的寄存器，不过有些指令是读寄存器*%rsp*的。
- **执行**(execute)：在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据*ifun*的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值称为*valE*。也可能设置条件码，对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由*ifun*给出），如果条件成立，则更新目标寄存器。对一条跳转指令来说，这个阶段会决定是不是应该选择分支。
- **访存**(memory)：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为*valM*。
- **写回**(write back)：写回阶段最多可以写两个结果到寄存器文件
- **更新PC**(PC update)：将PC设置成下一条指令的地址。

使用图4-17中所示的代码来描述不同Y86-64指令的处理：

![image-20211208162841186](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162841186.png)

图4-18给出了对*OPq*(整数和逻辑运算)、*rrmovq*(寄存器-寄存器传送)和*irmovq*(立即数-寄存器传送)累的指令所需的处理

![image-20211208162849780](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162849780.png)

整数操作指令的处理遵循上面列出的通用模式。在取值阶段，我们不需要常数字，所以*valP*就计算为PC+2。在译码阶段，我们要读两个操作数。在执行阶段，它们和功能指示符*ifun*一起再提供给ALU，*valE*就成了指令结果。这个计算使用表达式*valB OP valA*来表达的，这里*OP*代表*ifun*指定的操作。这些指令在访存阶段什么也不做，而在写回阶段，*valE*被写入寄存器*rB*，然后PC设为*valP*，整个指令的执行就结束了。

![image-20211208162918228](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162918228.png)

执行*rrmovq*指令和执行算术运算类似。不过，不需要取第二个寄存器操作数。我们将ALU的第二个输入设为0，先把它和第一个操作数相加，得到*valE*= *valA*，然后再把这个值写到寄存器文件。对*irmovq*的处理类似，除了ALU的第一个输入为常数值*valC*。另外，因为是长指令格式，对于*irmovq*，程序计数器必须加10。所有这些指令都不改变条件码。

------

图4-19给出了内存读写指令*rmmovq*和*mrmovq*所需要的处理。用ALU来加*valC*和*valB*，得到内存操作的有效地址(偏移量与基址寄存器值之和)。在访存阶段，会将寄存器值*valA*写到内存，或者从内存中读出*valM*。

![image-20211208162933662](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162933662.png)

![image-20211208162942331](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162942331.png)

------

图4-20给出了处理*pushq*和*popq*指令所需的步骤：

![image-20211208162958569](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208162958569.png)

在译码阶段，用*%rsp*作为第二个寄存器操作数的标识符，将栈指针赋值为*valB*。在执行阶段，用ALU将栈指针减8。减过8的值就是内存写的地址，在写回阶段还会存会到*%rsp*中。将*valE*作为写操作的地址。

![image-20211208163013657](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163013657.png)

*popq*指令的执行与*pushq*的执行类似，除了在译码阶段要读两次栈指针以外。在执行阶段，用ALU给栈指针加8，但是用没加过8的原始值作为内存操作的地址。在写回阶段，要用加过8的栈指针更新栈指针寄存器，还要将寄存器*rA*更新为内存中读出的值。用没加过8的值作为内存读地址。

------

图4-21表明了三类控制转移指令的处理：各种跳转、*call*和*ret*：

![image-20211208163027840](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163027840.png)

在执行阶段，检查条件码和跳转条件来确定是否要选择分支，产生出一个一位信号*Cnd*。在更新PC阶段，检查这个标志，如果这个标志为1，就将PC设为*valC*（跳转目标），如果为0，就设为*valP*（下一条指令的地址）。

![image-20211208163058449](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163058449.png)

对指令*call*，我们要将*valP*，也就是*call*指令后紧跟着的那条指令的地址，压入栈中。在更新PC阶段，将PC设为*valC*，也就是调用目的地。对指令*ret*，在更新PC阶段，将*valM*，即从栈中取出的值，赋值给PC。

![image-20211208163108974](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163108974.png)

![image-20211208163131884](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163131884.png)



### 4.3.2 SEQ硬件结构

![image-20211208163140083](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163140083.png)

- **取指**：将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器计算*valP*，增加了的程序计数器

- **译码**：寄存器文件有两个读端口A和B，从这两个端口同时读寄存器值*valA*和*valB*。

- **执行**：执行阶段会根据指令的类型，将算术/逻辑单元（ALU）用于不同的目的。对于整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或计算有效地址，或者只是简单地加0，将一个输入传递到输出。

  条件码寄存器（CC）有三个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号*Cnd*

- **访存**：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。

- **写回**：寄存器文件有两个写端口，端口E用来写ALU计算出来的值，而端口M用来写从数据内存中读出的值。

- **PC更新**：程序计数器的新值选择自：*valP*，下一条指令的地址；*valC*，调用指令或跳转指令的目标地址；*valM*，从内存读取的返回地址

![image-20211208163152179](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163152179.png)

- ***白色方框表示时钟寄存器。***程序计数器PPC是SEQ中唯一的时钟寄存器
- ***浅蓝色方框表示硬件单元***。这包括内存、ALU等
- ***控制逻辑块用灰色圆角矩形表示***。这些块用来从一组信号源中进行选择，或者用来计算一些布尔函数。
- ***线路的名字在白色圆圈中说明***
- ***宽度为字长的数据连接用中等粗度的线表示***。每条这样的线实际上都代表一簇64根线，并列地连在一起，将一个字从硬件的一个部分传送到另一部分
- ***单个位的连接用虚线来表示***。这代表芯片上单元与块之间传递的控制值。

![image-20211208163210839](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163210839.png)

### 4.3.3 SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备：时钟存储器（程序计数器和条件码寄存器），随机访问存储器（寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或控制——只要输入变化了，值就通过逻辑门网络传播。由于指令内只用来读取指令，可以将这个单元看成是组合逻辑。

这些单元通过一个时钟信号来控制，它触发将新值装在到寄存器以及将值写到随机访问存储器。每个时钟周期，程序计数器都会装载新年的指令地址。只有在执行整数运算指令时，才会装在条件码寄存器。只有在执行*rmmovq*、*pushq*或*call*指令时，才会写数据内存。寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器，可以用页数的寄存器ID*0xF*作为端口地址，来表明在此端口不应该执行写操作。

**原则**：从不回读

*处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态*

![image-20211208163244430](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163244430.png)

![image-20211208163303371](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163303371.png)

### 4.3.4 SEQ阶段的实现

![image-20211208163317123](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163317123.png)

除了图中的指令以外，还包括了对*nop*和*halt*指令的处理。*nop*指令只是简单地经过各个阶段，除了要将PC加1，不进行任何处理。*halt*指令使得处理器状态被设置为*HLT*，导致处理器停止运行。

#### 1.取指阶段

![image-20211208163327995](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163327995.png)

取指阶段包括指令内存硬件单元。以PC作为第一个字节的地址，这个单元一次从内存读出10个字节。

第一个字节被解释成指令字节，（标号为“Split”的单元）分为两个4位的数。标号为”icode“和”ifun“的控制逻辑块计算指令和功能码，或者使之等于从内存读出的值，或者当指令地址不合法时（由信号*imem_error*指明），使这些值对应于*nop*指令。标号为”Align“的硬件单元会处理剩下的9个字节，将它们放入寄存器字段和常数字中。根据*icode*的值，我们可以计算三个一位的信号：

- *instr_valid*：这个信号用来发现不合法的指令
- *need_regids*：当被计算出的信号*need_regids*为1时，字节1被分开装入寄存器指示符rA和rB中，否则，被设为*0xF(RNONE)*，表明没有指明寄存器。
- *need_valC*：根据信号*need_regidsd*的值，要么根据1~8来产生*valC*，要么根据字节2~9来产生

PC增加器硬件单元根据当前的PC以及两个信号*need_regids*和*need_valC*的值，产生信号*valP*。对于PC值*p*、*need_regids*值*r*以及*need_valC*值*i*，增加器产生值*p+1+r+8i*

#### 2.译码和写回阶段

![image-20211208163336675](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163336675.png)

寄存器文件有四个端口。它支持同时进行两个读（在端口A和B上）和两个写（在端口E和M上）。每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器ID，而数据连接是一组64根线路，既可以作为寄存器文件的输出字，也可以作为它的输入字。两个读端口的地址输入为*srcA*和*srcB*，两个写端口的地址输入为*dstA*和*dstB*。如果某个地址宽口上的值为特殊标识符*0xF*，则表明不需要访问寄存器。

根据指令代码*icode*以及寄存器指示值*rA*和*rB*，可能还会根据执行阶段计算出的*Cnd*条件信号。寄存器ID*srcA*表明应该读那个寄存器以产生*valA*。寄存器ID*dstE*表明写端口E的目的寄存器，计算出来的值*valE*将放在那里。

#### 3. 执行阶段

![image-20211208163348507](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163348507.png)

执行阶段包括算术/逻辑端元（ALU）。这个单元根据*alufun*信号的设置，对输入*aluA*和*aluB*执行ADD、SUBTRACT、AND或EXECLUSIVE-OR运算。ALU的输出就是*valE*信号。

执行阶段的第一步就是每条指令的ALU计算。列出的操作数*aluB*在前面，后面是*aluA*，这样是为了爆炸*subq*指令是*valB*减去*valA*。

执行阶段还包括条件码寄存器。标号为”cond“的硬件单元会根据条件码和功能码来确定是否进行条件分支或条件数据传送，它产生信号*Cnd*，用于设置条件传送的*dstE*，也用在条件分支的下一个PC逻辑中。对于其他指令，取决于指令的功能码和条件码的设置，*Cnd*信号可以被设置为1或0。

#### 4. 访存阶段

![image-20211208163356744](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163356744.png)

访存阶段的任务就是读或写程序数据。两个控制块产生内存地址和内存输入数据的值。另外两个产生表明应该执行读操作还是写操作的控制信号。当执行读操作时，数据内存产生值*valM*。

访存阶段最后的功能是根据取值阶段产生的*icode*、*imem_error*、*instr_valid*值以及数据内存产生的*dmem_error*信号，从指令执行的结果来计算状态码*Stat*

#### 5. 更新PC阶段

![image-20211208163406407](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163406407.png)

SEQ中最后一个阶段会产生程序计数器的新值。依据指令的类型和是否要选择分支，新的PC可能是*valC*、*valM*或*valP*

## 4.4 流水线的通用原理

流水线话的一个重要特性的就是提高了系统的***吞吐量***，也就是单位时间内服务的顾客总数，不过也会轻微的增加延迟，也就是服务一个用户所需要的时间。

### 4.4.1 计算流水线

![image-20211208163415401](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163415401.png)

在现代逻辑设计中，电路延迟以微微秒或皮秒(ps)，也就是10^-12^秒为单位来计算。实心的长方形表示这些指令执行的时间。这个实现中，在开始下一条指令之间必须完成前一个。这个系统的最大吞吐量为：

$吞吐量\ = \frac{1条指令}{(20+300)ps} \cdot \frac{1000ps}{1ns} \approx 3.12GIPS$

我们以每秒千兆条指令（GIPS），也就是每秒十亿条指令，为单位来描述吞吐量。从头到尾执行一条指令所需要的时间称为延迟。

假设将系统执行的计算分成三个阶段（A、B和C），每个阶段需要100ps

![image-20211208163424359](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163424359.png)

然后在各个阶段之间放上*流水线寄存器*，这样每条指令都会按照三步经过这个系统，从头到尾需要三个完整的时钟周期。将系统的吞吐量提高到原来的2.67倍，代价是增加了一些硬件，以及延迟的少了增加。延迟变大时由于增加的流水线寄存器的时间开销。

### 4.4.2 流水线操作的详细说明

![image-20211208163431139](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163431139.png)

图4-34给出了前面看到的三阶段流水线的流水线图。流水线阶段之间的指令转移是由时钟信号来控制的，每隔120ps，信号从0上升至1，开始下一组流水线阶段的计算。

![image-20211208163447647](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163447647.png)

图4-35 跟踪了时刻240~360之间的电路活动。

指令*I1*经过阶段C，*I2*经过阶段B，而*I3*经过阶段A。

- ①：就在时刻240时钟上升前，阶段A中计算的指令*I2*的值以及达到了第一个流水线寄存器的输入，但是该寄存器的状态和输出还保持为指令*I1*在阶段A中计算的值。指令*I1*在阶段B中计算的值以及到达了第二个流水线寄存器的输入。
- ②：当时钟上升时，这些输入被加载到流水线寄存器中，称为寄存器的输出。
- ③：阶段A的输入被设置成发起指令*I3*的计算，然后信号传播通过各个阶段的组合逻辑，就像曲线化的波阵面表明的那样，信号可能以不同的速率通过各个不同的部分。
- ④：在时刻360之前，结果只到达流水线寄存器的输入。当时刻360时钟上升时，各条指令会前进经过一个流水线阶段。

可以看到减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输入还不是合法的值。

### 4.4.3 流水线的局限性

#### 1. 不一致的划分

![image-20211208163458281](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163458281.png)

在这个系统中，通过这些阶段的延迟从50ps到150ps不等。通过所有阶段的延迟和仍为300ps，不过，运行时钟的速率是由最慢的阶段的延迟限制。流水线图表明， 每个时钟周期，阶段A都会空闲100ps，而阶段C会空闲50ps，只有阶段B会一直处于活动状态，另外，由于时钟周期减慢了，延迟也增加了。

#### 2. 流水过深，收益反而下降

![image-20211208163507663](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163507663.png)

通过将流水线的阶段数加倍，将性能提高了1.71，虽然将每个计算时钟的时间缩短了两倍，但是由于通过流水线寄存器的延迟，吞吐并没有加倍。这个延迟成了流水线吞吐量的一个制约因素。在这个设计中，这个延迟占到了整个时钟周期的28.6%。

为了提高时钟效率，现代处理器采用了很深的（15或更多的阶段）流水线。

### 4.4.4 带反馈的流水线系统

图4-38举例说明了将流水线引入含有反馈路径的系统中的危险。在原来的系统中，每条指令的结果都反馈给下一条指令。流水线（图4-38b）就说明了这个情况，*I1*的结果称为*I2*的输入，依此类推。

![image-20211208163519632](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163519632.png)

### 4.5.1 SEQ+：重新安排计算阶段

移动PC阶段，使得它的逻辑在时钟周期开始时活动，使它计算当前指令的PC值。在SEQ+中，创建状态寄存器来保存在一条指令执行过程中计算出来的信号。当一个新的时钟周期开始时，这些信号值通过同样的逻辑来计算当前指令的PC。这些寄存器标号为“pIcode”、“pCnd”等等，来指明在任一给定的周期，它们保存的时前一个周期中产生的控制信号。

![image-20211208163542142](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163542142.png)

> SEQ+有一个很奇怪的特色，那就是没有硬件寄存器来存放程序计数器。而是根据前一条指令保存下来的一些状态信息动态地计算PC。这就是一个小小的证明——可以以一种与ISA隐含着的概念模型不同的方式来处实现处理器，只要机器能正确执行任意的机器语言程序

SEQ到SEQ+中状态单元的改变时一种很通用的改进的例子，这种改进称为*电路重定时*。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水席系统中各个阶段之间的延迟。

### 4.5.2 插入流水线寄存器

在创建一个流水线化的Y86-64处理器的最初尝试中，要在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新排列，得到PIPE-处理器，这里的“-”代表这个处理器和最终的处理器设计相比，性能要差一点。



流水线寄存器在该图中用黑色方框表示，每个寄存器包括不同的字段，用白色方框表示。每个流水线寄存器可以存放多个字节和字。白色的方框表示实际的硬件组成。

流水线寄存器按如下方式标号：

- F：保存程序计数器的预测值
- D：位于取指和译码阶段之间。它保存关于最新取出的指令的信息。即将由译码阶段进行处理。
- E：位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息。即将由执行阶段进行处理。
- M：位于执行和访存阶段之间。它保存最新执行的指令结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。
- W：位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成*ret*指令时，它还要向PC选择逻辑提供返回地址。

![image-20211208163732228](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163732228.png)

这个图描述了每条指令通过的流水线各个阶段的行进过程，时间从左往右增大。

![image-20211208163741483](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163741483.png)

指令是自底向上的流动的。周期5时的扩展图表明的流水线阶段，取指阶段在底部，写回阶段在最上面，同流水线与硬件图表明的一样。

### 4.5.3 对信号进行重新排列和标号

顺序实现SEQ和SEQ+在一个时刻只处理一条指令，诸如*valC*、*srcA*和*valE*这样的信号值有唯一的值。在流水线化的设计中，与各个指令相关连的这些值有多个版本，会随着指令一起流过系统。

例如，在PIPE-的详细结构中，有4个标号为“Stat”的白色方框，保存着4条不同状态的状态码。采用的命名机制，通过在信号名前面加上大写的流水线寄存器名字作为前缀，存储在流水线寄存器中的信号可以唯一地被表示。如：*D_stat*、*E_stat*、*M_stat*和*W_stat*。

引用某些在一个阶段内刚刚计算出来的信号。它们的命名时在信号名前面加上小写的阶段名的第一个字母作为前缀，如*f_stat*和*m_stat*。

可以看到整个处理器的实际状态*Stat*时根据流水线寄存器W中的状态值，由写回阶段中的块计算出来的。

SEQ+和PIPE-的译码阶段都产生信号*dstE*和*dstM*，它们指明值*valE*和*valM*的目的寄存器。

在SEQ+中，我们可以将这些信号直接连到寄存器文件写端口的地址输入。

在PIPE-中，会在流水线中一直携带这些信号穿过执行和访存阶段你，直到写回阶段才送到寄存器文件。这样做是为了确保写端口的地址和数据输入是来自同一条指令。否则，会将处于写回阶段的指令的值写入，而寄存器ID却来自于处于译码阶段的指令。

作为一条通用原则，我们要保存一个流水线阶段中的指令的所有信息。

PIPE-中有一个块在相同表示形式的SEQ+中没有的，==那就是译码阶段中标号为“Select A“的块。这个块会从来自流水线寄存器D的*valP*或从寄存器文件A端口中读出的值选择一个，作为流水线寄存器E的值*valA*。==包括这个块是为了减少要携带给流水下寄存器E和M的状态数量。在所有的指令中，只有*call*在访存阶段需要*valP*的值。只有跳转指令在执行阶段（当不需要进行跳转时）需要*valP*的值。而这些指令又都不需要从寄存器文件中读出的值。因此合并这两个信号，将它们作为信号*valA*携带穿过流水线，从而减少流水线寄存器的状态数量。这样做就消除了SEQ和SEQ+中标号为”Data“的块。

流水线寄存器包括一个状态码*Stat*字段，开始时时在取指阶段计算出来的，访存阶段有可能会被修改。

### 4.5.4 预测下一个PC

流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。

如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之和，才知道是否要选择分支。类似地，如果取出的指令是*ret*，要到指令通过访存阶段，才能确定返回地址。

除了条件转移指令和*ret*之外，根据取指阶段中计算出的信息，能够确定下一条指令的地址。对于*call*和*jmp*来说，下一条指令的地址是指令中的常数字*valC*，而对于其他指令来说就是*valP*。因此，通过预测PC的下一个值，在大多数情况下，我们能达到每个时钟周期发射一条新指令的目的。对于条件转移来说，即可以预测选择了分支，新的PC值应为*valC*，也可以预测没有选择分支，那么新PC值应为*valP*。

猜测分支方向并根据猜测开始取指的技术称为*分支预测*。我们的设计只使用了简单的策略，即总是预测选了条件分支，因而预测PC的新值为*valC*。

同条件转移不同，*ret*指令的返回值几乎是无限的，因为返回地址是位于栈顶的字，其内容可以是任意的。在设计中，不会试图对返回地址做任何测试，只是简单地暂停处理新指令，直到*ret*指令通过写回阶段。

PIPE-的取指阶段，如图4-41底部所示，负责预测PC的下一个值，以及为取指选择实际的PC。

标号为”Predict PC“的块会从PC增加器计算出的*valP*和取出的指令中得到*valC*中进行选择。这个值存放在流水线寄存器F中，作为程序计数器的预测值。

标号为”Select PC“的块类似于SEQ+的PC阶段中标号为”PC“的块。它从三个值中选择一个作为指令内存的地址：预测的PC，对于到达流水线寄存器M的不选择分支的指令来说是*valP*的值（存储在寄存器*M_valA*），或是当*ret*指令到达流水线寄存器W（存储在*W_valM*）时的返回地址的值。

### 4.5.5 流水线冒险

将流水线技术引入一个带反馈的系统，当相邻指令间存在相关时会导致出现问题。这些相关有两种形式：

- 数据相关：下一条指令会用到这一条指令计算出的结果
- 控制相关：一条指令要确定下一条指令的位置，例如在执行跳转、调用和返回指令时。

这些相关可能会导致流水线产生计算错误，称为冒险。冒险也分为两类：数据冒险和控制冒险。

不会造成数据冒险的例子：

![image-20211208163848694](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163848694.png)

------

第一个*irmovq*指令已经通过了写回阶段，而第二个*irmovq*还处于写回阶段，对程序寄存器*%rax*的写要到周期7开始，时钟上升，才会发生。结果，会读出*%rax*的错误值。

![image-20211208163856331](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163856331.png)

------

当*irmovq*指令和*addq*指令之间只有一条*nop*指令，必须检查周期5内流水线的行为，此时*addq*已经通过译码阶段，但是寄存器*rdx*还处于写回阶段，而*%rax*还处于访存阶段，会得到两个错误的操作数

![image-20211208163925537](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163925537.png)

------

当去掉*irmovq*指令和*addq*指令之间所有*nop*指令，此时*addq*通过译码阶段，而寄存器*%rdx*处于访存阶段，*%rax*处于执行阶段。

![image-20211208163933506](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163933506.png)

> 数据冒险的类型
>
> - 程序寄存器：寄存器文件的读写是在不同阶段进行的，导致不同指令之间可能出现不希望的相互作用。
> - 程序计数器：更新和读取程序计数器之间的冲突导致了控制冒险。
> - 内存：对数据内存的读和写都发生在访存阶段。在一条读内存的指令到达这个阶段之前，前面所有要写内存的指令都已经完成了这个阶段。另外，在访存阶段中写数据的指令和在取指阶段中读指令也有冲突，因为指令和数据内存访问的是同一个地址空间。
> - 条件码寄存器：在执行阶段中，整数操作会写这些寄存器。条件传送指令会在执行阶段以及条件转移会在访存阶段读这些寄存器。在条件传送或转移到达执行阶段之前，前面所有的整数操作都已经完成了这个阶段了，不会发生冒险
> - 状态寄存器：指令流经流水线的时候，会影响程序状态。我们采用流水线中的每条指令都与一个状态码相关联的机制，使得当异常发生时，处理器能够有条理地停止。

#### 1. 用暂停来避免数据冒险

***暂停***是避免冒险的一直常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样就可以避免数据冒险。

将*addq*指令阻塞在译码阶段时，还必须将紧跟其后的*halt*指令阻塞在取指阶段。通过将程序计数器保持不变就能做到这一点，这样一来，会不断地对*halt*指令进行取指，直到结束。

暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。每次要把一条指令阻塞在译码阶段，就在执行阶段插入一个气泡。气泡就像一个自动产生的*nop*指令——它不会改变寄存器、内存、条件码或程序状态。

![image-20211208163954017](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208163954017.png)

但是这样会导致流水线暂停长达三个周期，严重降低了整体的吞吐量。

#### 2. 用转发来避免数据冒险

与其暂停直到写完成，不如将要写的值传到流水线寄存器E作为源操作数。

下图中的译码阶段逻辑发现，寄存器*%rax*是操作数*valB*的源寄存器，而在写端口E上还有一个对*%rax*的未进行的写。只要将提供到端口E的数据字(信号*W_valE*)作为操作数*valB*的值，就能避免暂停。

![image-20211208164002754](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164002754.png)

这种将结果值直接从一个流水线阶段传到较早阶段的技术称为*数据转发*。数据转发需要在基本的硬件结构中增加一些额外的数据连接和逻辑控制。

![image-20211208164054050](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164054050.png)

程序*prog2~prog4*中描述的转发技术的使用都是将ALU产生的以及目标为写端口E的值进行转发，其实也可以转发从内存中读出的以及其目标为写端口M的值。

从访存阶段，可以转发刚刚从数据内存中读出的值(信号*m_valM*)。从写回阶段，可以转发对端口M为进行的写(信号*W_valM*)。这样一共就有五个不同的转发源(*e_valE*、*m_valM*、*M_valE*、*W_valM*和*W_valE*)，以及两个不同的转发目的(*valA*和*valB*)。

图4-49~图4-51的扩展图还表明译码阶段逻辑能够确定是使用来自寄存器文件的值，还是要用转发过来的值。与每个要写回寄存器文件的值相关的是目的寄存器ID。逻辑会这些ID与源寄存器ID*srcA*和*srcB*相比较，以此来检测是否需要转发。可能有多个目的寄存器ID与一个源ID相等。

![image-20211208164117516](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164117516.png)

标号为”Sel+Fwd A“的块是PIPE-中标号为”Select A“的块的功能与转发逻辑的结合。它允许流水线寄存器E的*valA*为已增加的程序计数器值*valP*，从寄存器我呢见A端口读出的值，或者某个转发过来的值。

标号为”Fwd B“的块实现的是源操作数*valB*的转发逻辑。

#### 3. 加载/使用数据冒险

有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。

![image-20211208164129103](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164129103.png)

如下图所示，可以将暂停和转发结合起来，避免加载/使用数据冒险。这个需要修改控制逻辑，但是可以使用现有的旁路路径。

![image-20211208164141066](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164141066.png)

这种用暂停来处理加载/使用冒险的方法称为*加载互锁*。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。因为只有加载互锁会降低流水线的吞吐量，我们几乎可以实现每个时钟周期发射一条新指令的吞吐量目标。

#### 4. 避免控制冒险

当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。

对于*ret*指令，下面给出了示例程序

![image-20211208164157926](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164157926.png)

图4-55给出了希望流水线如何来处理*ret*指令

![image-20211208164203614](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164203614.png)

*ret*经过译码、执行和访存阶段时，流水线不能做任何有用的活动。只能在流水线中插入三个气泡。一旦*ret*指令到达写回阶段，PC选择逻辑就会将程序计数器设为返回地址，然后取指阶段就会取出位于返回点的指令。

要处理预测错误的分支，考虑下面用汇编代码表示的程序：

![image-20211208164218085](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164218085.png)

![image-20211208164224947](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164224947.png)

### 4.5.6 异常处理

异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。指令集体系结构包括三种不同的内部的异常：

- *halt*指令
- 有非法指令和功能码组合的指令
- 取指或数据读写试图访问一个非法地址

在使用非法指令地址的情况中，没有实际的异常指令，但是想象在非法地址处有一种“虚拟指令”会有所帮助。在一个更完整的设计中，处理器会继续调用异常处理程序，这是操作系统的一部分。

在一个流水线化的系统中，异常处理包括一些细节问题。例如：

1. 可能同时有多条指令会引起异常，必须确定处理器应该向操作系统报告哪个异常。==基本原则是：由流水线最深的指令引起的异常，优先级最高。==
2. 当取出一条指令，开始执行时，导致了一个异常，由于分支预测错误，取消了该指令。
3. 一条指令导致了一个异常，但是它后面的指令在异常指令完成之前改变了部分状态。![image-20211208164248005](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164248005.png)

如果一条指令在其处理中于某个阶段产生了一个异常，*Stat*字段被设置成指示异常的种类。==异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现出现了异常，并停止执行。==

为了避免异常指令之后的指令更新任何程序员可见的状态，当处于访存或写回姐u但中的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或数据内存。

处理细节问题：

当流水线出现一个或多个异常，信息存放在流水线寄存器的状态字段中。异常时间不会对指令流有任何影响，除了会禁止流水线中后面的指令更新程序员可见的状态，直到异常指令到达最后的流水线阶段。

1. 因为指令到达写回阶段的顺序与在非流水线化的处理器中执行的顺序相同，可以保证第二条遇到异常的指令会第一个到达写回阶段，程序停止执行，寄存器W中的状态码会被记录为程序状态。
2. 如果取出了某条指令之后有取消了，所有关于这条指令的异常状态信息也都会被取消。所有导致异常的指令后面的指令都不能改变程序员可见的状态。

### 4.5.7 PIPE各阶段的实现

#### 1. PC选择和取值阶段

![image-20211208164315392](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164315392.png)

PC选择逻辑从三个程序计数器源中进行选择，当一条预测错误的分支进入访存阶段时，会从流水线寄存器M(信号*M_valA*)中读出该指令*valP*的值。当ret指令进入写回阶段时，会从流水线寄存器。其他情况会使用存放在流水线寄存器F(信号*F_predPC*)中的PC的预测值。

![image-20211208164328541](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164328541.png)

当取出的指令为函数调用或跳转时，PC预测逻辑会选择*valC*，否则就选择*valP*

![image-20211208164335547](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164335547.png)

同SEQ不一样，必须䩕指令状态的计算分成两个部分。在取指阶段，可以测试由于指令地址越界引起的内存错误，还可以发现非法指令或*halt*指令，而这必须推迟到访存阶段才能发现非法数据地址。

#### 2. 译码和写回阶段

![image-20211208164348773](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164348773.png)

当*D_icode*与*call*或*jxx*的指令代码相匹配时，这个块就会选择*D_valP*作为它的输出。

有5个不同的转发源，每个都有一个数据字和一个目的寄存器ID：

![image-20211208164358784](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164358784.png)

如果不满足任何转发条件，这个块就应该选择*d_rvalA*作为它的输出，也就是从寄存器端口A中读出的值。

![image-20211208164412615](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164412615.png)

上述代码转发源的顺序优先级是由HCL代码中检测5个目的寄存器ID的顺序来确定的，如果选择了其他任何顺序，对某些程序来说，流水线就会出错。

![image-20211208164617556](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164617556.png)

当转发逻辑必须在两个都以源寄存器为目的值中选择一个，流水线总是给处于最早流水线阶段中的转发源以较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令。只有指令*popq %rsp*会关心在访存或写回阶段中的两个源之间的转发优先级，因为只有这条指令能同时写两个寄存器。

写回阶段的一小部分保持不变。唯一要考虑的特殊情况是当写回阶段有气泡时：![image-20211208164630144](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164630144.png)

#### 3. 执行阶段

![image-20211208164642190](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164642190.png)

信号*e_valE*和*e_dstE*作为转发源，指向译码阶段。一个区别标号为*Set CC*的逻辑信号以*m_stat*和*W_stat*作为输入，这个逻辑决定了是否要更新条件码。这些信号被用来检查一条导致异常的指令正在通过后面的流水线阶段的情况，对任何条件码的更新都会被禁止。

#### 4. 访存阶段

![image-20211208164648970](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164648970.png)

PIPE中没有SEQ中标号为“Data”的块。这个块是用来在数据源*valP*和*valA*中选择的，但是现在由译码阶段中标号为’Sel+Fwd A“的块来指向。

### 4.5.8 流水线控制逻辑

#### 2. 发现特殊控制条件

![image-20211208164727931](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164727931.png)

- 当*ret*指令通过流水线时，要想发现它，只要检查译码、指向和访存阶段中指令的指令码。
- 发现加载/使用冒险要检查执行阶段中的指令类型，并把它的目的寄存器与译码阶段中指令的源寄存器相比较。
- 当跳转指令在执行阶段时，流水线控制逻辑应该能发现预测错误的分支，当指令进入访存阶段时，它就能设置从错误预测中恢复所需要的条件。当指令处于执行阶段时，信号*e_Cnd*指明是否要选择分支。
- 通过检查访存和写回阶段中的指令状态值，就能发现异常指令。对于访存阶段，使用在这个阶段中计算出来的信号*m_stat*，而不是使用流水线寄存器的*M_stat*。这个内部信号包含着可能的数据内存地址错误

#### 3. 流水线控制机制

- 在正常操作下，这两个输入都设为0，使得寄存器加载它的输入作为新的状态。
- 当暂停信号设为1时，禁止更新状态，寄存器保持它以前的状态，这使得它可以将指令阻塞在某个流水线阶段中。
- 当气泡信号设置为1实，寄存器状态会设置成某个固定的复位位置，得到一个等效于*nop*指令的的状态。一个流水线寄存器的复位配置的0、1模式是由流水线寄存器中字段的集合决定的。

![image-20211208164737944](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164737944.png)

下图给出了各个流水线寄存器在三种特殊情况下应该采取的行动。

![image-20211208164746705](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164746705.png)

#### 4. 控制条件的组合

图中所示的是译码、执行和访存阶段的块。暗色的方框代表要出现这种条件必须要满足的特别限制。

![image-20211208164753134](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164753134.png)

从图中可以看出，大多数控制条件是互斥的。只有用箭头标明的两种组合可能同时出现。

组合A中执行阶段中有一条不选择分支的跳转指令，而译码阶段中有一条*ret*指令。出现这种组合要求*ret*位于不选择分支的目标处。流水线控制逻辑应该发现分支预测错误，因此取消*ret*指令。

合并组合A条件的控制动作，得到以下流水线控制动作：

![image-20211208164800914](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164800914.png)

组合情况A的处理与预测错误的分支相似，只不过在取指阶段是暂停。在下一个周期，PC选择逻辑会选择跳转后面那条指令的地址，而不是预测的程序计数器值，所以流水线寄存器F发生了什么是没关系的。

组合B包括一个加载/使用冒险，其中加载指令设置寄存器*%rsp*，然后*ret*指令用这个寄存器作为源操作数，因为它必须从栈中弹出返回地址。流水线控制逻辑应该将*ret*指令阻塞在译码阶段。

合并组合B条件的控制动作，得到以下流水线控制动作。

![image-20211208164807505](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164807505.png)

#### 5.控制逻辑实现

图4-68是流水线控制逻辑的整体结构

![image-20211208164815934](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164815934.png)

### 4.5.9 性能分析

可以通过计算PIPE执行一条指令所需要的平均时钟周期数的估计值，来量化这些处罚对整体性能的影响，这种衡量方法称为CPI(Cycles Per Instruction,每指令周期数)。这种衡量值是流水线平均吞吐量的倒数，不过时间单位是时钟周期，而不是微微秒。

如果忽略异常带来的性能损失，另一种思考CPI的方法是，每个周期，执行阶段要么会处理一条指令，然后这条指令继续通过剩下的阶段，直到完成；要么会处理一个由于三种特殊情况之一而插入的气泡。如果这个阶段一共处理了*C~i~*条指令和*C~b~*个气泡，那么处理器总共需要大约*C~i~+C~b~*个时钟周期来执行*C~i~*指令。可以用下面的方法来计算这个基准程序的CPI：

$CPI = \frac{C_i+C_b}{C_i} = 1.0 \ + \frac{C_b}{C_i}$

这个项表明执行一条指令平均要插入多少个气泡。因为只有三种指令类型会导致插入气泡，可以将这个处罚项分成解分成三个部分：

$CPI  = 1.0 + lp + mp+rp$

*lp*是加载处罚插入气泡的平均数，*mp*是预测错误分支处罚，*rp*是*ret*返回处罚。

为了估计每种处罚，需要知道相关指令的出现频率，以及对每种指令特殊情况出现的频率。对CPI的计算，使用下面这组频率：

- 加载指令占所有执行指令的25%。其中20%会导致加载/使用冒险
- 条件分支指令占所有执行指令的20%，其中60%会选择分支，而40%不选择分支
- 返回指令占所有执行指令的2%

![image-20211208164832966](C:\Users\Silhouette76\AppData\Roaming\Typora\typora-user-images\image-20211208164832966.png)

